##
## This append modifies the meta-ide-support recipe to generate a
## cross-development SDK.
## This modifies the original meta-ide-support recipe to generate a
## cross-development SDK that:
##    - Can be installed by app developers on any machine, irrespective of whether
##      they have access to the original bitbake tree where the SDK was generated
##    - Contains the sysroots needed for cross-development
##    - Contains the external cross toolchain used to develop the distro
##
## It changes the recipe as follows:
##    - Modifies the do_populate_ide_support to not call
##      toolchain_create_tree_env_script from toolchain-scripts.bbclass.
##    - Instead, it starts by calling update_installer_script that updates a script that
##      installs the SDK at a desired location. (See Installer Script below)
##    - Then it calls our own create_environment_script function
##       - followed by our own create_toolchain_shared_env_script
##       - Both these functions take similar functions from the original class, but
##         set enviroment variables to paths that are not absolute. They generate
##         paths relative to $SDK_DIR, which makes it easy to move the SDK and just
##         set the SDK_DIR variable at the top of the environment-setup-<target> file
##    - Then it calls create_package which creates a tarball that includes:
##       - The sysroots
##       - The environment-setup-<target> file
##       - An installer script
##       - An example app
##
## Installer Script:
## =========
## The installer script starts off as a file with patterns in it. The function
## update_installer_script replaces patterns with recipe variables,
## e.g. %PATTERN_GCC_URL% with ${QRL_GCC_URL}.
##
## The script itself takes as argument the target location where to install
## the SDK, and does the following:
##    - Installs the sysroots at the target location
##    - Installs the example app at the target location
##    - Modifies the environment-setup-<target> script to use this location
## 

# The OECORE variable isn't available to this recipe, so we have to compute it here   
QRL_OECORE = "${@os.path.dirname(bb.data.getVar('TOPDIR', d,1))}"

# The name used for the installer script generated by this recipe
QRL_SDK_INSTALL_SCRIPT ?= "qrlSDKInstaller.sh"

# The name used for the tarball  generated by this recipe
QRL_SDK_TARBALL_NAME ?= "qrlSDK.tgz"

# The name used for the sysroots tarball
QRL_SDK_SYSROOTS_TARBALL_NAME ?= "qrlSysroots.tgz"

# Download this gcc from the specified URL
QRL_GCC_NAME ?= "gcc-linaro-arm-linux-gnueabihf-4.8-2013.08_linux"
QRL_GCC_URL  ?= "https://releases.linaro.org/archive/13.08/components/toolchain/binaries"

FILESEXTRAPATHS_prepend := "${THISDIR}/files:"

SRC_URI += "file://README"
SRC_URI += "file://hello.c"
SRC_URI += "file://Makefile"
SRC_URI += "file://${QRL_SDK_INSTALL_SCRIPT}"

#########################################
##
## Ugh. We need to find a better way to copy sample app files from the
## "files" location to a subdir under S. Enumerating each file can get tedious
## if the sample app(s) grow
## 
do_unpack_append() {
    import shutil
    import os
    src = d.getVar('WORKDIR', True)
    dest = d.getVar('S', True)
    if os.path.exists(dest):
        shutil.rmtree(dest)
    os.mkdir(dest)
    shutil.copy(src+"/${QRL_SDK_INSTALL_SCRIPT}", dest)
    shutil.copy(src+"/README", dest)
    dest = dest+'/sample'
    os.mkdir(dest)
    shutil.copy(src+"/hello.c", dest)
    shutil.copy(src+"/Makefile", dest)
}

#########################################
##
## Function used to replace $TMPDIR with $SDK_DIR
## 
normalizePath_TMPDIR () {
   path=$1
   path=`echo ${path} | awk 'gsub ( "${TMPDIR}", "$\{SDK_DIR\}" )'`
   echo ${path}
}

#########################################
##
## Function used to replace refs. to build tree with $SDK_DIR, specifically for
## XXXFLAG variables, e.g. CC_FLAGS
## 
normalizePath_FLAGS () {
   path=$1
   # Replace all references to build tree with SDK_DIR
   path=`echo ${path} | awk 'gsub ( "${QRL_OECORE}/build/..", "$\{SDK_DIR\}" )'`
   echo ${path}
}

#########################################
##
## Function used to modify the PATH variable, to add gcc and other native binaries.
## 
modifyPath () {
    newPath="\${SDK_DIR}/${QRL_GCC_NAME}/bin:\$PATH:\${SDK_DIR}/sysroots/x86_64-linux/usr/sbin:\${SDK_DIR}/sysroots/x86_64-linux/usr/bin:\${SDK_DIR}/sysroots/x86_64-linux/sbin:\${SDK_DIR}/sysroots/x86_64-linux/bin"
    echo ${newPath}
}

#########################################
create_environment_script () {
	script=${S}/environment-setup-${REAL_MULTIMACH_TARGET_SYS}
	rm -f $script
	touch $script
	# For some reason I need to call these functions here, else they aren't
	# available inside the echo commands below
        x=$(normalizePath_TMPDIR ${PKG_CONFIG_SYSROOT_DIR})
        x=$(modifyPath)
	
	echo 'SDK_DIR=' >> $script
	echo -n "export PATH=\"" >> $script
	echo -n $(modifyPath) >> $script
	echo "\"" >> $script
	echo "export PKG_CONFIG_SYSROOT_DIR=\"$(normalizePath_TMPDIR ${PKG_CONFIG_SYSROOT_DIR})\"" >> $script
	echo "export PKG_CONFIG_PATH=\"$(normalizePath_TMPDIR ${PKG_CONFIG_PATH})\"" >> $script
	echo "export SDKTARGETSYSROOT=\"$(normalizePath_TMPDIR ${STAGING_DIR_TARGET})\"" >> $script
	echo "export OECORE_NATIVE_SYSROOT=\"$(normalizePath_TMPDIR ${STAGING_DIR_NATIVE})\"" >> $script
	echo "export OECORE_TARGET_SYSROOT=\"$(normalizePath_TMPDIR ${STAGING_DIR_TARGET})\"" >> $script
	echo "export OECORE_ACLOCAL_OPTS=\"-I $(normalizePath_TMPDIR ${STAGING_DIR_NATIVE})/usr/share/aclocal\"" >> $script

	create_toolchain_shared_env_script
}

#########################################
create_toolchain_shared_env_script () {
	echo 'export CC="${TARGET_PREFIX}gcc ${TARGET_CC_ARCH} --sysroot=$SDKTARGETSYSROOT"' >> $script
	echo 'export CXX="${TARGET_PREFIX}g++ ${TARGET_CC_ARCH} --sysroot=$SDKTARGETSYSROOT"' >> $script
	echo 'export CPP="${TARGET_PREFIX}gcc -E ${TARGET_CC_ARCH} --sysroot=$SDKTARGETSYSROOT"' >> $script
	echo 'export AS="${TARGET_PREFIX}as ${TARGET_AS_ARCH}"' >> $script
	echo 'export LD="${TARGET_PREFIX}ld ${TARGET_LD_ARCH} --sysroot=$SDKTARGETSYSROOT"' >> $script
	echo 'export GDB=${TARGET_PREFIX}gdb' >> $script
	echo 'export STRIP=${TARGET_PREFIX}strip' >> $script
	echo 'export RANLIB=${TARGET_PREFIX}ranlib' >> $script
	echo 'export OBJCOPY=${TARGET_PREFIX}objcopy' >> $script
	echo 'export OBJDUMP=${TARGET_PREFIX}objdump' >> $script
	echo 'export AR=${TARGET_PREFIX}ar' >> $script
	echo 'export NM=${TARGET_PREFIX}nm' >> $script
	echo 'export M4=m4' >> $script
	echo 'export TARGET_PREFIX=${TARGET_PREFIX}' >> $script
	echo 'export CONFIGURE_FLAGS="--target=${TARGET_SYS} --host=${TARGET_SYS} --build=${SDK_ARCH}-linux --with-libtool-sysroot=$SDKTARGETSYSROOT"' >> $script
        # Again, need to call this out here, before I can use in echo further down
        x=$(normalizePath_FLAGS ${TARGET_CFLAGS})
 	echo "export CFLAGS=\"$(normalizePath_FLAGS ${TARGET_CFLAGS})\"" >> $script
	echo "export CXXFLAGS=\"$(normalizePath_FLAGS ${TARGET_CXXFLAGS})\"" >> $script
	echo "export LDFLAGS=\"$(normalizePath_FLAGS ${TARGET_LDFLAGS})\"" >> $script
	echo "export CPPFLAGS=\"$(normalizePath_FLAGS ${TARGET_CPPFLAGS})\"" >> $script
	echo 'export OECORE_DISTRO_VERSION="${DISTRO_VERSION}"' >> $script
	echo 'export OECORE_SDK_VERSION="${SDK_VERSION}"' >> $script
	echo 'export ARCH=${ARCH}' >> $script
	echo 'export CROSS_COMPILE=${TARGET_PREFIX}' >> $script
}

#########################################
##
## Creates the installer script
## 
update_installer_script () {
	script=${S}/${QRL_SDK_INSTALL_SCRIPT}
        envFile=environment-setup-${REAL_MULTIMACH_TARGET_SYS}
        tc=`basename ${EXTERNAL_TOOLCHAIN}`
        sed -i "s|%PATTERN_SDK_DIR%|${SDK_DIR}|" $script
        sed -i "s|%PATTERN_ENV_FILE%|${envFile}|" $script
        sed -i "s|%PATTERN_SYSROOTS_TGZ%|${QRL_SDK_SYSROOTS_TARBALL_NAME}|" $script
        sed -i "s|%PATTERN_GCC%|${tc}|" $script
        sed -i "s|%PATTERN_GCC_URL%|${QRL_GCC_URL}|" $script
	chmod +x $script

}

#########################################
setup_linux_headers_and_src () {
    sysrootDir=${1}

    # To create a properly named linux-headers-uname-r link we need the linux version.
    # There isn't a good OE way of finding the version in this recipe, so just try
    # to find the directory under lib/modules instead.
    linux_ver="UNKNOWN"
    for f in ${sysrootDir}/lib/modules/*${MACHINE}*
    do
	linux_ver=$(basename $f)
    done

    # Ok, now we can create a symlink in the sysroot for /usr/src/linux-headers-<linux_ver>
    # to point to /usr/include/linux-headers.
    # Similarly create a symlink /lib/modules/linux-ver/build to point to /usr/src/linux-headers-<linux_ver>
    # However, these links have to be relative, so cd to the appropriate directory before making the links
    (
	if [[ ${linux_ver} != "UNKNOWN" ]]
	then
	    cd ${sysrootDir}/usr/src
	    ln -sf ../include/linux-headers linux-headers-${linux_ver}
	    cd ${sysrootDir}/lib/modules/${linux_ver}
	    ln -sf ../../../usr/src/linux-headers-${linux_ver} build
	else
	    bbwarn "Error creating link for linux-headers-${linux_ver} in the sysroot because linux version wasn't found"
	fi
    )
}

#########################################
setup_sysroots () {
        # We create a new sysroot for packaging:
        #    - First create the ARM sysroot
        #       - First bring in the appropriate directories from our open-embedded build
        #       - Layer in the missing stuff from the Linaro rootfs we've built earlier
        #       - Do some cleanup and setup for the linux headers
        #       - Remove some of the directories that are problematic or not needed
        #    - Next create the native (x86_64) sysroot, in case something is needed from it

        # Create a new location for assembling the sysroot
	sysrootDir=${WORKDIR}/${1}/${MACHINE}
	sysrootDirNative=${WORKDIR}/${1}/x86_64-linux
        mkdir -p ${sysrootDir}
        mkdir -p ${sysrootDirNative}
        
	dirsFromLinaroRootFS="lib usr/lib usr/include"
	dirsFromOE="lib usr/lib usr/include usr/src usr/share"

	# First copy OE directories
	for d in ${dirsFromOE}
	do
	    # If 'd' contains 'usr', add '/usr' to the destination dir
	    destDir=${sysrootDir}
	    if [[ ${d} == *usr* ]]; then destDir=${sysrootDir}/usr; fi
	    rsync --links --recursive  ${STAGING_DIR_HOST}/${d} ${destDir}
	done

	for d in ${dirsFromLinaroRootFS}

	# Now layer in Linaro. Notice the --ignore-existing option
	do
	    destDir=${sysrootDir}
	    # If 'd' contains 'usr', add '/usr' to the destination dir
	    if [[ ${d} == *usr* ]]; then destDir=${sysrootDir}/usr; fi
	    rsync --links --recursive --ignore-existing ${STAGING_DIR_HOST}/linaro-rootfs/${d} ${destDir}
	done

	setup_linux_headers_and_src ${sysrootDir}

	# Now do some other cleanup
	dirsToRemove="usr/lib/arm-linux-gnueabihf lib/terminfo lib/firmware lib/systemd lib/modules/*linaro*"
	for d in ${dirsToRemove}
	do
	    rm -rf ${sysrootDir}/${d}
	done

	# Finally, the native sysroot
        rsync --links --recursive  ${STAGING_DIR_NATIVE}/ ${sysrootDirNative}
}
	
#########################################
create_package () {
	sdkSysrootLocation=sysroots
        setup_sysroots ${sdkSysrootLocation}
        tar -zcf ${S}/${QRL_SDK_SYSROOTS_TARBALL_NAME} -C ${WORKDIR} ${sdkSysrootLocation}
        tar -zcf ${S}/${QRL_SDK_TARBALL_NAME} -C ${S} README ${QRL_SDK_SYSROOTS_TARBALL_NAME} ${QRL_SDK_INSTALL_SCRIPT} environment-setup-${REAL_MULTIMACH_TARGET_SYS} sample
        deployDir="${DEPLOY_DIR}/sdk"
        mkdir -p $deployDir
        cp ${S}/${QRL_SDK_TARBALL_NAME} $deployDir
}

#########################################
do_populate_ide_support () {
        update_installer_script
        create_environment_script
        create_package
}

