--- a/dpkg-deb/build.c
+++ b/dpkg-deb/build.c
@@ -432,16 +432,87 @@
   return path;
 }
 
+/* Now that we have verified everything its time to actually
+ * build something. Let's start by making the ar-wrapper. */
+static int debar_open(const char *debar) {
+  int arfd = creat(debar, 0644);
+  if (arfd < 0)
+    ohshite(_("unable to create `%.255s'"), debar);
+  return arfd;
+}
+
+/* We have our first file for the ar-archive. Write a header for it
+ * to the package and insert it. */
+static void debar_write_control(int gzfd, int arfd, const char *debar) {
+  struct dpkg_error err;
+  if (deb_format.major == 0) {
+    struct stat controlstab;
+    char versionbuf[40];
+
+    if (fstat(gzfd, &controlstab))
+      ohshite(_("failed to stat temporary file (%s)"), _("control member"));
+    sprintf(versionbuf, "%-8s\n%jd\n", OLDARCHIVEVERSION,
+            (intmax_t)controlstab.st_size);
+    if (fd_write(arfd, versionbuf, strlen(versionbuf)) < 0)
+      ohshite(_("error writing `%s'"), debar);
+    if (fd_fd_copy(gzfd, arfd, -1, &err) < 0)
+      ohshit(_("cannot copy '%s' into archive '%s': %s"), _("control member"),
+             debar, err.str);
+  } else if (deb_format.major == 2) {
+    const char deb_magic[] = ARCHIVEVERSION "\n";
+
+    dpkg_ar_put_magic(debar, arfd);
+    dpkg_ar_member_put_mem(debar, arfd, DEBMAGIC, deb_magic, strlen(deb_magic));
+    dpkg_ar_member_put_file(debar, arfd, ADMINMEMBER, gzfd, -1);
+  } else {
+    internerr("unknown deb format version %d.%d", deb_format.major, deb_format.minor);
+  }
+  close(gzfd);
+}
+
+/* Okay, we have data.tar as well now, add it to the ar wrapper. */
+static void debar_write_data(int gzfd, int arfd, const char *debar) {
+  char datamember[16 + 1];
+  if (deb_format.major == 2) {
+
+    sprintf(datamember, "%s%s", DATAMEMBER,
+            compressor_get_extension(compress_params.type));
+
+    if (lseek(gzfd, 0, SEEK_SET))
+      ohshite(_("failed to rewind temporary file (%s)"), _("data member"));
+
+    dpkg_ar_member_put_file(debar, arfd, datamember, gzfd, -1);
+
+    close(gzfd);
+  }
+}
+
+/* Create a temporary file to store the control data in. Immediately
+ * unlink our temporary file so others can't mess with it. */
+static int open_tempfd(void) {
+  char *tfbuf;
+  int gzfd;
+
+  tfbuf = path_make_temp_template("dpkg-deb");
+  gzfd = mkstemp(tfbuf);
+  if (gzfd == -1)
+    ohshite(_("failed to make temporary file (%s)"), _("control member"));
+  /* Make sure it's gone, the fd will remain until we close it. */
+  if (unlink(tfbuf))
+    ohshit(_("failed to unlink temporary file (%s), %s"), _("control member"),
+           tfbuf);
+  free(tfbuf);
+  return gzfd;
+}
+
 /**
  * Overly complex function that builds a .deb file.
  */
 int
 do_build(const char *const *argv)
 {
-  struct dpkg_error err;
   const char *debar, *dir;
   bool subdir;
-  char *tfbuf;
   int arfd;
   int p1[2], p2[2], gzfd;
   pid_t c1, c2;
@@ -493,9 +564,8 @@
 
   /* Now that we have verified everything its time to actually
    * build something. Let's start by making the ar-wrapper. */
-  arfd = creat(debar, 0644);
-  if (arfd < 0)
-    ohshite(_("unable to create `%.255s'"), debar);
+  arfd = debar_open(debar);
+
   /* Fork a tar to package the control-section of the package. */
   unsetenv("TAR_OPTIONS");
   m_pipe(p1);
@@ -512,15 +582,7 @@
   close(p1[1]);
   /* Create a temporary file to store the control data in. Immediately
    * unlink our temporary file so others can't mess with it. */
-  tfbuf = path_make_temp_template("dpkg-deb");
-  gzfd = mkstemp(tfbuf);
-  if (gzfd == -1)
-    ohshite(_("failed to make temporary file (%s)"), _("control member"));
-  /* Make sure it's gone, the fd will remain until we close it. */
-  if (unlink(tfbuf))
-    ohshit(_("failed to unlink temporary file (%s), %s"), _("control member"),
-           tfbuf);
-  free(tfbuf);
+  gzfd = open_tempfd();
 
   /* And run gzip to compress our control archive. */
   c2 = subproc_fork();
@@ -541,32 +603,9 @@
   if (lseek(gzfd, 0, SEEK_SET))
     ohshite(_("failed to rewind temporary file (%s)"), _("control member"));
 
-  /* We have our first file for the ar-archive. Write a header for it
-   * to the package and insert it. */
-  if (deb_format.major == 0) {
-    struct stat controlstab;
-    char versionbuf[40];
-
-    if (fstat(gzfd, &controlstab))
-      ohshite(_("failed to stat temporary file (%s)"), _("control member"));
-    sprintf(versionbuf, "%-8s\n%jd\n", OLDARCHIVEVERSION,
-            (intmax_t)controlstab.st_size);
-    if (fd_write(arfd, versionbuf, strlen(versionbuf)) < 0)
-      ohshite(_("error writing `%s'"), debar);
-    if (fd_fd_copy(gzfd, arfd, -1, &err) < 0)
-      ohshit(_("cannot copy '%s' into archive '%s': %s"), _("control member"),
-             debar, err.str);
-  } else if (deb_format.major == 2) {
-    const char deb_magic[] = ARCHIVEVERSION "\n";
-
-    dpkg_ar_put_magic(debar, arfd);
-    dpkg_ar_member_put_mem(debar, arfd, DEBMAGIC, deb_magic, strlen(deb_magic));
-    dpkg_ar_member_put_file(debar, arfd, ADMINMEMBER, gzfd, -1);
-  } else {
-    internerr("unknown deb format version %d.%d", deb_format.major, deb_format.minor);
-  }
-
-  close(gzfd);
+  /* We have our first file for the ar-archive. Re-wind the temp file, write
+   * a header for it to the package and insert it. */
+  debar_write_control(gzfd, arfd, debar);
 
   /* Control is done, now we need to archive the data. */
   if (deb_format.major == 0) {
@@ -577,15 +616,7 @@
   } else if (deb_format.major == 2) {
     /* Start by creating a new temporary file. Immediately unlink the
      * temporary file so others can't mess with it. */
-    tfbuf = path_make_temp_template("dpkg-deb");
-    gzfd = mkstemp(tfbuf);
-    if (gzfd == -1)
-      ohshite(_("failed to make temporary file (%s)"), _("data member"));
-    /* Make sure it's gone, the fd will remain until we close it. */
-    if (unlink(tfbuf))
-      ohshit(_("failed to unlink temporary file (%s), %s"), _("data member"),
-             tfbuf);
-    free(tfbuf);
+    gzfd = open_tempfd();
   } else {
     internerr("unknown deb format version %d.%d", deb_format.major, deb_format.minor);
   }
@@ -621,19 +652,95 @@
   subproc_wait_check(c2, _("<compress> from tar -cf"), 0);
   subproc_wait_check(c1, "tar -cf", 0);
   /* Okay, we have data.tar as well now, add it to the ar wrapper. */
-  if (deb_format.major == 2) {
-    char datamember[16 + 1];
+  debar_write_data(gzfd, arfd, debar);
+  if (fsync(arfd))
+    ohshite(_("unable to sync file '%s'"), debar);
+  if (close(arfd))
+    ohshite(_("unable to close file '%s'"), debar);
 
-    sprintf(datamember, "%s%s", DATAMEMBER,
-            compressor_get_extension(compress_params.type));
+  return 0;
+}
 
-    if (lseek(gzfd, 0, SEEK_SET))
-      ohshite(_("failed to rewind temporary file (%s)"), _("data member"));
+int do_tarbuild(const char *const *argv) {
+  const char *debar;
+  const char *ctar;
+  const char *dtar;
+  struct compress_params params;
+  int arfd, gzfd, gzfd2;
+  int cfd = -1;
+  int dfd = -1;
+  struct stat statbuf;
+
+  if (!(ctar = *argv++))
+    badusage(_("--tarbuild needs a control tar argument"));
+  if (!(dtar = *argv++))
+    badusage(_("--tarbuild needs a data tar argument"));
+  if (!(debar = *argv++))
+    badusage(_("--tarbuild needs a deb argument"));
+  if (*argv)
+    badusage(_("--tarbuild takes exactly three arguments"));
+
+  if (stat(ctar, &statbuf) || (!S_ISREG(statbuf.st_mode)))
+    ohshite(_("archive `%.250s' does not exist or is not a regular file"),
+	        ctar);
+  if (stat(dtar, &statbuf) || (!S_ISREG(statbuf.st_mode)))
+    ohshite(_("archive `%.250s' does not exist or is not a regular file"),
+	        dtar);
+
+  arfd = debar_open(debar);
+  if (arfd < 0) {
+      ohshite(_("unable to open temp arfd file descriptor"));
+  }
+  gzfd = open_tempfd();
+  if (gzfd < 0) {
+      ohshite(_("unable to open temp gzfd file descriptor"));
+  }
 
-    dpkg_ar_member_put_file(debar, arfd, datamember, gzfd, -1);
+  /* And run gzip to compress our control archive. */
+  /* Gzip needs a duplicate file descriptor because it closes it when the
+   * compression is completed */
+  gzfd2 = dup(gzfd);
+  if (gzfd2 < 0) {
+      ohshite(_("unable to open temp gzfd2 file descriptor"));
+  }
 
-    close(gzfd);
+  params.type = compressor_type_gzip;
+  params.strategy = compressor_strategy_none;
+  params.level = 9;
+  cfd = open(ctar, O_RDONLY);
+  if (cfd < 0) {
+    ohshite(_("failed to open cfd"));
   }
+  compress_filter(&params, cfd, gzfd2, _("compressing control member"));
+
+  /* We have our first file for the ar-archive. Re-wind the temp file, write
+   * a header for it to the package and insert it. */
+  if (lseek(gzfd, 0, SEEK_SET))
+    ohshite(_("failed to rewind temporary file (%s)"), _("control member"));
+  debar_write_control(gzfd, arfd, debar);
+  close(cfd);
+  cfd = -1;
+  close(gzfd);
+  gzfd = -1;
+
+  /* Now we do the data compression */
+  gzfd = open_tempfd();
+  dfd = open(dtar, O_RDONLY);
+  if (dfd < 0) {
+    ohshite(_("failed to open dfd"));
+  }
+
+  compress_filter(&compress_params, dfd, gzfd, _("compressing data member"));
+
+  /* Okay, we have data.tar as well now, add it to the ar wrapper. */
+  if (lseek(gzfd, 0, SEEK_SET))
+    ohshite(_("failed to rewind temporary file (%s)"), _("data member"));
+  debar_write_data(gzfd, arfd, debar);
+  close(dfd);
+  dfd = -1;
+  close(gzfd);
+  gzfd = -1;
+
   if (fsync(arfd))
     ohshite(_("unable to sync file '%s'"), debar);
   if (close(arfd))
unchanged:
--- a/dpkg-deb/dpkg-deb.h
+++ b/dpkg-deb/dpkg-deb.h
@@ -34,6 +34,8 @@ action_func do_extract;
 action_func do_vextract;
 action_func do_raw_extract;
 action_func do_fsystarfile;
+action_func do_tarbuild;
+action_func do_controltarfile;
 
 extern int opt_verbose;
 extern int debugflag, nocheckflag;
unchanged:
--- a/dpkg-deb/extract.c
+++ b/dpkg-deb/extract.c
@@ -366,9 +366,7 @@ extracthalf(const char *debar, const char *dir,
   }
 }
 
-int
-do_fsystarfile(const char *const *argv)
-{
+int extract_tarfile(const char *const *argv, int admin) {
   const char *debar;
 
   debar = *argv++;
@@ -376,11 +374,19 @@ do_fsystarfile(const char *const *argv)
     badusage(_("--%s needs a .deb filename argument"),cipaction->olong);
   if (*argv)
     badusage(_("--%s takes only one argument (.deb filename)"),cipaction->olong);
-  extracthalf(debar, NULL, DPKG_TAR_PASSTHROUGH, 0);
+  extracthalf(debar, NULL, DPKG_TAR_PASSTHROUGH, admin);
 
   return 0;
 }
 
+int do_fsystarfile(const char *const *argv) {
+  return extract_tarfile(argv, 0);
+}
+
+int do_controltarfile(const char *const *argv) {
+  return extract_tarfile(argv, 1);
+}
+
 int
 do_control(const char *const *argv)
 {
unchanged:
--- a/dpkg-deb/main.c
+++ b/dpkg-deb/main.c
@@ -82,7 +82,9 @@ usage(const struct cmdinfo *cip, const char *value)
 "  -X|--vextract <deb> <directory>  Extract & list files.\n"
 "  -R|--raw-extract <deb> <directory>\n"
 "                                   Extract control info and files.\n"
+"  --tar-build <ctar> <dtar> <deb>  Build archive from tars.\n"
 "  --fsys-tarfile <deb>             Output filesystem tarfile.\n"
+"  --control-tarfile <deb>          Output control tarfile.\n"
 "\n"));
 
   printf(_(
@@ -94,6 +96,8 @@ usage(const struct cmdinfo *cip, const char *value)
 "<deb> is the filename of a Debian format archive.\n"
 "<cfile> is the name of an administrative file component.\n"
 "<cfield> is the name of a field in the main `control' file.\n"
+"<ctar> is the name of an uncompressed control.tar file.\n"
+"<dtar> is the name of an uncompressed data.tar file.\n"
 "\n"));
 
   printf(_(
@@ -224,7 +228,9 @@ static const struct cmdinfo cmdinfos[]= {
   ACTION("extract",       'x', 0, do_extract),
   ACTION("vextract",      'X', 0, do_vextract),
   ACTION("raw-extract",   'R', 0, do_raw_extract),
+  ACTION("tar-build",     0,   0, do_tarbuild),
   ACTION("fsys-tarfile",  0,   0, do_fsystarfile),
+  ACTION("control-tarfile", 0, 0, do_controltarfile),
   ACTION("show",          'W', 0, do_showinfo),
 
   { "deb-format",    0,   1, NULL,           NULL,         set_deb_format   },
unchanged:
--- a/man/dpkg-deb.1
+++ b/man/dpkg-deb.1
@@ -170,6 +170,15 @@ of the specified directory.
 
 The target directory (but not its parents) will be created if necessary.
 .TP
+.BR --tar-build
+Creates a new debian archive from the control information files
+.I control-tar
+and the filesystem tree
+.I data-tar.
+Both are stored in
+.B tar
+format.
+.TP
 .BR \-\-fsys\-tarfile " \fIarchive\fP"
 Extracts the filesystem tree data from a binary package and sends it
 to standard output in
@@ -179,6 +188,12 @@ format. Together with
 this can be used to extract a particular file from a package archive.
 The input archive will always be processed sequentially.
 .TP
+.BR --control-tarfile
+Extracts the control information files from a binary package and sends it
+to standard output in
+.B tar
+format.
+.TP
 .BR \-e ", " \-\-control " \fIarchive\fP [\fIdirectory\fP]"
 Extracts the control information files from a package archive into the
 specified directory.
