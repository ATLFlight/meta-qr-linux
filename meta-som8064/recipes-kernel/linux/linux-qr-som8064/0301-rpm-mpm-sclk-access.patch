diff --git a/arch/arm/mach-msm/rpm_stats.c b/arch/arm/mach-msm/rpm_stats.c
index 752fa20..fd514af 100644
--- a/arch/arm/mach-msm/rpm_stats.c
+++ b/arch/arm/mach-msm/rpm_stats.c
@@ -194,6 +194,50 @@ static const struct file_operations msm_rpmstats_fops = {
 	.llseek   = no_llseek,
 };
 
+static char* sclk_kbuf = NULL;
+#define BUF_SIZE 10
+static int msm_rpmsclk_file_open(struct inode *inode, struct file *file)
+{
+	sclk_kbuf = kzalloc(sizeof(char) * BUF_SIZE, GFP_KERNEL);
+	return 0;
+}
+
+static int msm_rpmsclk_file_close(struct inode *inode, struct file *file)
+{
+	if (sclk_kbuf)
+		kfree(sclk_kbuf);
+	sclk_kbuf = NULL;
+	return 0;
+}
+
+extern uint64_t msm_timer_get_sclk_ticks_in_us(void);
+static int msm_rpmsclk_file_read(struct file *file, char __user *bufu,
+				  size_t count, loff_t *ppos)
+{
+	uint64_t data = 0;
+	int ret = 0;
+	size_t c = 0;
+
+	if (!bufu || count < 0)
+		return -EINVAL;
+
+	data = msm_timer_get_sclk_ticks_in_us();
+	/*pr_info("MPM_SCLK_COUNT_VAL: 0x%llx\n", data);*/
+	c = scnprintf(sclk_kbuf, BUF_SIZE, "%llx", data);
+	ret = simple_read_from_buffer(bufu, count, ppos, sclk_kbuf, c);
+
+	return ret;
+}
+
+static const struct file_operations msm_rpmsclkcount_fops = {
+	.owner	  = THIS_MODULE,
+	.open	  = msm_rpmsclk_file_open,
+	.read	  = msm_rpmsclk_file_read,
+	.release  = msm_rpmsclk_file_close,
+};
+
+static struct dentry *dent1;
+
 static  int __devinit msm_rpmstats_probe(struct platform_device *pdev)
 {
 	struct dentry *dent;
@@ -209,6 +253,15 @@ static  int __devinit msm_rpmstats_probe(struct platform_device *pdev)
 		pr_err("%s: ERROR debugfs_create_file failed\n", __func__);
 		return -ENOMEM;
 	}
+
+	dent1 = debugfs_create_file("rpm_mpm_sclk_count_val", S_IRUGO, NULL,
+			NULL, &msm_rpmsclkcount_fops);
+
+	if (!dent1) {
+		pr_err("%s: ERROR debugfs_create_file failed\n", __func__);
+		return -ENOMEM;
+	}
+
 	platform_set_drvdata(pdev, dent);
 	return 0;
 }
@@ -219,6 +272,7 @@ static int __devexit msm_rpmstats_remove(struct platform_device *pdev)
 
 	dent = platform_get_drvdata(pdev);
 	debugfs_remove(dent);
+	debugfs_remove(dent1);
 	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
diff --git a/arch/arm/mach-msm/timer.c b/arch/arm/mach-msm/timer.c
index 6e4580b..05e8cec 100644
--- a/arch/arm/mach-msm/timer.c
+++ b/arch/arm/mach-msm/timer.c
@@ -447,6 +447,22 @@ uint32_t msm_timer_get_sclk_ticks(void)
 	return t1;
 }
 
+
+/* Conversion from sleep clock ticks to microseconds at the nominal frequency */
+// 1000*1000/32768 = 30.517578125
+#define QTIMER_TIMETICK_TO_US(ticks) \
+	(((unsigned long long)(ticks)*30ul)+((unsigned long long)(ticks)>>1)+((unsigned long long)(ticks)>>6)+((unsigned long long)(ticks)>>9))
+
+uint64_t msm_timer_get_sclk_ticks_in_us(void)
+{
+	uint64_t ticks_us = 0;
+	uint32_t ticks = msm_timer_get_sclk_ticks();
+	if(ticks)
+		ticks_us = QTIMER_TIMETICK_TO_US(ticks);
+
+	return ticks_us;
+}
+
 static uint32_t msm_timer_do_sync_to_sclk(
 	void (*time_start)(struct msm_timer_sync_data_t *data),
 	bool (*time_expired)(struct msm_timer_sync_data_t *data),
