diff --git a/app/aboot/aboot.c b/app/aboot/aboot.c
index 37a9475..4987cb5 100644
--- a/app/aboot/aboot.c
+++ b/app/aboot/aboot.c
@@ -526,7 +526,7 @@ int boot_linux_from_mmc(void)
 	}
 
 	if (memcmp(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
-		dprintf(CRITICAL, "ERROR: Invalid boot image header\n");
+		dprintf(CRITICAL, "ERROR: %s, %d Invalid boot image header \n", __func__, __LINE__);
                 return -1;
 	}
 
@@ -735,7 +735,7 @@ int boot_linux_from_flash(void)
 	if (target_is_emmc_boot()) {
 		hdr = (struct boot_img_hdr *)EMMC_BOOT_IMG_HEADER_ADDR;
 		if (memcmp(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
-			dprintf(CRITICAL, "ERROR: Invalid boot image header\n");
+			dprintf(CRITICAL, "ERROR: %s, %d Invalid boot image header \n", __func__, __LINE__);
 			return -1;
 		}
 		goto continue_boot;
@@ -770,7 +770,7 @@ int boot_linux_from_flash(void)
 	}
 
 	if (memcmp(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
-		dprintf(CRITICAL, "ERROR: Invalid boot image header\n");
+		dprintf(CRITICAL, "ERROR: %s, %d Invalid boot image header \n", __func__, __LINE__);
 		return -1;
 	}
 
@@ -1610,10 +1610,16 @@ void aboot_init(const struct app_descriptor *app)
 	surf_udc_device.serialno = sn_buf;
 
 	/* Check if we should do something other than booting up */
-	if (keys_get_state(KEY_HOME) != 0)
+	if (keys_get_state(KEY_HOME) != 0) {
+	    dprintf(SPEW,"Switching to recovery mode: KEY_HOME\n");
 		boot_into_recovery = 1;
-	if (keys_get_state(KEY_VOLUMEUP) != 0)
+	}
+#if 0 /* Constitution - no volume up */
+	if (keys_get_state(KEY_VOLUMEUP) != 0) {
+	    dprintf(SPEW,"Switching to recovery mode: KEY_VOLUP\n");
 		boot_into_recovery = 1;
+	}
+#endif
 	if(!boot_into_recovery)
 	{
 		if (keys_get_state(KEY_BACK) != 0)
@@ -1629,6 +1635,7 @@ void aboot_init(const struct app_descriptor *app)
 
 	reboot_mode = check_reboot_mode();
 	if (reboot_mode == RECOVERY_MODE) {
+	    dprintf(SPEW,"Switching to recovery mode: reboot_mode\n");
 		boot_into_recovery = 1;
 	} else if(reboot_mode == FASTBOOT_MODE) {
 		goto fastboot;
diff --git a/dev/keys/gpio_keypad.c b/dev/keys/gpio_keypad.c
index 5f0e818..369f405 100644
--- a/dev/keys/gpio_keypad.c
+++ b/dev/keys/gpio_keypad.c
@@ -445,15 +445,20 @@ scan_qwerty_gpio_keypad(struct timer *timer, time_t now, void *arg)
 
 	num = keypad->mapsize;
 
+    dprintf (SPEW, "%s: mapsize %d \n",__func__, num);
+
 	for(i=0; i < num; i++)
 	{
 		/*continue if not interested in key*/
+    	dprintf (SPEW, "%s: %d keymap %d \n",__func__, i, keypad->keymap[i]);
 		if(!keypad->keymap[i])
 			continue;
 
 		/*read key gpio*/
 		keypad->key_gpio_get(keypad->gpiomap[i], &key_status);
 
+    	dprintf (SPEW, "%s: key_gpio %d status %d \n",__func__, keypad->gpiomap[i], key_status);
+		
 		/*Post event if key pressed*/
 		if(key_status)
 		{
diff --git a/dev/pmic/pm8921/pm8921.c b/dev/pmic/pm8921/pm8921.c
index cafa6a8..a7e5a35 100644
--- a/dev/pmic/pm8921/pm8921.c
+++ b/dev/pmic/pm8921/pm8921.c
@@ -113,6 +113,8 @@ int pm8921_gpio_config(int gpio, struct pm8921_gpio *param)
 		PM_GPIO_MODE_BOTH,
 	};
 
+	dprintf(SPEW, "%s: gpio %d\n",__func__,gpio);
+
 	if (param == NULL) {
 	  dprintf (CRITICAL, "pm8291_gpio struct not defined\n");
           return -1;
diff --git a/platform/msm8960/gpio.c b/platform/msm8960/gpio.c
index 680be8b..7cc3853 100755
--- a/platform/msm8960/gpio.c
+++ b/platform/msm8960/gpio.c
@@ -95,6 +95,16 @@ void gpio_config_uart_dm(uint8_t id)
 							 GPIO_8MA, GPIO_DISABLE);
 			break;
 
+		/* Constitution: UART_2x console */
+		case GSBI_ID_5:
+			/* configure rx gpio */
+			gpio_tlmm_config(52, 2, GPIO_INPUT, GPIO_NO_PULL,
+							 GPIO_8MA, GPIO_DISABLE);
+			/* configure tx gpio */
+			gpio_tlmm_config(51, 2, GPIO_OUTPUT, GPIO_NO_PULL,
+							 GPIO_8MA, GPIO_DISABLE);
+			break;
+		
 		/* Clarence SOM: UART_2x, GSBI-6, GPIO 14,15 */
 		case GSBI_ID_6:
 			/* configure rx gpio */
diff --git a/target/msm8960/init.c b/target/msm8960/init.c
index e78ed1c..c33ec26 100755
--- a/target/msm8960/init.c
+++ b/target/msm8960/init.c
@@ -143,7 +143,7 @@ void target_init(void)
 	};
 
 	/* SOM RevB carrier: Serial port workaround, Enable LVS5 */
-	pm8921_low_voltage_switch_enable(lvs_5); 
+	/*pm8921_low_voltage_switch_enable(lvs_5); */
 
 	dprintf(INFO, "Platform ID : (%u)\n", platform_id);
 	dprintf(INFO, "Hardware ID : (%u)\n", board_hardware_id());
@@ -151,6 +151,7 @@ void target_init(void)
 	dprintf(INFO, "Baseband    : (%u)\n", board_baseband());
 	dprintf(INFO, "PMIC type   : (%u)\n", board_pmic_type());
 	dprintf(INFO, "PMIC ver    : (%u)\n", board_pmic_ver());
+	dprintf(INFO, "*** Constitution LK init *** \n");
 
 	/* Display splash screen if enabled */
 #if DISPLAY_SPLASH_SCREEN
@@ -318,7 +319,9 @@ void target_uart_init(void)
 		/* SOM: UART_2x, GSBI-6, GPIO 14,15 */
 		/*uart_dm_init(6, 0x16500000, 0x16540000);*/
 		/* SOM: UART_2x, GSBI-1, GPIO 18,19 */
-		uart_dm_init(1, 0x12440000, 0x12450000);
+		/*uart_dm_init(1, 0x12440000, 0x12450000);*/
+		/* Constitution UART_2x, GSBI-5, GPIO 51,52 */
+		uart_dm_init(5, 0x1A200000, 0x1A240000);
 		break;
 	case LINUX_MACHTYPE_8064_MPQ_CDP:
 	case LINUX_MACHTYPE_8064_MPQ_HRD:
diff --git a/target/msm8960/keypad.c b/target/msm8960/keypad.c
index 82e049c..7aac8cc 100644
--- a/target/msm8960/keypad.c
+++ b/target/msm8960/keypad.c
@@ -94,18 +94,22 @@ struct qwerty_keypad_info msm8930_pm8917_qwerty_keypad = {
 };
 
 unsigned int apq8064_qwerty_keymap[] = {
-	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEUP,	/* Volume key on the device/CDP */
-	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEDOWN,	/* Volume key on the device/CDP */
+	[KEYMAP_INDEX(0, 0)] = KEY_VOLUMEDOWN,	/* Volume key on the device/CDP */
+#if 0
+	[KEYMAP_INDEX(0, 1)] = KEY_VOLUMEUP,	/* Volume key on the device/CDP */
+#endif
 };
 
 unsigned int apq8064_pm8921_keys_gpiomap[] = {
-	[KEYMAP_INDEX(0, 0)] = PM_GPIO(35),	/* Volume key on the device/CDP */
-	[KEYMAP_INDEX(0, 1)] = PM_GPIO(38),	/* Volume key on the device/CDP */
+#if 0
+	[KEYMAP_INDEX(0, 1)] = PM_GPIO(35),	/* Volume key on the device/CDP */
+#endif
+	[KEYMAP_INDEX(0, 0)] = PM_GPIO(38),	/* Volume key on the device/CDP */
 };
 
 unsigned int apq8064_pm8917_keys_gpiomap[] = {
-	[KEYMAP_INDEX(0, 0)] = PM_GPIO(35),	/* Volume key on the device/CDP */
 	[KEYMAP_INDEX(0, 1)] = PM_GPIO(30),	/* Volume key on the device/CDP */
+	[KEYMAP_INDEX(0, 0)] = PM_GPIO(35),	/* Volume key on the device/CDP */
 };
 
 struct qwerty_keypad_info apq8064_pm8921_qwerty_keypad = {
