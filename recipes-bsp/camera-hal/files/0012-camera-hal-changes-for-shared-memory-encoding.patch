From 993efb1ef471364a4226cb38e9caf9ef010eb13b Mon Sep 17 00:00:00 2001
From: Punit Soni <punits@codeaurora.org>
Date: Fri, 24 Jul 2015 13:20:52 -0700
Subject: [PATCH 12/16] camera-hal: changes for shared memory encoding

Change-Id: I8be1e7f538e12fb79fce14d1ffa0338bf7db7490
---
 QCamera/stack/mm-camera-test/inc/mm_qcamera_app.h  |  2 +-
 QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h | 16 ++++-
 QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c |  9 +++
 .../stack/mm-camera-test/src/mm_qcamera_video.c    | 48 ++++++++++++---
 qcamlib/README.md                                  |  4 ++
 qcamlib/inc/qcamlib.h                              | 59 +++++++++++++++++-
 qcamlib/src/qcamlib.c                              | 69 +++++++++++++++++++++-
 7 files changed, 192 insertions(+), 15 deletions(-)
 mode change 100755 => 100644 QCamera/stack/mm-camera-test/inc/mm_qcamera_app.h

diff --git a/QCamera/stack/mm-camera-test/inc/mm_qcamera_app.h b/QCamera/stack/mm-camera-test/inc/mm_qcamera_app.h
old mode 100755
new mode 100644
index 9b51825..7d0ab8e
--- a/QCamera/stack/mm-camera-test/inc/mm_qcamera_app.h
+++ b/QCamera/stack/mm-camera-test/inc/mm_qcamera_app.h
@@ -40,7 +40,7 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MM_APP_MAX_DUMP_FRAME_NUM 1000
 
 #define PREVIEW_BUF_NUM 7
-#define VIDEO_BUF_NUM 7
+#define VIDEO_BUF_NUM 10
 #define ISP_PIX_BUF_NUM 9
 
 #define STATS_BUF_NUM 4
diff --git a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
index 2e6636a..7ab87c4 100644
--- a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
+++ b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
@@ -113,6 +113,7 @@ typedef enum {
 } mm_camera_tune_prevcmd_t;
 
 typedef void (*prev_callback) (mm_camera_buf_def_t *preview_frame);
+typedef void (*vid_callback) (mm_camera_super_buf_t *super_buf);
 
 typedef struct {
   char *send_buf;
@@ -133,6 +134,11 @@ typedef struct {
     void *lib_handle;
 }mm_camera_tuning_lib_params_t;
 
+typedef struct _mm_camera_stream_t mm_camera_stream_t;
+
+// callback for notifying buffer handles to the client
+typedef void (*mm_app_stream_buf_info_cb_t)(mm_camera_stream_t *stream);
+
 typedef enum {
     MM_CAMERA_OK,
     MM_CAMERA_E_GENERAL,
@@ -171,7 +177,7 @@ typedef struct {
     mm_camera_app_meminfo_t mem_info;
 } mm_camera_app_buf_t;
 
-typedef struct {
+typedef struct _mm_camera_stream_t {
     uint32_t s_id;
     mm_camera_stream_config_t s_config;
     cam_frame_len_offset_t offset;
@@ -179,6 +185,8 @@ typedef struct {
     uint32_t multipleOf;
     mm_camera_app_buf_t s_bufs[MM_CAMERA_MAX_NUM_FRAMES];
     mm_camera_app_buf_t s_info_buf;
+    void* p_test_obj; // mm_camera_test_obj_t *
+    mm_camera_channel_type_t channel_type;
 } mm_camera_stream_t;
 
 typedef struct {
@@ -221,6 +229,8 @@ typedef struct {
     uint32_t current_job_id;
     mm_camera_app_buf_t jpeg_buf;
 
+    mm_app_stream_buf_info_cb_t buf_info_cb;
+
     int fb_fd;
     struct fb_var_screeninfo vinfo;
     struct mdp_overlay data_overlay;
@@ -234,7 +244,7 @@ typedef struct {
     int zsl_enabled;
     int8_t focus_supported;
     prev_callback user_preview_cb;
-    prev_callback user_video_cb;
+    vid_callback user_video_cb;
     parm_buffer_new_t *params_buffer;
     USER_INPUT_DISPLAY_T preview_resolution;
 
@@ -513,6 +523,8 @@ extern void* mm_qcamera_queue_dequeue(mm_camera_queue_t *queue,
                                       int bFromHead);
 extern void mm_qcamera_queue_flush(mm_camera_queue_t *queue);
 
+int mm_app_relese_video_frame(mm_camera_super_buf_t *super_buf,
+                                      void *userdata);
 
 int setFPSRange(mm_camera_test_obj_t *test_obj, cam_fps_range_t range);
 int setFocusMode(mm_camera_test_obj_t *test_obj, cam_focus_mode_type mode);
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
index e44fc63..068f19c 100644
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
@@ -425,6 +425,12 @@ int mm_app_stream_initbuf(cam_frame_len_offset_t *frame_offset_info,
     *bufs = pBufs;
     *initial_reg_flag = reg_flags;
 
+    mm_camera_test_obj_t *test_obj = (mm_camera_test_obj_t *) stream->p_test_obj;
+
+    if (test_obj && test_obj->buf_info_cb) {
+        CDBG_ERROR("%s: calling the buffer info callback.", __func__);
+        test_obj->buf_info_cb(stream);
+    }
     CDBG("%s: X",__func__);
     return rc;
 }
@@ -670,6 +676,7 @@ mm_camera_channel_t * mm_app_add_channel(mm_camera_test_obj_t *test_obj,
     }
     channel = &test_obj->channels[ch_type];
     channel->ch_id = ch_id;
+    test_obj->num_channels++;
     return channel;
 }
 
@@ -679,6 +686,7 @@ int mm_app_del_channel(mm_camera_test_obj_t *test_obj,
     test_obj->cam->ops->delete_channel(test_obj->cam->camera_handle,
                                        channel->ch_id);
     memset(channel, 0, sizeof(mm_camera_channel_t));
+    test_obj->num_channels--;
     return MM_CAMERA_OK;
 }
 
@@ -698,6 +706,7 @@ mm_camera_stream_t * mm_app_add_stream(mm_camera_test_obj_t *test_obj,
     }
 
     stream->multipleOf = test_obj->slice_size;
+    stream->p_test_obj = (void *) test_obj;
 
     /* alloc ion mem for stream_info buf */
     memset(&offset_info, 0, sizeof(offset_info));
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
index 6ad260e..2e5947a 100644
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
@@ -39,26 +39,60 @@ static void mm_app_video_notify_cb(mm_camera_super_buf_t *bufs,
     mm_camera_buf_def_t *frame = bufs->bufs[0];
     mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
 
+    mm_camera_super_buf_t *sbuf = (mm_camera_super_buf_t *)
+        malloc(sizeof(mm_camera_super_buf_t));
+    if (!sbuf) {
+        CDBG_ERROR("%s:%d, malloc failed\n", __func__, __LINE__);
+        return;
+    }
+    memcpy(sbuf, bufs, sizeof(mm_camera_super_buf_t));
+
     CDBG("%s: BEGIN - length=%d, frame idx = %d\n",
          __func__, frame->frame_len, frame->frame_idx);
 
     if (pme->user_video_cb) {
-      pme->user_video_cb(frame);
+        pme->user_video_cb(sbuf);
     }
 #if DUMP_VIDEO_FRAME
     snprintf(file_name, sizeof(file_name), "V_C%d", pme->cam->camera_handle);
     mm_app_dump_frame(frame, file_name, "yuv", frame->frame_idx);
 #endif
 
-    if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
+    CDBG("%s:%d, sbuf=%p handle=%u, ch-id=%u, frame=%p\n",
+                __func__, __LINE__, bufs, bufs->camera_handle,
                                             bufs->ch_id,
+                                            frame);
+    CDBG("%s: END\n", __func__);
+}
+
+int mm_app_relese_video_frame(mm_camera_super_buf_t *super_buf,
+                                      void *userdata)
+{
+    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)userdata;
+
+    if (!super_buf || !super_buf->bufs[0] || !userdata) {
+        CDBG_ERROR("%s: invalid args %p %p %p\n", __func__,
+                    super_buf, super_buf->bufs[0], userdata);
+        return -1;
+    }
+    mm_camera_buf_def_t *frame = super_buf->bufs[0];
+
+    CDBG("%s:%d, sbuf=%p, handle=%u, ch-id=%u, frame=%p\n",
+                __func__, __LINE__, super_buf, super_buf->camera_handle,
+                                            super_buf->ch_id,
+                                            frame);
+
+    // Enqueue buffer to kernel
+    if (MM_CAMERA_OK != pme->cam->ops->qbuf(super_buf->camera_handle,
+                                            super_buf->ch_id,
                                             frame)) {
-        CDBG_ERROR("%s: Failed in Preview Qbuf\n", __func__);
+        CDBG_ERROR("%s: Failed in video Qbuf\n", __func__);
+        return -1;
     }
     mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
                      ION_IOC_INV_CACHES);
-
-    CDBG("%s: END\n", __func__);
+    free(super_buf);
+    return 0;
 }
 
 mm_camera_stream_t * mm_app_add_video_stream(mm_camera_test_obj_t *test_obj,
@@ -76,7 +110,7 @@ mm_camera_stream_t * mm_app_add_video_stream(mm_camera_test_obj_t *test_obj,
         CDBG_ERROR("%s: add stream failed\n", __func__);
         return NULL;
     }
-
+    stream->channel_type = MM_CHANNEL_TYPE_VIDEO;
     stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
     stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
     stream->s_config.mem_vtbl.clean_invalidate_buf =
@@ -130,7 +164,7 @@ mm_camera_channel_t * mm_app_add_video_channel(mm_camera_test_obj_t *test_obj)
                                      channel,
                                      mm_app_video_notify_cb,
                                      (void *)test_obj,
-                                     1);
+                                     VIDEO_BUF_NUM);
     if (NULL == stream) {
         CDBG_ERROR("%s: add video stream failed\n", __func__);
         mm_app_del_channel(test_obj, channel);
diff --git a/qcamlib/README.md b/qcamlib/README.md
index 730111a..38fba64 100644
--- a/qcamlib/README.md
+++ b/qcamlib/README.md
@@ -37,6 +37,10 @@ void video_cb(qcamlib_cb_data_t frame)
 {
     // copy frame to user buffer
     qcamlib_copy_frame_to_buf(frame, video_info, buf);
+
     // process the frame
+
+    // release the frame
+    qcamlib_release_video_frame(h_cam, frame);
 }
 ~~~
\ No newline at end of file
diff --git a/qcamlib/inc/qcamlib.h b/qcamlib/inc/qcamlib.h
index 47e44ca..4456915 100644
--- a/qcamlib/inc/qcamlib.h
+++ b/qcamlib/inc/qcamlib.h
@@ -74,8 +74,12 @@ typedef struct _qcamlib_frame_info_t {
  */
 typedef struct _qcamlib_cb_data_t {
     uint8_t *buffer;
+    /* frame timestamp */
     struct timespec ts;
+    /* client private userdata */
     void *userdata;
+    /* pointer to framebuffer data maintained by camera framework */
+    void *sbuf;
 } qcamlib_cb_data_t;
 
 /**
@@ -96,6 +100,31 @@ typedef struct _qcamlib_stream_dim_t {
 } qcamlib_stream_dim_t;
 
 /**
+ * @brief ion memory information single video buffer
+ */
+typedef struct _qcamlib_video_buf_info_t {
+    int fd;
+    uint32_t size;
+    void *vaddr;
+} qcamlib_video_buf_info_t;
+
+/**
+ * @brief data structure delivered as part of video buf_info
+ *        callback.
+ */
+typedef struct _qcamlib_video_buf_cb_data_t {
+    int32_t num_bufs;
+    qcamlib_video_buf_info_t *buf_info;
+    void *userdata;
+} qcamlib_video_buf_cb_data_t;
+
+/**
+ * @brief buffer information callback to get ion memory
+ *        information for video stream
+ */
+typedef void (*qcamlib_video_buf_info_cb) (qcamlib_video_buf_cb_data_t cb_data);
+
+/**
  *  @brief qcamlib configuration
  */
 typedef struct _qcamlib_config_t {
@@ -218,15 +247,41 @@ int qcamlib_configure(qcamlib_t h, qcamlib_config_t config);
 
 /**
  * @brief copy the frame to a user buffer
- * 
+ *
  * @param frame frame data received in callback
  * @param frame_info frame information data
  * @param buf user allocated buffer
- * 
+ *
  * @return int 0: success, non-zero: failure
  */
 int qcamlib_copy_frame_to_buf(qcamlib_cb_data_t frame,
                               qcamlib_frame_info_t frame_info,
                               uint8_t *buf);
 
+/**
+ * @brief register video buf info callback
+ * @param h
+ *     qcamlib handle
+ * @param cb
+ *     user callback funtion pointer
+ * @return int
+ *     0: sucess
+ *     non-zero: failure
+ */
+int qcamlib_register_video_buf_info_cb(qcamlib_t h,
+                                       qcamlib_video_buf_info_cb cb);
+
+/**
+ * @brief function to indicate that client is done with video
+ *        frame
+ * @param h
+ *     qcamlib handle
+ * @param frame
+ *     video frame data
+ * @return int
+ *     0: sucess
+ *     non-zero: failure
+ */
+int qcamlib_release_video_frame(qcamlib_t h, qcamlib_cb_data_t frame);
+
 #endif
diff --git a/qcamlib/src/qcamlib.c b/qcamlib/src/qcamlib.c
index 9cb2751..6fdde09 100644
--- a/qcamlib/src/qcamlib.c
+++ b/qcamlib/src/qcamlib.c
@@ -32,6 +32,7 @@
 #include "qcamlib.h"
 #include <stdbool.h>
 #include <media/msm_media_info.h>
+#include <sys/time.h>
 
 typedef struct _qcamlib_obj {
     qcamlib_frame_cb pcb;
@@ -42,10 +43,13 @@ typedef struct _qcamlib_obj {
     bool video_on;
     void *cb_userdata;
     bool video_preview;
+    qcamlib_video_buf_info_cb v_buf_info_cb;
 };
 
 qcamlib_t g_handle;
 
+static void qcamlib_buf_info_cb(mm_camera_stream_t *stream);
+
 qcamlib_t qcamlib_create()
 {
     int rc;
@@ -81,6 +85,9 @@ qcamlib_t qcamlib_create()
     h->test_obj.snapshot_width = DEFAULT_SNAPSHOT_WIDTH;
     h->test_obj.snapshot_height = DEFAULT_SNAPSHOT_HEIGHT;
 #endif
+
+    h->test_obj.buf_info_cb = qcamlib_buf_info_cb;
+
     return h;
 cleanup:
     free(h);
@@ -265,6 +272,35 @@ int qcamlib_stop_preview(qcamlib_t h)
   return 0;
 }
 
+static void qcamlib_buf_info_cb(mm_camera_stream_t *stream)
+{
+    QCAM_INFO("E");
+    qcamlib_t h = g_handle;
+    qcamlib_video_buf_cb_data_t cb_data;
+    int i;
+    switch (stream->channel_type) {
+    case MM_CHANNEL_TYPE_VIDEO: {
+        cb_data.buf_info = (qcamlib_video_buf_info_t *)
+                malloc (stream->num_of_bufs * sizeof(qcamlib_video_buf_info_t));
+
+        for (i=0; i < stream->num_of_bufs; i++) {
+            cb_data.buf_info[i].fd = stream->s_bufs[i].mem_info.fd;
+            cb_data.buf_info[i].vaddr = stream->s_bufs[i].mem_info.data;
+            cb_data.buf_info[i].size = stream->s_bufs[i].mem_info.size;
+        }
+        cb_data.userdata = h->cb_userdata;
+        cb_data.num_bufs = stream->num_of_bufs;
+        if (h->v_buf_info_cb) {
+            h->v_buf_info_cb(cb_data);
+        }
+        free(cb_data.buf_info);
+        break;
+    }
+    default:
+        break;
+    }
+}
+
 static void preview_cb_internal(mm_camera_buf_def_t *buf_def)
 {
     qcamlib_cb_data_t frame;
@@ -278,17 +314,28 @@ static void preview_cb_internal(mm_camera_buf_def_t *buf_def)
     h->pcb(frame);
 }
 
-static void video_cb_internal(mm_camera_buf_def_t *buf_def)
+static void video_cb_internal(mm_camera_super_buf_t *super_buf)
 {
     qcamlib_cb_data_t frame;
     qcamlib_t h = g_handle;
     if (h->vcb == NULL) {
         return;
     }
+    mm_camera_buf_def_t *buf_def = super_buf->bufs[0];
     frame.buffer = buf_def->buffer;
     frame.ts = buf_def->ts;
     frame.userdata = h->cb_userdata;
+    frame.sbuf = super_buf;
+
+    struct timeval tv0, tv1;
+
+    gettimeofday(&tv0, NULL);
     h->vcb(frame);
+    gettimeofday(&tv1, NULL);
+
+    uint64_t us;
+    us = (tv1.tv_sec - tv0.tv_sec) * 1000000 + (tv1.tv_usec - tv0.tv_usec);
+    QCAM_DBG("user vcb processing time = %lld us", us);
 }
 
 int qcamlib_register_preview_cb(qcamlib_t h, qcamlib_frame_cb upcb)
@@ -315,6 +362,12 @@ int qcamlib_register_video_cb(qcamlib_t h, qcamlib_frame_cb uvcb)
   return 0;
 }
 
+int qcamlib_register_video_buf_info_cb(qcamlib_t h, qcamlib_video_buf_info_cb cb)
+{
+  h->v_buf_info_cb = cb;
+  return 0;
+}
+
 void qcamlib_deregister_preview_cb(qcamlib_t h)
 {
     h->pcb = NULL;
@@ -343,8 +396,8 @@ int qcamlib_configure(qcamlib_t h, qcamlib_config_t config)
     h->test_obj.snapshot_width = config.snapshot_dim.width;
     h->test_obj.snapshot_height = config.snapshot_dim.height;
 #endif
-    QCAM_DBG("preview %dx%d, video %dx%d", 
-			h->test_obj.preview_width, h->test_obj.preview_height, 
+    QCAM_DBG("preview %dx%d, video %dx%d",
+			h->test_obj.preview_width, h->test_obj.preview_height,
 			h->test_obj.video_width, h->test_obj.video_height);
     return 0;
 }
@@ -376,3 +429,13 @@ int qcamlib_copy_frame_to_buf(qcamlib_cb_data_t frame,
     }
     return 0;
 }
+
+int qcamlib_release_video_frame(qcamlib_t h, qcamlib_cb_data_t frame)
+{
+    if (!frame.sbuf) {
+        QCAM_ERR("invalid argument, frame.sbuf=NULL");
+        return -1;
+    }
+    return mm_app_relese_video_frame((mm_camera_super_buf_t *)frame.sbuf,
+                                     &h->test_obj);
+}
-- 
1.9.1

