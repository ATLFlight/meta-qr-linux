From 966537b8f5b808ecd3c81692b0dd9f14d2e008ed Mon Sep 17 00:00:00 2001
From: Punit Soni <punits@codeaurora.org>
Date: Tue, 26 May 2015 12:24:34 -0700
Subject: [PATCH 6/9] camera-hal: qcamlib API update for video stream

Change-Id: Ic95c8ac6cf03a6931a1ebbb4db8b3ed120a6bf49
---
 .../stack/mm-camera-interface/inc/mm_camera_dbg.h  |   4 +-
 QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h |  18 +-
 QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h |   4 +-
 QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c |  32 ++
 .../stack/mm-camera-test/src/mm_qcamera_preview.c  |   7 +-
 .../stack/mm-camera-test/src/mm_qcamera_video.c    |  18 +-
 qcamlib/Makefile.am                                |   3 +-
 qcamlib/inc/qcamlib.h                              | 161 +++++++++--
 qcamlib/src/qcamlib.c                              | 322 +++++++++++++++++----
 qcamlib/test/qcamlib_test.c                        | 258 +++++++++++++----
 10 files changed, 668 insertions(+), 159 deletions(-)
 mode change 100755 => 100644 QCamera2/stack/mm-camera-interface/inc/mm_camera_dbg.h
 mode change 100755 => 100644 QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
 mode change 100755 => 100644 QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c

diff --git a/QCamera2/stack/mm-camera-interface/inc/mm_camera_dbg.h b/QCamera2/stack/mm-camera-interface/inc/mm_camera_dbg.h
old mode 100755
new mode 100644
index 3099178..3ed6f9b
--- a/QCamera2/stack/mm-camera-interface/inc/mm_camera_dbg.h
+++ b/QCamera2/stack/mm-camera-interface/inc/mm_camera_dbg.h
@@ -66,8 +66,8 @@
   #define CDBG_ERROR(fmt, args...)  ALOGE(fmt, ##args)
 #else
   #include <syslog.h>
-  #define CDBG(fmt, args...) do{}while(0)
-  #define CDBG_HIGH(fmt, args...) syslog(LOG_INFO, fmt, ##args)
+  #define CDBG(fmt, args...) do {} while(0)
+  #define CDBG_HIGH(fmt, args...) syslog(LOG_NOTICE, fmt, ##args)
   #define CDBG_ERROR(fmt, args...) syslog(LOG_ERR, fmt, ##args)
 #endif
 
diff --git a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
old mode 100755
new mode 100644
index 2703646..e4b4109
--- a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
+++ b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
@@ -58,12 +58,12 @@
 #define CAPTURE_BUF_NUM 5
 
 #define DEFAULT_PREVIEW_FORMAT    CAM_FORMAT_YUV_420_NV21
-#define DEFAULT_PREVIEW_WIDTH     3840
-#define DEFAULT_PREVIEW_HEIGHT    2160
+#define DEFAULT_PREVIEW_WIDTH     1280
+#define DEFAULT_PREVIEW_HEIGHT    720
 #define DEFAULT_PREVIEW_PADDING   CAM_PAD_TO_WORD
 #define DEFAULT_VIDEO_FORMAT      CAM_FORMAT_YUV_420_NV12
-#define DEFAULT_VIDEO_WIDTH       800
-#define DEFAULT_VIDEO_HEIGHT      480
+#define DEFAULT_VIDEO_WIDTH       1920
+#define DEFAULT_VIDEO_HEIGHT      1080
 #define DEFAULT_VIDEO_PADDING     CAM_PAD_TO_2K
 #define DEFAULT_SNAPSHOT_FORMAT   CAM_FORMAT_YUV_420_NV21
 #define DEFAULT_RAW_FORMAT        CAM_FORMAT_BAYER_QCOM_RAW_10BPP_GBRG
@@ -234,9 +234,14 @@ typedef struct {
     int zsl_enabled;
     int8_t focus_supported;
     prev_callback user_preview_cb;
+    prev_callback user_video_cb;
     parm_buffer_new_t *params_buffer;
     USER_INPUT_DISPLAY_T preview_resolution;
 
+    uint32_t video_width, video_height;
+    uint32_t preview_width, preview_height;
+    cam_format_t preview_fmt, video_fmt;
+
     //Reprocess params&stream
     int8_t enable_reproc;
     int32_t reproc_sharpness;
@@ -508,6 +513,11 @@ extern void* mm_qcamera_queue_dequeue(mm_camera_queue_t *queue,
                                       int bFromHead);
 extern void mm_qcamera_queue_flush(mm_camera_queue_t *queue);
 
+
+int setFPSRange(mm_camera_test_obj_t *test_obj, cam_fps_range_t range);
+int setFocusMode(mm_camera_test_obj_t *test_obj, cam_focus_mode_type mode);
+int setHFRMode(mm_camera_test_obj_t *test_obj, cam_hfr_mode_t mode);
+
 #endif /* __MM_QCAMERA_APP_H__ */
 
 
diff --git a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
index d424287..bf1fa92 100644
--- a/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
+++ b/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
@@ -66,8 +66,8 @@
   #define CDBG_ERROR(fmt, args...)  ALOGE(fmt, ##args)
 #else
   #include <syslog.h>
-  #define CDBG(fmt, args...) do {} while (0)
-  #define CDBG_HIGH(fmt, args...) do {} while (0)
+  #define CDBG(fmt, args...) syslog(LOG_DEBUG, fmt, ##args)
+  #define CDBG_HIGH(fmt, args...) syslog(LOG_NOTICE, fmt, ##args)
   #define CDBG_ERROR(fmt, args...) syslog(LOG_ERR, fmt, ##args)
 #endif
 
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
old mode 100755
new mode 100644
index 94eb418..e44fc63
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
@@ -1228,6 +1228,38 @@ ERROR:
     return rc;
 }
 
+
+int setHFRMode(mm_camera_test_obj_t *test_obj, cam_hfr_mode_t mode)
+{
+    int rc = MM_CAMERA_OK;
+
+    rc = initBatchUpdate(test_obj);
+    if (rc != MM_CAMERA_OK) {
+        CDBG_ERROR("%s: Batch camera parameter update failed\n", __func__);
+        goto ERROR;
+    }
+
+    uint32_t value = mode;
+
+    rc = AddSetParmEntryToBatch(test_obj,
+                                CAM_INTF_PARM_HFR,
+                                sizeof(value),
+                                &value);
+    if (rc != MM_CAMERA_OK) {
+        CDBG_ERROR("%s: Focus mode parameter not added to batch\n", __func__);
+        goto ERROR;
+    }
+
+    rc = commitSetBatch(test_obj);
+    if (rc != MM_CAMERA_OK) {
+        CDBG_ERROR("%s: Batch parameters commit failed\n", __func__);
+        goto ERROR;
+    }
+
+ERROR:
+    return rc;
+}
+
 int setEVCompensation(mm_camera_test_obj_t *test_obj, int ev)
 {
     int rc = MM_CAMERA_OK;
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
index c9009be..ecf85a4 100644
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
@@ -425,13 +425,12 @@ mm_camera_stream_t * mm_app_add_preview_stream(mm_camera_test_obj_t *test_obj,
     stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
     stream->s_config.stream_info->fmt = DEFAULT_PREVIEW_FORMAT;
 
-    if ((test_obj->preview_resolution.user_input_display_width == 0) ||
-           ( test_obj->preview_resolution.user_input_display_height == 0)) {
+    if (test_obj->preview_width == 0 || test_obj->preview_height == 0) {
         stream->s_config.stream_info->dim.width = DEFAULT_PREVIEW_WIDTH;
         stream->s_config.stream_info->dim.height = DEFAULT_PREVIEW_HEIGHT;
     } else {
-        stream->s_config.stream_info->dim.width = test_obj->preview_resolution.user_input_display_width;
-        stream->s_config.stream_info->dim.height = test_obj->preview_resolution.user_input_display_height;
+        stream->s_config.stream_info->dim.width = test_obj->preview_width;
+        stream->s_config.stream_info->dim.height = test_obj->preview_height;
     }
 
     stream->s_config.padding_info = cam_cap->padding_info;
diff --git a/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c b/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
index 136c8a8..6ad260e 100644
--- a/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
+++ b/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
@@ -30,6 +30,8 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mm_qcamera_dbg.h"
 #include "mm_qcamera_app.h"
 
+#define DUMP_VIDEO_FRAME 0
+
 static void mm_app_video_notify_cb(mm_camera_super_buf_t *bufs,
                                    void *user_data)
 {
@@ -39,8 +41,14 @@ static void mm_app_video_notify_cb(mm_camera_super_buf_t *bufs,
 
     CDBG("%s: BEGIN - length=%d, frame idx = %d\n",
          __func__, frame->frame_len, frame->frame_idx);
+
+    if (pme->user_video_cb) {
+      pme->user_video_cb(frame);
+    }
+#if DUMP_VIDEO_FRAME
     snprintf(file_name, sizeof(file_name), "V_C%d", pme->cam->camera_handle);
     mm_app_dump_frame(frame, file_name, "yuv", frame->frame_idx);
+#endif
 
     if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
                                             bufs->ch_id,
@@ -84,10 +92,16 @@ mm_camera_stream_t * mm_app_add_video_stream(mm_camera_test_obj_t *test_obj,
     stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_VIDEO;
     stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
     stream->s_config.stream_info->fmt = DEFAULT_VIDEO_FORMAT;
-    stream->s_config.stream_info->dim.width = DEFAULT_VIDEO_WIDTH;
-    stream->s_config.stream_info->dim.height = DEFAULT_VIDEO_HEIGHT;
     stream->s_config.padding_info = cam_cap->padding_info;
 
+    if (test_obj->video_width == 0 || test_obj->video_height == 0) {
+      stream->s_config.stream_info->dim.width = DEFAULT_VIDEO_WIDTH;
+      stream->s_config.stream_info->dim.height = DEFAULT_VIDEO_HEIGHT;
+    } else {
+      stream->s_config.stream_info->dim.width = test_obj->video_width;
+      stream->s_config.stream_info->dim.height = test_obj->video_height;
+    }
+
     rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
     if (MM_CAMERA_OK != rc) {
         CDBG_ERROR("%s:config preview stream err=%d\n", __func__, rc);
diff --git a/qcamlib/Makefile.am b/qcamlib/Makefile.am
index 078882b..ea93f6b 100644
--- a/qcamlib/Makefile.am
+++ b/qcamlib/Makefile.am
@@ -3,8 +3,9 @@ ACLOCAL_AMFLAGS = -I m4
 ## build libqcam.so ##
 lib_LTLIBRARIES = libqcam.la
 
+include_HEADERS = inc/qcamlib.h
+
 libqcam_la_CFLAGS = -fPIC
-libqcam_la_CFLAGS += -g -O0
 
 libqcam_la_CFLAGS += -DCAMERA_ION_HEAP_ID=ION_IOMMU_HEAP_ID
 libqcam_la_CFLAGS += -DCAMERA_GRALLOC_HEAP_ID=GRALLOC_USAGE_PRIVATE_IOMMU_HEAP
diff --git a/qcamlib/inc/qcamlib.h b/qcamlib/inc/qcamlib.h
index d19a845..980edf4 100644
--- a/qcamlib/inc/qcamlib.h
+++ b/qcamlib/inc/qcamlib.h
@@ -64,63 +64,182 @@
 #define __QCAMLIB_H__
 
 #include <stdint.h>
+/**
+ *  @brief frame buffer plane information
+ */
+typedef struct _qcamlib_plane_info_t {
+  uint32_t len;
+  uint32_t stride;
+  uint32_t scanlines;
+  uint32_t width;
+  uint32_t height;
+  uint32_t offset;
+} qcamlib_plane_info_t;
 
 /**
- * @brief Function pointer type for preview callbacks
+ *  @brief Enumeration for image format types
  */
-typedef void (*qcamlib_preview_cb) (void* frame);
+typedef enum _qcamlib_img_format_t {
+  QCAMLIB_FMT_NV12,
+  QCAMLIB_FMT_NV21,
+  QCAMLIB_FMT_MAX,
+} qcamlib_img_format_t;
 
 /**
- * @brief Initialize the camera library
- * @return int
- *    returns 0 on success, negative value on failure
+ *  @brief frame buffer information about size, format etc
+ */
+typedef struct _qcamlib_frame_info_t {
+  qcamlib_img_format_t fmt;
+  uint32_t buf_size;
+  uint32_t width;
+  uint32_t height;
+  qcamlib_plane_info_t planes[2];
+} qcamlib_frame_info_t;
+
+/**
+ *  @brief data structure returned with callbacks
+ */
+typedef struct _qcamlib_cb_data_t {
+    uint8_t *buffer;
+    struct timespec ts;
+    void *userdata;
+} qcamlib_cb_data_t;
+
+/**
+ *  @brief enum type for streams
+ */
+typedef enum _qcamlib_stream_type_t {
+  QCAMLIB_STREAM_PREVIEW,
+  QCAMLIB_STREAM_VIDEO,
+  QCAMLIB_STREAM_MAX,
+} qcamlib_stream_type_t;
+
+/**
+ *  @brief stream dimensions
  */
-int qcamlib_init(void);
+typedef struct _qcamlib_stream_dim_t {
+    uint32_t width;
+    uint32_t height;
+} qcamlib_stream_dim_t;
+
+/**
+ *  @brief qcamlib configuration
+ */
+typedef struct _qcamlib_config_t {
+    qcamlib_stream_dim_t preview_dim;
+    qcamlib_stream_dim_t video_dim;
+} qcamlib_config_t;
+
+/**
+ *  @brief opaque datatype for qcamilb handle
+ */
+typedef struct _qcamlib_obj* qcamlib_t;
+
+/**
+ * @brief Function pointer type for frame callbacks
+ */
+typedef void (*qcamlib_frame_cb) (qcamlib_cb_data_t frame);
+
+/**
+ * @brief Create qcamlib instance and initialize camera
+ * @return
+ *    returns qcamlib handle, NULL if failed
+ */
+qcamlib_t qcamlib_create();
 
 /**
  * @brief Clean up library resources
+ *
+ */
+void qcamlib_destroy(qcamlib_t h);
+
+/**
+ * @brief Start the Preview stream
+ * @param h qcamlib handle
  * @return int
  *    returns 0 on success, negative value on failure
  */
-int qcamlib_exit(void);
+int qcamlib_start_preview(qcamlib_t h);
 
 /**
- * @brief Start the Preview stream
+ * @brief Stop the Preview stream
+ * @param h qcamlib handle
  * @return int
  *    returns 0 on success, negative value on failure
  */
-int qcamlib_start_preview(void);
+int qcamlib_stop_preview(qcamlib_t h);
 
 /**
- * @brief Start the Preview stream
+ * @brief Start the Video stream
+ * @param h qcamlib handle
  * @return int
  *    returns 0 on success, negative value on failure
  */
-int qcamlib_stop_preview(void);
+int qcamlib_start_video(qcamlib_t h);
 
 /**
- * @brief Register preview callback
- * @param upcb pointer to the callback function
+ * @brief Stop the Video stream
+ * @param h qcamlib handle
  * @return int
  *    returns 0 on success, negative value on failure
  */
-int qcamlib_register_preview_cb(qcamlib_preview_cb upcb);
+int qcamlib_stop_video(qcamlib_t h);
 
 /**
- * @brief Deregister preview callback
+ * @brief Register preview frame callback
+ * @param h qcamlib handle
+ * @param upcb pointer to the callback function
  * @return int
  *    returns 0 on success, negative value on failure
  */
-int qcamlib_deregister_preview_cb(void);
+int qcamlib_register_preview_cb(qcamlib_t h, qcamlib_frame_cb upcb);
 
 /**
- * @brief copy preview frame to user buffer
- * @param buf  user allocated array of size bufsize
- * @param frame frame handle returned by a preview callback
- * @param buf_size size of the buf
+ * @brief Register video frame callback
+ * @param h qcamlib handle
+ * @param uvcb pointer to the callback function
  * @return int
  *    returns 0 on success, negative value on failure
  */
-int qcamlib_copy_preview_frame(uint8_t *buf, void* frame, uint32_t buf_size);
+int qcamlib_register_video_cb(qcamlib_t h, qcamlib_frame_cb uvcb);
+
+/**
+ * @brief Deregister preview callback
+ * @param h qcamlib handle
+ */
+void qcamlib_deregister_preview_cb(qcamlib_t h);
+
+/**
+ * @brief Deregister video callback
+ * @param h qcamlib handle
+ */
+void qcamlib_deregister_video_cb(qcamlib_t h);
+
+/**
+ * @brief get frame buffer info for a stream
+ * @param h qcamlib handle
+ * @param stream_type type of the stream
+ * @return qcamlib_frame_info_t
+ *    returns structure with frame buffer information
+ */
+qcamlib_frame_info_t qcamlib_get_frame_info(qcamlib_t h,
+                                            qcamlib_stream_type_t stream_type);
+
+/**
+ * @brief set userdata that is going to be returned with
+ *        callbacks
+ * @param h qcamlib handle
+ * @param void* userdata pointer
+ */
+void qcamlib_set_cb_userdata(qcamlib_t h, void *userdata);
+
+/**
+ * @brief configure the camera parameters
+ * @param h qcamlib handle
+ * @param config configuration data structure
+ *
+ * @return int 0:success, non-zero: failure
+ */
+int qcamlib_configure(qcamlib_t h, qcamlib_config_t config);
 
 #endif
diff --git a/qcamlib/src/qcamlib.c b/qcamlib/src/qcamlib.c
index 2e49b55..0d77c0e 100644
--- a/qcamlib/src/qcamlib.c
+++ b/qcamlib/src/qcamlib.c
@@ -31,120 +31,314 @@
 #include "qcam_log.h"
 #include "qcamlib.h"
 #include <stdbool.h>
+#include <media/msm_media_info.h>
 
-static mm_camera_lib_handle g_lib_handle;
-static qcamlib_preview_cb g_upcb = NULL;
-static bool g_previewing = false;
+typedef struct _qcamlib_obj {
+    qcamlib_frame_cb pcb;
+    qcamlib_frame_cb vcb;
+    mm_camera_test_obj_t test_obj;
+    mm_camera_app_t app;
+    bool preview_on;
+    bool video_on;
+    void *cb_userdata;
+    bool video_preview;
+};
 
-#define PREVIEW_BUF_SIZE (DEFAULT_PREVIEW_WIDTH * DEFAULT_PREVIEW_HEIGHT * 1.5)
+qcamlib_t g_handle;
 
-int qcamlib_init()
+qcamlib_t qcamlib_create()
 {
-  int rc;
+    int rc;
+    if (g_handle != NULL) {
+        QCAM_ERR("only single qcamlib instance is supported");
+        return NULL;
+    }
+    qcamlib_t h = (qcamlib_t)malloc(sizeof(struct _qcamlib_obj));
+    if (h == NULL) {
+        QCAM_ERR("malloc() failed");
+        return h;
+    }
+    memset(h, 0x00, sizeof(struct _qcamlib_obj));
+
+    rc = mm_app_load_hal(&h->app);
+    if (rc != MM_CAMERA_OK) {
+        QCAM_ERR("mm_app_load_hal() failed");
+        goto cleanup;
+    }
+    rc = mm_app_open(&h->app, 0, &h->test_obj);
+    if (rc != MM_CAMERA_OK) {
+        QCAM_ERR("mm_app_open() rc=%d", rc);
+        goto cleanup;
+    }
+    h->video_preview = false;
+    g_handle = h;
+
+    h->test_obj.video_width = DEFAULT_VIDEO_WIDTH;
+    h->test_obj.video_height = DEFAULT_VIDEO_HEIGHT;
+    h->test_obj.preview_width = DEFAULT_PREVIEW_WIDTH;
+    h->test_obj.preview_height = DEFAULT_PREVIEW_HEIGHT;
+
+    return h;
+cleanup:
+    free(h);
+    return NULL;
+}
 
-  rc = mm_camera_lib_open(&g_lib_handle, 0);
+void qcamlib_destroy(qcamlib_t h)
+{
+  int rc;
+  if (h->preview_on) {
+    QCAM_ERR("preview needs to be stopped before exit");
+    // TODO: stop preview
+  }
+  rc = mm_app_close(&h->test_obj);
   if (rc != MM_CAMERA_OK) {
-    QCAM_ERR("mm_camera_lib_open() rc=%d", rc);
-    return -1;
+    QCAM_ERR("mm_app_close() failed");
   }
-  return 0;
+  free(h);
+  g_handle = NULL;
 }
 
-int qcamlib_exit()
+qcamlib_frame_info_t qcamlib_get_frame_info(qcamlib_t h,
+                                            qcamlib_stream_type_t stream_type)
 {
-  if (g_previewing) {
-    QCAM_ERR("preview needs to be stopped before exit");
-    return -1;
+  qcamlib_frame_info_t frame_info;
+
+  switch (stream_type) {
+    case QCAMLIB_STREAM_PREVIEW:
+      frame_info.fmt = QCAMLIB_FMT_NV21;
+      frame_info.width = h->test_obj.preview_width;
+      frame_info.height = h->test_obj.preview_height;
+      /* Y plane */
+      frame_info.planes[0].width = h->test_obj.preview_width;
+      frame_info.planes[0].height = h->test_obj.preview_height;
+      frame_info.planes[0].stride = h->test_obj.preview_width;
+      frame_info.planes[0].scanlines = h->test_obj.preview_height;
+      /* CbCr Plane */
+      frame_info.planes[1].width = h->test_obj.preview_width;
+      frame_info.planes[1].height = h->test_obj.preview_height/2;
+      frame_info.planes[1].stride = h->test_obj.preview_width;
+      frame_info.planes[1].scanlines = h->test_obj.preview_height/2;
+
+      frame_info.buf_size =
+          frame_info.planes[0].stride * frame_info.planes[0].scanlines +
+          frame_info.planes[1].stride * frame_info.planes[1].scanlines;
+
+      break;
+    case QCAMLIB_STREAM_VIDEO:
+      /* Video buffers are VENUS encoder compatible */
+      frame_info.fmt = QCAMLIB_FMT_NV12;
+      frame_info.width = h->test_obj.video_width;
+      frame_info.height = h->test_obj.video_height;
+      /* Y plane */
+      frame_info.planes[0].width = h->test_obj.video_width;
+      frame_info.planes[0].height = h->test_obj.video_height;
+      frame_info.planes[0].stride =
+          VENUS_Y_STRIDE(COLOR_FMT_NV12, h->test_obj.video_width);
+      frame_info.planes[0].scanlines =
+          VENUS_Y_SCANLINES(COLOR_FMT_NV12, h->test_obj.video_height);
+      /* CbCr Plane */
+      frame_info.planes[1].width = h->test_obj.video_width;
+      frame_info.planes[1].height = h->test_obj.video_height/2;
+      frame_info.planes[1].stride =
+          VENUS_UV_STRIDE(COLOR_FMT_NV12, h->test_obj.video_width);
+      frame_info.planes[1].scanlines =
+          VENUS_UV_SCANLINES(COLOR_FMT_NV12, h->test_obj.video_height);
+      frame_info.buf_size = VENUS_BUFFER_SIZE(COLOR_FMT_NV12,
+                                              h->test_obj.video_width,
+                                              h->test_obj.video_height);
   }
-  mm_camera_lib_close(&g_lib_handle);
-  return 0;
+  frame_info.planes[0].offset = 0;
+  frame_info.planes[0].len =
+    frame_info.planes[0].stride * frame_info.planes[0].scanlines;
+  frame_info.planes[1].offset = frame_info.planes[0].len;
+  frame_info.planes[1].len =
+    frame_info.planes[1].stride * frame_info.planes[1].scanlines;
+
+  return frame_info;
 }
 
-int qcamlib_start_preview()
+int qcamlib_start_preview(qcamlib_t h)
 {
   int rc;
   QCAM_INFO("starting preview");
-  rc = mm_camera_lib_start_stream(&g_lib_handle);
+
+  rc = mm_app_start_record_preview(&h->test_obj);
   if (rc != MM_CAMERA_OK) {
-      QCAM_ERR("mm_camera_lib_start_stream() rc=%d\n", rc);
+      QCAM_ERR("mm_app_start_record_preview() failed");
       return -1;
   }
-  g_previewing = true;
+  h->preview_on = true;
   return 0;
 }
 
-int qcamlib_stop_preview() {
+int qcamlib_start_video(qcamlib_t h)
+{
+    int rc;
+    QCAM_INFO("starting video");
+
+    /* set fps mode to fixed for video recording */
+    cam_fps_range_t fr;
+    fr.min_fps = 29.8;
+    fr.max_fps = 30.0;
+    fr.video_min_fps = 29.8;
+    fr.video_max_fps = 30.0;
+
+    rc = setFPSRange(&h->test_obj, fr);
+    if (rc != MM_CAMERA_OK) {
+        QCAM_ERR("setFPSRange() rc=%d", rc);
+        return -1;
+    }
+
+    /* set AF mode to continuous video */
+    cam_focus_mode_type af_mode = CAM_FOCUS_MODE_CONTINOUS_VIDEO;
+    rc = setFocusMode(&h->test_obj, af_mode);
+    if (rc != MM_CAMERA_OK) {
+        QCAM_ERR("setFocusMode() rc=%d", rc);
+        return -1;
+    }
+
+    if (h->preview_on == false) {
+        rc = qcamlib_start_preview(h);
+        if (rc != 0) {
+            QCAM_ERR("qcamlib_start_preview() failed");
+            return -1;
+        }
+        /* this indicates the preview is started by qcamlib
+           internally for video recording, not by user */
+        h->video_preview = true;
+    }
+    rc = mm_app_start_record(&h->test_obj);
+    if (rc != MM_CAMERA_OK) {
+        QCAM_ERR("mm_app_start_record() failed");
+        return -1;
+    }
+    h->video_on = true;
+    return 0;
+}
+
+int qcamlib_stop_video(qcamlib_t h)
+{
   int rc;
-  QCAM_INFO("stopping preview");
-  rc = mm_camera_lib_stop_stream(&g_lib_handle);
+  QCAM_INFO("stopping video");
+  if (h->video_on == false) {
+      QCAM_ERR("video not started");
+      return 0;
+  }
+  rc = mm_app_stop_record(&h->test_obj);
   if (rc != MM_CAMERA_OK) {
-      QCAM_ERR("mm_camera_lib_stop_stream() rc=%d\n", rc);
+      QCAM_ERR("mm_app_stop_record() failed");
       return -1;
   }
-  g_previewing = false;
+  h->video_on = false;
+
+  if (h->video_preview == true) {
+      rc = qcamlib_stop_preview(h);
+      if (rc != 0) {
+          QCAM_ERR("qcamlib_stop_preview() failed");
+          return -1;
+      }
+      h->video_preview = false;
+  }
   return 0;
 }
 
-void preview_cb_internal(mm_camera_buf_def_t *frame)
+int qcamlib_stop_preview(qcamlib_t h)
 {
-  if (g_upcb) {
-    g_upcb((void*) frame);
+  int rc;
+  QCAM_INFO("stopping preview");
+
+  if (h->video_on) {
+    QCAM_ERR("cannot stop preview before video");
+    return -1;
   }
+  rc = mm_app_stop_record_preview(&h->test_obj);
+  if (rc != MM_CAMERA_OK) {
+      QCAM_ERR("mm_app_stop_record_preview() failed");
+      return -1;
+  }
+  h->preview_on = false;
+  return 0;
 }
 
-int qcamlib_register_preview_cb(qcamlib_preview_cb upcb)
+static void preview_cb_internal(mm_camera_buf_def_t *buf_def)
+{
+    qcamlib_cb_data_t frame;
+    qcamlib_t h = g_handle;
+    if (h->pcb == NULL) {
+        return;
+    }
+    frame.buffer = buf_def->buffer;
+    frame.ts = buf_def->ts;
+    frame.userdata = h->cb_userdata;
+    h->pcb(frame);
+}
+
+static void video_cb_internal(mm_camera_buf_def_t *buf_def)
+{
+    qcamlib_cb_data_t frame;
+    qcamlib_t h = g_handle;
+    if (h->vcb == NULL) {
+        return;
+    }
+    frame.buffer = buf_def->buffer;
+    frame.ts = buf_def->ts;
+    frame.userdata = h->cb_userdata;
+    h->vcb(frame);
+}
+
+int qcamlib_register_preview_cb(qcamlib_t h, qcamlib_frame_cb upcb)
 {
   int rc;
-  if (g_previewing) {
+  if (h->preview_on) {
     QCAM_ERR("preview callback needs to be set before starting the preview");
     return -1;
   }
-  g_upcb = upcb;
-  prev_callback pcb = (upcb) ? preview_cb_internal : NULL;
-  rc = mm_camera_lib_set_preview_usercb(&g_lib_handle, pcb);
+  h->pcb = upcb;
+  h->test_obj.user_preview_cb = (upcb) ? preview_cb_internal : NULL;
+  return 0;
+}
 
-  if (rc != MM_CAMERA_OK) {
-    QCAM_ERR("mm_camera_lib_set_preview_usercb() rc=%d\n", rc);
+int qcamlib_register_video_cb(qcamlib_t h, qcamlib_frame_cb uvcb)
+{
+  int rc;
+  if (h->video_on) {
+    QCAM_ERR("video callback needs to be set before starting the video");
     return -1;
   }
+  h->vcb = uvcb;
+  h->test_obj.user_video_cb = (uvcb) ? video_cb_internal : NULL;
   return 0;
 }
 
-int qcamlib_deregister_preview_cb()
+void qcamlib_deregister_preview_cb(qcamlib_t h)
 {
-  return qcamlib_register_preview_cb(NULL);
+    h->pcb = NULL;
+    h->test_obj.user_preview_cb = NULL;
+    return 0;
 }
 
-int qcamlib_copy_preview_frame(uint8_t *buf, void* frame, uint32_t buf_size)
+void qcamlib_deregister_video_cb(qcamlib_t h)
 {
-  mm_camera_buf_def_t * _frame = (mm_camera_buf_def_t*) frame;
-
-  if (buf_size < PREVIEW_BUF_SIZE) {
-    QCAM_ERR("buf_size=%d, need to be at least %d", buf_size, PREVIEW_BUF_SIZE);
-    return -EINVAL;
-  }
-  if (frame == NULL) {
-    QCAM_ERR("frame NULL");
-    return -EINVAL;
-  }
-  if (buf == NULL) {
-    QCAM_ERR("buf NULL");
-    return -EINVAL;
-  }
+    h->vcb = NULL;
+    h->test_obj.user_video_cb = NULL;
+    return 0;
+}
 
-  uint32_t offset = 0;
-  int i;
-  for (i=0; i < _frame->num_planes; i++) {
-    memcpy(buf + offset, _frame->buffer + offset, _frame->planes[i].length);
-    offset +=  _frame->planes[i].length;
-  }
-  return 0;
+void qcamlib_set_cb_userdata(qcamlib_t h, void *userdata)
+{
+    h->cb_userdata = userdata;
 }
 
-/* get preview frame buffer size */
-uint32_t qcamlib_get_preview_bufsize()
+int qcamlib_configure(qcamlib_t h, qcamlib_config_t config)
 {
-  /* TODO: returning the default size for now, add logic to calculate size
-     based on current resolution */
-  return PREVIEW_BUF_SIZE;
+    // TODO: add input validation
+    h->test_obj.preview_width = config.preview_dim.width;
+    h->test_obj.preview_height = config.preview_dim.height;
+    h->test_obj.video_width = config.video_dim.width;
+    h->test_obj.video_height = config.video_dim.height;
+    QCAM_DBG("preview %dx%d, video %dx%d", h->test_obj.preview_width,
+             h->test_obj.preview_height, h->test_obj.video_width,
+             h->test_obj.video_height);
+    return 0;
 }
diff --git a/qcamlib/test/qcamlib_test.c b/qcamlib/test/qcamlib_test.c
index 99e86f8..67289bf 100644
--- a/qcamlib/test/qcamlib_test.c
+++ b/qcamlib/test/qcamlib_test.c
@@ -43,18 +43,36 @@
 
 #define PRINT_FPS             0
 
-uint32_t frame_count = 0;
+uint32_t p_frame_count = 0;
+uint32_t v_frame_count = 0;
 uint32_t dump_count = 0;
+uint32_t v_dump_count = 0;
 uint32_t dump_count_max = DEF_DUMP_COUNT_MAX;
 uint32_t dump_interval = DEF_DUMP_INTERVAL;
-uint8_t *buf = NULL;
-uint32_t bufsize = 0;
+uint8_t *p_buf = NULL;
+uint32_t p_bufsize = 0;
+uint8_t *v_buf = NULL;
+uint32_t v_bufsize = 0;
 bool previewing = false;
-
+static bool streaming = false;
 char *outdir = DEF_OUTPUT_DIR;
 
+qcamlib_frame_info_t preview_info, video_info;
+
+#define YUV420_BUF_SIZE(w, h) ((w) * (h) * 3/2)
+
+
 struct timeval tv0, tv1;
 
+int64_t p_ns0 = 0, v_ns0 = 0;
+int64_t p_diff=0, v_diff=0;
+
+FILE *video_fp;
+
+static bool enable_video = false;
+
+static qcamlib_t h_cam;
+
 char usage_str[] =
   "usage: qcamlib-test [options]\n"
   "\n"
@@ -68,56 +86,114 @@ char usage_str[] =
   "        print this message\n"
 ;
 
-void preview_cb(void* frame)
+int save_frame_to_file(char *filename, uint8_t *buf, uint32_t size)
 {
   int rc;
-  frame_count++;
+  FILE *fp;
+  fp = fopen(filename, "w");
+  if (!fp) {
+    perror("fopen() failed\n");
+    return -1;
+  }
+  rc = fwrite(buf, size, 1, fp);
+  if (rc != 1) {
+    perror("fwrite() failed\n");
+    return -1;
+  }
+  fclose(fp);
+  return 0;
+}
+
+int copy_frame_to_buf(qcamlib_cb_data_t frame, qcamlib_frame_info_t frame_info,
+                      uint8_t *buf)
+{
+    int i;
+    uint32_t src_offset, dest_offset;
+    /* copy one line at a time */
+    /* Y plane */
+    src_offset = frame_info.planes[0].offset;
+    dest_offset = 0;
+    for (i=0; i<frame_info.height; i++) {
+        memcpy(buf + dest_offset, frame.buffer + src_offset,
+               frame_info.width);
+        src_offset += frame_info.planes[0].stride;
+        dest_offset += frame_info.width;
+    }
+    /* UV plane */
+    src_offset = frame_info.planes[1].offset;
+    dest_offset = frame_info.width * frame_info.height;
+    for (i=0; i<frame_info.height/2; i++) {
+        memcpy(buf + dest_offset, frame.buffer + src_offset,
+               frame_info.width);
+        src_offset += frame_info.planes[1].stride;
+        dest_offset += frame_info.width;
+    }
+    return 0;
+}
+
+void video_cb(qcamlib_cb_data_t frame)
+{
+  int rc;
+  v_frame_count++;
+
+  int64_t ns1 = frame.ts.tv_sec * 1000000000LL + frame.ts.tv_nsec;
+  v_diff = (v_diff + (ns1 - v_ns0))/2;
+  v_ns0 = ns1;
 
 #if PRINT_FPS
-  if (frame_count % 30 == 0) {
-    gettimeofday(&tv1, NULL);
-    double t_diff = (tv1.tv_sec - tv0.tv_sec) +
-      (tv1.tv_usec - tv0.tv_usec) / 1000000.0;
-    fprintf(stderr, "tv_diff = %f, fps = %f\n", t_diff, 30.0/t_diff);
-    tv0 = tv1;
+  if (v_frame_count % 30 == 0) {
+    fprintf(stderr, "video fps = %0.2f\n", 1e9/v_diff);
   }
 #endif
+  /* copy video frame to local buffer */
+  copy_frame_to_buf(frame, video_info, v_buf);
 
-  if ((frame_count-1) % dump_interval == 0 && dump_count < dump_count_max) {
-    rc = qcamlib_copy_preview_frame(buf, frame, bufsize);
-    if (rc < 0) {
-      perror("copy frame failed\n");
-      return;
-    }
-    FILE *fp;
+  rc = fwrite(v_buf, v_bufsize, 1, video_fp);
+  if (rc != 1) {
+    perror("fwrite() failed\n");
+    return;
+  }
+}
+
+void preview_cb(qcamlib_cb_data_t frame)
+{
+  int rc;
+  p_frame_count++;
+
+#if PRINT_FPS
+  int64_t ns1 = frame.ts.tv_sec * 1000000000LL + frame.ts.tv_nsec;
+  p_diff = (p_diff + (ns1 - p_ns0))/2;
+  p_ns0 = ns1;
+  if (p_frame_count % 30 == 0) {
+    fprintf(stderr, "preview fps = %0.2f\n", 1e9/p_diff);
+  }
+#endif
+
+  if ((p_frame_count-1) % dump_interval == 0 && dump_count < dump_count_max) {
+    /* copy the camera frame to local buffer */
+    copy_frame_to_buf(frame, preview_info, p_buf);
     char filename[128];
-    snprintf(filename, 128, "%s/frame_%d_3840x2160_NV21.yuv",
-             outdir, frame_count);
-    fp = fopen(filename, "w");
-    if (!fp) {
-      perror("fopen() failed\n");
-      return;
-    }
-    rc = fwrite(buf, bufsize, 1, fp);
-    if (rc != 1) {
-      perror("fwrite() failed\n");
+    snprintf(filename, 128, "%s/p_frame_%d_%dx%d_NV21.yuv",
+             outdir, p_frame_count, preview_info.planes[0].width,
+             preview_info.planes[0].height);
+    rc = save_frame_to_file(filename, p_buf, p_bufsize);
+    if (rc < 0) {
+      perror("save failed\n");
       return;
     }
     dump_count++;
-    fclose(fp);
   }
 }
 
 void print_usage()
 {
   printf("%s", usage_str);
-  return 0;
 }
 
 int parse_commadline(int argc, char* argv[])
 {
   int c;
-  while ((c = getopt (argc, argv, "hi:n:o:")) != -1) {
+  while ((c = getopt (argc, argv, "hi:n:o:v")) != -1) {
     switch (c) {
       case 'o':
         outdir = optarg;
@@ -128,6 +204,9 @@ int parse_commadline(int argc, char* argv[])
       case 'n':
         dump_count_max = atoi(optarg);
         break;
+      case 'v':
+        enable_video = true;
+        break;
       case 'h':
         print_usage();
         exit(0);
@@ -142,16 +221,40 @@ int parse_commadline(int argc, char* argv[])
 
 void print_menu()
 {
-  printf("\nSelect an option\n");
-  printf("\t1. Start preview\n");
-  printf("\t2. Stop preview\n");
-  printf("\t3. Exit\n");
+  printf("\nSelect an option");
+  if (enable_video) {
+    printf("[video enabled]");
+  }
+  printf("\n");
+  if (streaming) {
+    printf("\t1. Stop streaming\n");
+  } else {
+    printf("\t1. Start streaming\n");
+  }
+  printf("\t2. Exit\n");
   printf("\nSelect: ");
 }
 
-int main(int argc, char *argv[])
+void start_streaming()
 {
+  qcamlib_start_preview(h_cam);
+  if (enable_video) {
+    qcamlib_start_video(h_cam);
+  }
+  streaming = true;
+}
 
+void stop_streaming()
+{
+  if (enable_video) {
+    qcamlib_stop_video(h_cam);
+  }
+  qcamlib_stop_preview(h_cam);
+  streaming = false;
+}
+
+int main(int argc, char *argv[])
+{
   parse_commadline(argc, argv);
 
   printf("---- qcamlib test application ----\n");
@@ -161,17 +264,54 @@ int main(int argc, char *argv[])
     mkdir(outdir, 0777);
   }
 
-  qcamlib_init();
+  h_cam = qcamlib_create();
+  if (h_cam == NULL) {
+      perror("qcamlib_create() failed");
+      return -1;
+  }
+
+  qcamlib_config_t config;
+  memset(&config, 0x00, sizeof(qcamlib_config_t));
+
+  config.video_dim.width = 1920;
+  config.video_dim.height = 1080;
+  if (enable_video == true) {
+      config.preview_dim.width = 1280;
+      config.preview_dim.height = 720;
+  } else {
+      config.preview_dim.width = 3840;
+      config.preview_dim.height = 2160;
+  }
+
+  qcamlib_configure(h_cam, config);
 
-  bufsize = qcamlib_get_preview_bufsize();
-  buf = (uint8_t *) malloc (bufsize);
+  preview_info = qcamlib_get_frame_info(h_cam, QCAMLIB_STREAM_PREVIEW);
+  video_info = qcamlib_get_frame_info(h_cam, QCAMLIB_STREAM_VIDEO);
 
-  if (!buf) {
+  v_bufsize = video_info.buf_size;
+  p_bufsize = preview_info.buf_size;
+  p_buf = (uint8_t *)malloc(p_bufsize);
+  if (!p_buf) {
     perror("malloc failed\n");
-    qcamlib_exit();
+    qcamlib_destroy(h_cam);
     goto exit;
   }
-  qcamlib_register_preview_cb(preview_cb);
+  v_buf = (uint8_t *)malloc(v_bufsize);
+  if (!v_buf) {
+    perror("v_buf malloc failed\n");
+    qcamlib_destroy(h_cam);
+    goto exit;
+  }
+  char v_filename[128];
+  snprintf(v_filename, 128, "video_%dx%d_nv12.yuv",
+           video_info.planes[0].width,  video_info.planes[0].width);
+  video_fp = fopen(v_filename, "w");
+  if (video_fp == NULL) {
+    perror("fopen() failed\n");
+    goto exit;
+  }
+  qcamlib_register_preview_cb(h_cam, preview_cb);
+  qcamlib_register_video_cb(h_cam, video_cb);
 
   int option;
   do {
@@ -182,32 +322,32 @@ int main(int argc, char *argv[])
     }
     switch (option) {
       case 1:
-        if (!previewing) {
-          qcamlib_start_preview();
-          previewing = true;
+        if (streaming) {
+          stop_streaming();
+          printf(">> streaming stopped\n");
+        } else {
+          start_streaming();
+          printf(">> streaming started\n");
         }
         break;
       case 2:
-        if (previewing) {
-          qcamlib_stop_preview();
-          previewing = false;
-        }
-        break;
-      case 3:
-        if (previewing) {
-          qcamlib_stop_preview();
-          previewing = false;
+        if (streaming) {
+          stop_streaming();
+          printf(">> streaming stopped\n");
         }
         goto exit;
       default:
-        printf("invalid option\n");
+        printf(">> invalid option\n");
         continue;
     }
   } while (1);
 
+  fclose(video_fp);
+
 exit:
-  free(buf);
-  qcamlib_exit();
-  printf("DONE.\n");
+  free(p_buf);
+  free(v_buf);
+  qcamlib_destroy(h_cam);
+  printf(">> DONE\n");
   return 0;
 }
-- 
1.9.1

