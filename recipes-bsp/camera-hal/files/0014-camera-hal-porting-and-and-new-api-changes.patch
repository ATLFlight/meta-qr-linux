From cf472935342bd2a613feb8f789ce2a31df096423 Mon Sep 17 00:00:00 2001
From: Punit Soni <punits@codeaurora.org>
Date: Wed, 12 Aug 2015 11:46:36 -0700
Subject: [PATCH] camera-hal: porting and and new api changes

- Port the QCamera2/HAL interface for Linux
- add new camera API library

Change-Id: I017dcc3f5b186de2ce99406d510d65e9d6fb77a6
---
 Makefile.am                                        |   4 +
 .../stack/mm-camera-interface/inc/mm_camera_dbg.h  |   2 +-
 QCamera2/HAL/CameraParameters.cpp                  | 525 ++++++++++++++++
 QCamera2/HAL/CameraParameters.h                    | 693 +++++++++++++++++++++
 QCamera2/HAL/Makefile.am                           |  35 ++
 QCamera2/HAL/QCamera2HWI.cpp                       | 112 +++-
 QCamera2/HAL/QCamera2HWI.h                         |  13 +
 QCamera2/HAL/QCamera2HWICallbacks.cpp              | 106 +++-
 QCamera2/HAL/QCameraMem.cpp                        |  12 +-
 QCamera2/HAL/QCameraMem.h                          |   3 +-
 QCamera2/HAL/QCameraParameters.cpp                 | 207 +++---
 QCamera2/HAL/QCameraParameters.h                   |  43 +-
 QCamera2/HAL/QCameraPostProc.cpp                   |   5 +-
 QCamera2/HAL/QCameraThermalAdapter.cpp             |   3 +-
 QCamera2/stack/common/cam_list.h                   |   7 +
 .../mm-camera-interface/src/mm_camera_interface.c  |   1 +
 QCamera2/util/QCameraCmdThread.cpp                 |   6 +
 QCamera2/util/QCameraQueue.cpp                     |   5 +
 QCameraParameters.h                                | 257 --------
 android_adapter.h                                  |  20 +
 configure.ac                                       |  10 +-
 libcamera/Makefile.am                              |  41 ++
 libcamera/inc/camera.h                             | 350 +++++++++++
 libcamera/inc/camera_parameters.h                  | 414 ++++++++++++
 libcamera/src/camera_log.h                         |  53 ++
 libcamera/src/camera_memory.cpp                    | 113 ++++
 libcamera/src/camera_memory.h                      |  65 ++
 libcamera/src/camera_parameters.cpp                | 492 +++++++++++++++
 libcamera/src/qcamera2.cpp                         | 556 +++++++++++++++++
 libcamera/src/qcamera_extensions.h                 | 306 +++++++++
 libcamera/test/camera_test.cpp                     | 425 +++++++++++++
 31 files changed, 4472 insertions(+), 412 deletions(-)
 mode change 100755 => 100644 QCamera/stack/mm-camera-interface/inc/mm_camera_dbg.h
 create mode 100644 QCamera2/HAL/CameraParameters.cpp
 create mode 100644 QCamera2/HAL/CameraParameters.h
 create mode 100644 QCamera2/HAL/Makefile.am
 mode change 100755 => 100644 QCamera2/stack/common/cam_list.h
 mode change 100755 => 100644 QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c
 delete mode 100644 QCameraParameters.h
 create mode 100644 android_adapter.h
 create mode 100644 libcamera/Makefile.am
 create mode 100644 libcamera/inc/camera.h
 create mode 100644 libcamera/inc/camera_parameters.h
 create mode 100644 libcamera/src/camera_log.h
 create mode 100644 libcamera/src/camera_memory.cpp
 create mode 100644 libcamera/src/camera_memory.h
 create mode 100644 libcamera/src/camera_parameters.cpp
 create mode 100644 libcamera/src/qcamera2.cpp
 create mode 100644 libcamera/src/qcamera_extensions.h
 create mode 100644 libcamera/test/camera_test.cpp

diff --git a/Makefile.am b/Makefile.am
index b8916fb..1f050ef 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,9 +1,13 @@
 ACLOCAL_AMFLAGS = -I m4
 
+AM_CPPFLAGS = `pkg-config --cflags glib-2.0`
+
 dirs =
 dirs += mm-image-codec
 dirs += QCamera2/stack
+dirs += QCamera2/HAL
 dirs += qcamlib
+dirs += libcamera
 
 SUBDIRS = $(dirs)
 
diff --git a/QCamera/stack/mm-camera-interface/inc/mm_camera_dbg.h b/QCamera/stack/mm-camera-interface/inc/mm_camera_dbg.h
old mode 100755
new mode 100644
index 3bdfe6f..eda9d5a
--- a/QCamera/stack/mm-camera-interface/inc/mm_camera_dbg.h
+++ b/QCamera/stack/mm-camera-interface/inc/mm_camera_dbg.h
@@ -30,7 +30,7 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __MM_CAMERA_DBG_H__
 #define __MM_CAMERA_DBG_H__
 
-//#define LOG_DEBUG 1
+#define LOG_DEBUG 0
 
 #ifndef LOG_DEBUG
   #ifdef _ANDROID_
diff --git a/QCamera2/HAL/CameraParameters.cpp b/QCamera2/HAL/CameraParameters.cpp
new file mode 100644
index 0000000..b9cee96
--- /dev/null
+++ b/QCamera2/HAL/CameraParameters.cpp
@@ -0,0 +1,525 @@
+/*
+Copyright (c) 2014, The Linux Foundation. All rights reserved.
+Not a Contribution.
+
+Copyright 2008, The Android Open Source Project
+
+Licensed under the Apache License, Version 2.0 (the "License"); you
+may not use this file except in compliance with the License.  You may
+obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+implied.  See the License for the specific language governing
+permissions and limitations under the License
+*/
+
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define LOG_TAG "CameraParams"
+
+#if defined(USE_DLOG)
+  #include <dlog/dlog.h>
+#else
+  //#include <utils/Log.h>
+#endif
+
+#include <stdio.h>
+#include <unistd.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include "CameraParameters.h"
+#include "android_adapter.h"
+
+namespace android {
+// Parameter keys to communicate between camera application and driver.
+const char CameraParameters::KEY_PREVIEW_SIZE[] = "preview-size";
+const char CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES[] = "preview-size-values";
+const char CameraParameters::KEY_PREVIEW_FORMAT[] = "preview-format";
+const char CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS[] = "preview-format-values";
+const char CameraParameters::KEY_PREVIEW_FRAME_RATE[] = "preview-frame-rate";
+const char CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES[] = "preview-frame-rate-values";
+const char CameraParameters::KEY_PREVIEW_FPS_RANGE[] = "preview-fps-range";
+const char CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE[] = "preview-fps-range-values";
+const char CameraParameters::KEY_PICTURE_SIZE[] = "picture-size";
+const char CameraParameters::KEY_SUPPORTED_PICTURE_SIZES[] = "picture-size-values";
+const char CameraParameters::KEY_PICTURE_FORMAT[] = "picture-format";
+const char CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS[] = "picture-format-values";
+const char CameraParameters::KEY_JPEG_THUMBNAIL_WIDTH[] = "jpeg-thumbnail-width";
+const char CameraParameters::KEY_JPEG_THUMBNAIL_HEIGHT[] = "jpeg-thumbnail-height";
+const char CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES[] = "jpeg-thumbnail-size-values";
+const char CameraParameters::KEY_JPEG_THUMBNAIL_QUALITY[] = "jpeg-thumbnail-quality";
+const char CameraParameters::KEY_JPEG_QUALITY[] = "jpeg-quality";
+const char CameraParameters::KEY_ROTATION[] = "rotation";
+const char CameraParameters::KEY_GPS_LATITUDE[] = "gps-latitude";
+const char CameraParameters::KEY_GPS_LONGITUDE[] = "gps-longitude";
+const char CameraParameters::KEY_GPS_ALTITUDE[] = "gps-altitude";
+const char CameraParameters::KEY_GPS_TIMESTAMP[] = "gps-timestamp";
+const char CameraParameters::KEY_GPS_PROCESSING_METHOD[] = "gps-processing-method";
+const char CameraParameters::KEY_WHITE_BALANCE[] = "whitebalance";
+const char CameraParameters::KEY_SUPPORTED_WHITE_BALANCE[] = "whitebalance-values";
+const char CameraParameters::KEY_EFFECT[] = "effect";
+const char CameraParameters::KEY_SUPPORTED_EFFECTS[] = "effect-values";
+const char CameraParameters::KEY_ANTIBANDING[] = "antibanding";
+const char CameraParameters::KEY_SUPPORTED_ANTIBANDING[] = "antibanding-values";
+const char CameraParameters::KEY_SCENE_MODE[] = "scene-mode";
+const char CameraParameters::KEY_SUPPORTED_SCENE_MODES[] = "scene-mode-values";
+const char CameraParameters::KEY_FLASH_MODE[] = "flash-mode";
+const char CameraParameters::KEY_SUPPORTED_FLASH_MODES[] = "flash-mode-values";
+const char CameraParameters::KEY_FOCUS_MODE[] = "focus-mode";
+const char CameraParameters::KEY_SUPPORTED_FOCUS_MODES[] = "focus-mode-values";
+const char CameraParameters::KEY_MAX_NUM_FOCUS_AREAS[] = "max-num-focus-areas";
+const char CameraParameters::KEY_FOCUS_AREAS[] = "focus-areas";
+const char CameraParameters::KEY_FOCAL_LENGTH[] = "focal-length";
+const char CameraParameters::KEY_HORIZONTAL_VIEW_ANGLE[] = "horizontal-view-angle";
+const char CameraParameters::KEY_VERTICAL_VIEW_ANGLE[] = "vertical-view-angle";
+const char CameraParameters::KEY_EXPOSURE_COMPENSATION[] = "exposure-compensation";
+const char CameraParameters::KEY_MAX_EXPOSURE_COMPENSATION[] = "max-exposure-compensation";
+const char CameraParameters::KEY_MIN_EXPOSURE_COMPENSATION[] = "min-exposure-compensation";
+const char CameraParameters::KEY_EXPOSURE_COMPENSATION_STEP[] = "exposure-compensation-step";
+const char CameraParameters::KEY_AUTO_EXPOSURE_LOCK[] = "auto-exposure-lock";
+const char CameraParameters::KEY_AUTO_EXPOSURE_LOCK_SUPPORTED[] = "auto-exposure-lock-supported";
+const char CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK[] = "auto-whitebalance-lock";
+const char CameraParameters::KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED[] = "auto-whitebalance-lock-supported";
+const char CameraParameters::KEY_MAX_NUM_METERING_AREAS[] = "max-num-metering-areas";
+const char CameraParameters::KEY_METERING_AREAS[] = "metering-areas";
+const char CameraParameters::KEY_ZOOM[] = "zoom";
+const char CameraParameters::KEY_MAX_ZOOM[] = "max-zoom";
+const char CameraParameters::KEY_ZOOM_RATIOS[] = "zoom-ratios";
+const char CameraParameters::KEY_ZOOM_SUPPORTED[] = "zoom-supported";
+const char CameraParameters::KEY_SMOOTH_ZOOM_SUPPORTED[] = "smooth-zoom-supported";
+const char CameraParameters::KEY_FOCUS_DISTANCES[] = "focus-distances";
+const char CameraParameters::KEY_VIDEO_FRAME_FORMAT[] = "video-frame-format";
+const char CameraParameters::KEY_VIDEO_SIZE[] = "video-size";
+const char CameraParameters::KEY_SUPPORTED_VIDEO_SIZES[] = "video-size-values";
+const char CameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO[] = "preferred-preview-size-for-video";
+const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_HW[] = "max-num-detected-faces-hw";
+const char CameraParameters::KEY_MAX_NUM_DETECTED_FACES_SW[] = "max-num-detected-faces-sw";
+const char CameraParameters::KEY_RECORDING_HINT[] = "recording-hint";
+const char CameraParameters::KEY_VIDEO_SNAPSHOT_SUPPORTED[] = "video-snapshot-supported";
+const char CameraParameters::KEY_VIDEO_STABILIZATION[] = "video-stabilization";
+const char CameraParameters::KEY_VIDEO_STABILIZATION_SUPPORTED[] = "video-stabilization-supported";
+const char CameraParameters::KEY_LIGHTFX[] = "light-fx";
+
+const char CameraParameters::TRUE[] = "true";
+const char CameraParameters::FALSE[] = "false";
+const char CameraParameters::FOCUS_DISTANCE_INFINITY[] = "Infinity";
+
+// Values for white balance settings.
+const char CameraParameters::WHITE_BALANCE_AUTO[] = "auto";
+const char CameraParameters::WHITE_BALANCE_INCANDESCENT[] = "incandescent";
+const char CameraParameters::WHITE_BALANCE_FLUORESCENT[] = "fluorescent";
+const char CameraParameters::WHITE_BALANCE_WARM_FLUORESCENT[] = "warm-fluorescent";
+const char CameraParameters::WHITE_BALANCE_DAYLIGHT[] = "daylight";
+const char CameraParameters::WHITE_BALANCE_CLOUDY_DAYLIGHT[] = "cloudy-daylight";
+const char CameraParameters::WHITE_BALANCE_TWILIGHT[] = "twilight";
+const char CameraParameters::WHITE_BALANCE_SHADE[] = "shade";
+const char CameraParameters::WHITE_BALANCE_MANUAL_CCT[] = "manual-cct";
+
+// Values for effect settings.
+const char CameraParameters::EFFECT_NONE[] = "none";
+const char CameraParameters::EFFECT_MONO[] = "mono";
+const char CameraParameters::EFFECT_NEGATIVE[] = "negative";
+const char CameraParameters::EFFECT_SOLARIZE[] = "solarize";
+const char CameraParameters::EFFECT_SEPIA[] = "sepia";
+const char CameraParameters::EFFECT_POSTERIZE[] = "posterize";
+const char CameraParameters::EFFECT_WHITEBOARD[] = "whiteboard";
+const char CameraParameters::EFFECT_BLACKBOARD[] = "blackboard";
+const char CameraParameters::EFFECT_AQUA[] = "aqua";
+
+// Values for antibanding settings.
+const char CameraParameters::ANTIBANDING_AUTO[] = "auto";
+const char CameraParameters::ANTIBANDING_50HZ[] = "50hz";
+const char CameraParameters::ANTIBANDING_60HZ[] = "60hz";
+const char CameraParameters::ANTIBANDING_OFF[] = "off";
+
+// Values for flash mode settings.
+const char CameraParameters::FLASH_MODE_OFF[] = "off";
+const char CameraParameters::FLASH_MODE_AUTO[] = "auto";
+const char CameraParameters::FLASH_MODE_ON[] = "on";
+const char CameraParameters::FLASH_MODE_RED_EYE[] = "red-eye";
+const char CameraParameters::FLASH_MODE_TORCH[] = "torch";
+
+// Values for scene mode settings.
+const char CameraParameters::SCENE_MODE_AUTO[] = "auto";
+const char CameraParameters::SCENE_MODE_ACTION[] = "action";
+const char CameraParameters::SCENE_MODE_PORTRAIT[] = "portrait";
+const char CameraParameters::SCENE_MODE_LANDSCAPE[] = "landscape";
+const char CameraParameters::SCENE_MODE_NIGHT[] = "night";
+const char CameraParameters::SCENE_MODE_NIGHT_PORTRAIT[] = "night-portrait";
+const char CameraParameters::SCENE_MODE_THEATRE[] = "theatre";
+const char CameraParameters::SCENE_MODE_BEACH[] = "beach";
+const char CameraParameters::SCENE_MODE_SNOW[] = "snow";
+const char CameraParameters::SCENE_MODE_SUNSET[] = "sunset";
+const char CameraParameters::SCENE_MODE_STEADYPHOTO[] = "steadyphoto";
+const char CameraParameters::SCENE_MODE_FIREWORKS[] = "fireworks";
+const char CameraParameters::SCENE_MODE_SPORTS[] = "sports";
+const char CameraParameters::SCENE_MODE_PARTY[] = "party";
+const char CameraParameters::SCENE_MODE_CANDLELIGHT[] = "candlelight";
+const char CameraParameters::SCENE_MODE_BARCODE[] = "barcode";
+const char CameraParameters::SCENE_MODE_HDR[] = "hdr";
+
+const char CameraParameters::PIXEL_FORMAT_YUV422SP[] = "yuv422sp";
+const char CameraParameters::PIXEL_FORMAT_YUV420SP[] = "yuv420sp";
+const char CameraParameters::PIXEL_FORMAT_YUV422I[] = "yuv422i-yuyv";
+const char CameraParameters::PIXEL_FORMAT_YUV420P[]  = "yuv420p";
+const char CameraParameters::PIXEL_FORMAT_RGB565[] = "rgb565";
+const char CameraParameters::PIXEL_FORMAT_RGBA8888[] = "rgba8888";
+const char CameraParameters::PIXEL_FORMAT_JPEG[] = "jpeg";
+const char CameraParameters::PIXEL_FORMAT_BAYER_RGGB[] = "bayer-rggb";
+const char CameraParameters::PIXEL_FORMAT_ANDROID_OPAQUE[] = "android-opaque";
+
+// Values for focus mode settings.
+const char CameraParameters::FOCUS_MODE_AUTO[] = "auto";
+const char CameraParameters::FOCUS_MODE_INFINITY[] = "infinity";
+const char CameraParameters::FOCUS_MODE_MACRO[] = "macro";
+const char CameraParameters::FOCUS_MODE_FIXED[] = "fixed";
+const char CameraParameters::FOCUS_MODE_EDOF[] = "edof";
+const char CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO[] = "continuous-video";
+const char CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE[] = "continuous-picture";
+const char CameraParameters::FOCUS_MODE_MANUAL_POSITION[] = "manual";
+
+// Values for light fx settings
+const char CameraParameters::LIGHTFX_LOWLIGHT[] = "low-light";
+const char CameraParameters::LIGHTFX_HDR[] = "high-dynamic-range";
+
+CameraParameters::CameraParameters()
+                : mMap()
+{
+}
+
+CameraParameters::~CameraParameters()
+{
+}
+
+string CameraParameters::flatten() const
+{
+    string flattened("");
+    size_t size = mMap.size();
+
+    map<string, string>::const_iterator iter;
+    for (iter = mMap.begin(); iter != mMap.end(); iter ++) {
+        string k, v;
+        k = iter->first;
+        v = iter->second;
+
+        flattened += k;
+        flattened += "=";
+        flattened += v;
+        /* put a semicolon for every element other than the last one*/
+        //if (iter != std::prev(mMap.end()))
+        flattened += ";";
+    }
+
+    // remove last semicolon
+   flattened = flattened.substr(0, flattened.size()-1);
+    return flattened;
+}
+
+void CameraParameters::unflatten(const string &params)
+{
+    const char *a = params.c_str();
+    const char *b;
+
+    mMap.clear();
+
+    for (;;) {
+        // Find the bounds of the key name.
+        b = strchr(a, '=');
+        if (b == 0)
+            break;
+
+        // Create the key string.
+        string k(a, (size_t)(b-a));
+
+        // Find the value.
+        a = b+1;
+        b = strchr(a, ';');
+        if (b == 0) {
+            // If there's no semicolon, this is the last item.
+            string v(a);
+            //mMap.add(k, v);
+            mMap[k] = v;
+            break;
+        }
+
+        string v(a, (size_t)(b-a));
+        //mMap.add(k, v);
+        mMap[k] = v;
+        a = b+1;
+    }
+}
+
+
+void CameraParameters::set(const char *key, const char *value)
+{
+    // XXX i think i can do this with strspn()
+    if (strchr(key, '=') || strchr(key, ';')) {
+        //XXX ALOGE("Key \"%s\"contains invalid character (= or ;)", key);
+        return;
+    }
+
+    if (strchr(value, '=') || strchr(key, ';')) {
+        //XXX ALOGE("Value \"%s\"contains invalid character (= or ;)", value);
+        return;
+    }
+
+    //mMap.replaceValueFor(string(key), string(value));
+    mMap[string(key)] = string(value);
+}
+
+
+void CameraParameters::set(const char *key, string value)
+{
+  set(key, value.c_str());
+}
+
+void CameraParameters::set(string& key, string& value)
+{
+  set(key.c_str(), value.c_str());
+}
+
+void CameraParameters::set(const char *key, int value)
+{
+    char str[16];
+    sprintf(str, "%d", value);
+    set(key, str);
+}
+
+void CameraParameters::setFloat(const char *key, float value)
+{
+    char str[16];  // 14 should be enough. We overestimate to be safe.
+    snprintf(str, sizeof(str), "%g", value);
+    set(key, str);
+}
+
+const char *CameraParameters::get(const char *key) const
+{
+    //string v = mMap.valueFor(string(key));
+    string k(key);
+    //string v = mMap[k];
+    /* find the given key in map, if not found, return NULL */
+    map<string, string>::const_iterator it = mMap.find(k);
+    if (it == mMap.end()) {
+        return NULL;
+    }
+    const string &  v = it->second;
+    if (v.length() == 0)
+        return 0;
+    return v.c_str();
+}
+
+int CameraParameters::getInt(const char *key) const
+{
+    const char *v = get(key);
+    if (v == 0)
+        return -1;
+    return strtol(v, 0, 0);
+}
+
+float CameraParameters::getFloat(const char *key) const
+{
+    const char *v = get(key);
+    if (v == 0) return -1;
+    return strtof(v, 0);
+}
+
+void CameraParameters::remove(const char *key)
+{
+    //mMap.removeItem(string(key));
+    mMap.erase(string(key));
+}
+
+// Parse string like "640x480" or "10000,20000"
+static int parse_pair(const char *str, int *first, int *second, char delim,
+                      char **endptr = NULL)
+{
+    // Find the first integer.
+    char *end;
+    int w = (int)strtol(str, &end, 10);
+    // If a delimeter does not immediately follow, give up.
+    if (*end != delim) {
+        ALOGE("Cannot find delimeter (%c) in str=%s", delim, str);
+        return -1;
+    }
+
+    // Find the second integer, immediately after the delimeter.
+    int h = (int)strtol(end+1, &end, 10);
+
+    *first = w;
+    *second = h;
+
+    if (endptr) {
+        *endptr = end;
+    }
+
+    return 0;
+}
+
+static void parseSizesList(const char *sizesStr, vector<Size> &sizes)
+{
+    if (sizesStr == 0) {
+        return;
+    }
+
+    char *sizeStartPtr = (char *)sizesStr;
+
+    while (true) {
+        int width, height;
+        int success = parse_pair(sizeStartPtr, &width, &height, 'x',
+                                 &sizeStartPtr);
+        if (success == -1 || (*sizeStartPtr != ',' && *sizeStartPtr != '\0')) {
+            ALOGE("Picture sizes string \"%s\" contains invalid character.", sizesStr);
+            return;
+        }
+        sizes.push_back(Size(width, height));
+
+        if (*sizeStartPtr == '\0') {
+            return;
+        }
+        sizeStartPtr++;
+    }
+}
+
+void CameraParameters::setPreviewSize(int width, int height)
+{
+    char str[32];
+    sprintf(str, "%dx%d", width, height);
+    set(KEY_PREVIEW_SIZE, str);
+}
+
+void CameraParameters::getPreviewSize(int *width, int *height) const
+{
+    *width = *height = -1;
+    // Get the current string, if it doesn't exist, leave the -1x-1
+    const char *p = get(KEY_PREVIEW_SIZE);
+    if (p == 0)  return;
+    parse_pair(p, width, height, 'x');
+}
+
+void CameraParameters::getPreferredPreviewSizeForVideo(int *width, int *height) const
+{
+    *width = *height = -1;
+    const char *p = get(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO);
+    if (p == 0)  return;
+    parse_pair(p, width, height, 'x');
+}
+
+void CameraParameters::getSupportedPreviewSizes(vector<Size> &sizes) const
+{
+    const char *previewSizesStr = get(KEY_SUPPORTED_PREVIEW_SIZES);
+    parseSizesList(previewSizesStr, sizes);
+}
+
+void CameraParameters::setVideoSize(int width, int height)
+{
+    char str[32];
+    sprintf(str, "%dx%d", width, height);
+    set(KEY_VIDEO_SIZE, str);
+}
+
+void CameraParameters::getVideoSize(int *width, int *height) const
+{
+    *width = *height = -1;
+    const char *p = get(KEY_VIDEO_SIZE);
+    if (p == 0) return;
+    parse_pair(p, width, height, 'x');
+}
+
+void CameraParameters::getSupportedVideoSizes(vector<Size> &sizes) const
+{
+    const char *videoSizesStr = get(KEY_SUPPORTED_VIDEO_SIZES);
+    parseSizesList(videoSizesStr, sizes);
+}
+
+void CameraParameters::setPreviewFrameRate(int fps)
+{
+    set(KEY_PREVIEW_FRAME_RATE, fps);
+}
+
+int CameraParameters::getPreviewFrameRate() const
+{
+    return getInt(KEY_PREVIEW_FRAME_RATE);
+}
+
+void CameraParameters::getPreviewFpsRange(int *min_fps, int *max_fps) const
+{
+    *min_fps = *max_fps = -1;
+    const char *p = get(KEY_PREVIEW_FPS_RANGE);
+    if (p == 0) return;
+    parse_pair(p, min_fps, max_fps, ',');
+}
+
+void CameraParameters::setPreviewFormat(const char *format)
+{
+    set(KEY_PREVIEW_FORMAT, format);
+}
+
+const char *CameraParameters::getPreviewFormat() const
+{
+    return get(KEY_PREVIEW_FORMAT);
+}
+
+void CameraParameters::setPictureSize(int width, int height)
+{
+    char str[32];
+    sprintf(str, "%dx%d", width, height);
+    set(KEY_PICTURE_SIZE, str);
+}
+
+void CameraParameters::getPictureSize(int *width, int *height) const
+{
+    *width = *height = -1;
+    // Get the current string, if it doesn't exist, leave the -1x-1
+    const char *p = get(KEY_PICTURE_SIZE);
+    if (p == 0) return;
+    parse_pair(p, width, height, 'x');
+}
+
+void CameraParameters::getSupportedPictureSizes(vector<Size> &sizes) const
+{
+    const char *pictureSizesStr = get(KEY_SUPPORTED_PICTURE_SIZES);
+    parseSizesList(pictureSizesStr, sizes);
+}
+
+void CameraParameters::setPictureFormat(const char *format)
+{
+    set(KEY_PICTURE_FORMAT, format);
+}
+
+const char *CameraParameters::getPictureFormat() const
+{
+    return get(KEY_PICTURE_FORMAT);
+}
+
+void CameraParameters::dump() const
+{
+    ALOGD("dump: mMap.size = %d", mMap.size());
+    map<string, string>::const_iterator iter;
+    for (iter = mMap.begin(); iter != mMap.end(); iter ++) {
+        string k, v;
+        k = iter->first;
+        v = iter->second;
+        ALOGD("%s: %s\n", k.c_str(), v.c_str());
+    }
+}
+}; // namespace android
diff --git a/QCamera2/HAL/CameraParameters.h b/QCamera2/HAL/CameraParameters.h
new file mode 100644
index 0000000..e7f71c4
--- /dev/null
+++ b/QCamera2/HAL/CameraParameters.h
@@ -0,0 +1,693 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_CAMERA_PARAMETERS_H
+#define ANDROID_HARDWARE_CAMERA_PARAMETERS_H
+
+//#include <utils/KeyedVector.h>
+//#include <utils/string.h>
+#include <string>
+#include <map>
+#include <vector>
+using namespace std;
+
+namespace android {
+
+struct Size {
+    int width;
+    int height;
+
+    Size() {
+        width = 0;
+        height = 0;
+    }
+
+    Size(int w, int h) {
+        width = w;
+        height = h;
+    }
+};
+
+class CameraParameters
+{
+public:
+    CameraParameters();
+    CameraParameters(const string &params) { unflatten(params); }
+    ~CameraParameters();
+
+    string flatten() const;
+    void unflatten(const string &params);
+
+    void set(string& key, string& value);
+    void set(const char *key, const char *value);
+    void set(const char *key, int value);
+    void set(const char *key, string value);
+    void setFloat(const char *key, float value);
+    const char *get(const char *key) const;
+    int getInt(const char *key) const;
+    float getFloat(const char *key) const;
+
+    void remove(const char *key);
+
+    void setPreviewSize(int width, int height);
+    void getPreviewSize(int *width, int *height) const;
+    void getSupportedPreviewSizes(vector<Size> &sizes) const;
+
+    // Set the dimensions in pixels to the given width and height
+    // for video frames. The given width and height must be one
+    // of the supported dimensions returned from
+    // getSupportedVideoSizes(). Must not be called if
+    // getSupportedVideoSizes() returns an empty Vector of Size.
+    void setVideoSize(int width, int height);
+    // Retrieve the current dimensions (width and height)
+    // in pixels for video frames, which must be one of the
+    // supported dimensions returned from getSupportedVideoSizes().
+    // Must not be called if getSupportedVideoSizes() returns an
+    // empty Vector of Size.
+    void getVideoSize(int *width, int *height) const;
+    // Retrieve a Vector of supported dimensions (width and height)
+    // in pixels for video frames. If sizes returned from the method
+    // is empty, the camera does not support calls to setVideoSize()
+    // or getVideoSize(). In adddition, it also indicates that
+    // the camera only has a single output, and does not have
+    // separate output for video frames and preview frame.
+    void getSupportedVideoSizes(vector<Size> &sizes) const;
+    // Retrieve the preferred preview size (width and height) in pixels
+    // for video recording. The given width and height must be one of
+    // supported preview sizes returned from getSupportedPreviewSizes().
+    // Must not be called if getSupportedVideoSizes() returns an empty
+    // Vector of Size. If getSupportedVideoSizes() returns an empty
+    // Vector of Size, the width and height returned from this method
+    // is invalid, and is "-1x-1".
+    void getPreferredPreviewSizeForVideo(int *width, int *height) const;
+
+    void setPreviewFrameRate(int fps);
+    int getPreviewFrameRate() const;
+    void getPreviewFpsRange(int *min_fps, int *max_fps) const;
+    void setPreviewFormat(const char *format);
+    const char *getPreviewFormat() const;
+    void setPictureSize(int width, int height);
+    void getPictureSize(int *width, int *height) const;
+    void getSupportedPictureSizes(vector<Size> &sizes) const;
+    void setPictureFormat(const char *format);
+    const char *getPictureFormat() const;
+
+    void dump() const;
+    //status_t dump(int fd, const Vector<String16>& args) const;
+
+    // Parameter keys to communicate between camera application and driver.
+    // The access (read/write, read only, or write only) is viewed from the
+    // perspective of applications, not driver.
+
+    // Preview frame size in pixels (width x height).
+    // Example value: "480x320". Read/Write.
+    static const char KEY_PREVIEW_SIZE[];
+    // Supported preview frame sizes in pixels.
+    // Example value: "800x600,480x320". Read only.
+    static const char KEY_SUPPORTED_PREVIEW_SIZES[];
+    // The current minimum and maximum preview fps. This controls the rate of
+    // preview frames received (CAMERA_MSG_PREVIEW_FRAME). The minimum and
+    // maximum fps must be one of the elements from
+    // KEY_SUPPORTED_PREVIEW_FPS_RANGE parameter.
+    // Example value: "10500,26623"
+    static const char KEY_PREVIEW_FPS_RANGE[];
+    // The supported preview fps (frame-per-second) ranges. Each range contains
+    // a minimum fps and maximum fps. If minimum fps equals to maximum fps, the
+    // camera outputs frames in fixed frame rate. If not, the camera outputs
+    // frames in auto frame rate. The actual frame rate fluctuates between the
+    // minimum and the maximum. The list has at least one element. The list is
+    // sorted from small to large (first by maximum fps and then minimum fps).
+    // Example value: "(10500,26623),(15000,26623),(30000,30000)"
+    static const char KEY_SUPPORTED_PREVIEW_FPS_RANGE[];
+    // The image format for preview frames. See CAMERA_MSG_PREVIEW_FRAME in
+    // frameworks/av/include/camera/Camera.h. The default is
+    // PIXEL_FORMAT_YUV420SP. Example value: "yuv420sp" or PIXEL_FORMAT_XXX
+    // constants. Read/write.
+    static const char KEY_PREVIEW_FORMAT[];
+    // Supported image formats for preview frames.
+    // Example value: "yuv420sp,yuv422i-yuyv". Read only.
+    static const char KEY_SUPPORTED_PREVIEW_FORMATS[];
+    // Number of preview frames per second. This is the target frame rate. The
+    // actual frame rate depends on the driver.
+    // Example value: "15". Read/write.
+    static const char KEY_PREVIEW_FRAME_RATE[];
+    // Supported number of preview frames per second.
+    // Example value: "24,15,10". Read.
+    static const char KEY_SUPPORTED_PREVIEW_FRAME_RATES[];
+    // The dimensions for captured pictures in pixels (width x height).
+    // Example value: "1024x768". Read/write.
+    static const char KEY_PICTURE_SIZE[];
+    // Supported dimensions for captured pictures in pixels.
+    // Example value: "2048x1536,1024x768". Read only.
+    static const char KEY_SUPPORTED_PICTURE_SIZES[];
+    // The image format for captured pictures. See CAMERA_MSG_COMPRESSED_IMAGE
+    // in frameworks/base/include/camera/Camera.h.
+    // Example value: "jpeg" or PIXEL_FORMAT_XXX constants. Read/write.
+    static const char KEY_PICTURE_FORMAT[];
+    // Supported image formats for captured pictures.
+    // Example value: "jpeg,rgb565". Read only.
+    static const char KEY_SUPPORTED_PICTURE_FORMATS[];
+    // The width (in pixels) of EXIF thumbnail in Jpeg picture.
+    // Example value: "512". Read/write.
+    static const char KEY_JPEG_THUMBNAIL_WIDTH[];
+    // The height (in pixels) of EXIF thumbnail in Jpeg picture.
+    // Example value: "384". Read/write.
+    static const char KEY_JPEG_THUMBNAIL_HEIGHT[];
+    // Supported EXIF thumbnail sizes (width x height). 0x0 means not thumbnail
+    // in EXIF.
+    // Example value: "512x384,320x240,0x0". Read only.
+    static const char KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES[];
+    // The quality of the EXIF thumbnail in Jpeg picture. The range is 1 to 100,
+    // with 100 being the best.
+    // Example value: "90". Read/write.
+    static const char KEY_JPEG_THUMBNAIL_QUALITY[];
+    // Jpeg quality of captured picture. The range is 1 to 100, with 100 being
+    // the best.
+    // Example value: "90". Read/write.
+    static const char KEY_JPEG_QUALITY[];
+    // The rotation angle in degrees relative to the orientation of the camera.
+    // This affects the pictures returned from CAMERA_MSG_COMPRESSED_IMAGE. The
+    // camera driver may set orientation in the EXIF header without rotating the
+    // picture. Or the driver may rotate the picture and the EXIF thumbnail. If
+    // the Jpeg picture is rotated, the orientation in the EXIF header will be
+    // missing or 1 (row #0 is top and column #0 is left side).
+    //
+    // Note that the JPEG pictures of front-facing cameras are not mirrored
+    // as in preview display.
+    //
+    // For example, suppose the natural orientation of the device is portrait.
+    // The device is rotated 270 degrees clockwise, so the device orientation is
+    // 270. Suppose a back-facing camera sensor is mounted in landscape and the
+    // top side of the camera sensor is aligned with the right edge of the
+    // display in natural orientation. So the camera orientation is 90. The
+    // rotation should be set to 0 (270 + 90).
+    //
+    // Example value: "0" or "90" or "180" or "270". Write only.
+    static const char KEY_ROTATION[];
+    // GPS latitude coordinate. GPSLatitude and GPSLatitudeRef will be stored in
+    // JPEG EXIF header.
+    // Example value: "25.032146" or "-33.462809". Write only.
+    static const char KEY_GPS_LATITUDE[];
+    // GPS longitude coordinate. GPSLongitude and GPSLongitudeRef will be stored
+    // in JPEG EXIF header.
+    // Example value: "121.564448" or "-70.660286". Write only.
+    static const char KEY_GPS_LONGITUDE[];
+    // GPS altitude. GPSAltitude and GPSAltitudeRef will be stored in JPEG EXIF
+    // header.
+    // Example value: "21.0" or "-5". Write only.
+    static const char KEY_GPS_ALTITUDE[];
+    // GPS timestamp (UTC in seconds since January 1, 1970). This should be
+    // stored in JPEG EXIF header.
+    // Example value: "1251192757". Write only.
+    static const char KEY_GPS_TIMESTAMP[];
+    // GPS Processing Method
+    // Example value: "GPS" or "NETWORK". Write only.
+    static const char KEY_GPS_PROCESSING_METHOD[];
+    // Current white balance setting.
+    // Example value: "auto" or WHITE_BALANCE_XXX constants. Read/write.
+    static const char KEY_WHITE_BALANCE[];
+    // Supported white balance settings.
+    // Example value: "auto,incandescent,daylight". Read only.
+    static const char KEY_SUPPORTED_WHITE_BALANCE[];
+    // Current color effect setting.
+    // Example value: "none" or EFFECT_XXX constants. Read/write.
+    static const char KEY_EFFECT[];
+    // Supported color effect settings.
+    // Example value: "none,mono,sepia". Read only.
+    static const char KEY_SUPPORTED_EFFECTS[];
+    // Current antibanding setting.
+    // Example value: "auto" or ANTIBANDING_XXX constants. Read/write.
+    static const char KEY_ANTIBANDING[];
+    // Supported antibanding settings.
+    // Example value: "auto,50hz,60hz,off". Read only.
+    static const char KEY_SUPPORTED_ANTIBANDING[];
+    // Current scene mode.
+    // Example value: "auto" or SCENE_MODE_XXX constants. Read/write.
+    static const char KEY_SCENE_MODE[];
+    // Supported scene mode settings.
+    // Example value: "auto,night,fireworks". Read only.
+    static const char KEY_SUPPORTED_SCENE_MODES[];
+    // Current flash mode.
+    // Example value: "auto" or FLASH_MODE_XXX constants. Read/write.
+    static const char KEY_FLASH_MODE[];
+    // Supported flash modes.
+    // Example value: "auto,on,off". Read only.
+    static const char KEY_SUPPORTED_FLASH_MODES[];
+    // Current focus mode. This will not be empty. Applications should call
+    // CameraHardwareInterface.autoFocus to start the focus if focus mode is
+    // FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
+    // Example value: "auto" or FOCUS_MODE_XXX constants. Read/write.
+    static const char KEY_FOCUS_MODE[];
+    // Supported focus modes.
+    // Example value: "auto,macro,fixed". Read only.
+    static const char KEY_SUPPORTED_FOCUS_MODES[];
+    // The maximum number of focus areas supported. This is the maximum length
+    // of KEY_FOCUS_AREAS.
+    // Example value: "0" or "2". Read only.
+    static const char KEY_MAX_NUM_FOCUS_AREAS[];
+    // Current focus areas.
+    //
+    // Before accessing this parameter, apps should check
+    // KEY_MAX_NUM_FOCUS_AREAS first to know the maximum number of focus areas
+    // first. If the value is 0, focus area is not supported.
+    //
+    // Each focus area is a five-element int array. The first four elements are
+    // the rectangle of the area (left, top, right, bottom). The direction is
+    // relative to the sensor orientation, that is, what the sensor sees. The
+    // direction is not affected by the rotation or mirroring of
+    // CAMERA_CMD_SET_DISPLAY_ORIENTATION. Coordinates range from -1000 to 1000.
+    // (-1000,-1000) is the upper left point. (1000, 1000) is the lower right
+    // point. The width and height of focus areas cannot be 0 or negative.
+    //
+    // The fifth element is the weight. Values for weight must range from 1 to
+    // 1000.  The weight should be interpreted as a per-pixel weight - all
+    // pixels in the area have the specified weight. This means a small area
+    // with the same weight as a larger area will have less influence on the
+    // focusing than the larger area. Focus areas can partially overlap and the
+    // driver will add the weights in the overlap region.
+    //
+    // A special case of single focus area (0,0,0,0,0) means driver to decide
+    // the focus area. For example, the driver may use more signals to decide
+    // focus areas and change them dynamically. Apps can set (0,0,0,0,0) if they
+    // want the driver to decide focus areas.
+    //
+    // Focus areas are relative to the current field of view (KEY_ZOOM). No
+    // matter what the zoom level is, (-1000,-1000) represents the top of the
+    // currently visible camera frame. The focus area cannot be set to be
+    // outside the current field of view, even when using zoom.
+    //
+    // Focus area only has effect if the current focus mode is FOCUS_MODE_AUTO,
+    // FOCUS_MODE_MACRO, FOCUS_MODE_CONTINUOUS_VIDEO, or
+    // FOCUS_MODE_CONTINUOUS_PICTURE.
+    // Example value: "(-10,-10,0,0,300),(0,0,10,10,700)". Read/write.
+    static const char KEY_FOCUS_AREAS[];
+    // Focal length in millimeter.
+    // Example value: "4.31". Read only.
+    static const char KEY_FOCAL_LENGTH[];
+    // Horizontal angle of view in degrees.
+    // Example value: "54.8". Read only.
+    static const char KEY_HORIZONTAL_VIEW_ANGLE[];
+    // Vertical angle of view in degrees.
+    // Example value: "42.5". Read only.
+    static const char KEY_VERTICAL_VIEW_ANGLE[];
+    // Exposure compensation index. 0 means exposure is not adjusted.
+    // Example value: "-5" or "5". Read/write.
+    static const char KEY_EXPOSURE_COMPENSATION[];
+    // The maximum exposure compensation index (>=0).
+    // Example value: "6". Read only.
+    static const char KEY_MAX_EXPOSURE_COMPENSATION[];
+    // The minimum exposure compensation index (<=0).
+    // Example value: "-6". Read only.
+    static const char KEY_MIN_EXPOSURE_COMPENSATION[];
+    // The exposure compensation step. Exposure compensation index multiply by
+    // step eqals to EV. Ex: if exposure compensation index is -6 and step is
+    // 0.3333, EV is -2.
+    // Example value: "0.333333333" or "0.5". Read only.
+    static const char KEY_EXPOSURE_COMPENSATION_STEP[];
+    // The state of the auto-exposure lock. "true" means that
+    // auto-exposure is locked to its current value and will not
+    // change. "false" means the auto-exposure routine is free to
+    // change exposure values. If auto-exposure is already locked,
+    // setting this to true again has no effect (the driver will not
+    // recalculate exposure values). Changing exposure compensation
+    // settings will still affect the exposure settings while
+    // auto-exposure is locked. Stopping preview or taking a still
+    // image will not change the lock. In conjunction with
+    // exposure compensation, this allows for capturing multi-exposure
+    // brackets with known relative exposure values. Locking
+    // auto-exposure after open but before the first call to
+    // startPreview may result in severely over- or under-exposed
+    // images.  The driver will not change the AE lock after
+    // auto-focus completes.
+    static const char KEY_AUTO_EXPOSURE_LOCK[];
+    // Whether locking the auto-exposure is supported. "true" means it is, and
+    // "false" or this key not existing means it is not supported.
+    static const char KEY_AUTO_EXPOSURE_LOCK_SUPPORTED[];
+    // The state of the auto-white balance lock. "true" means that
+    // auto-white balance is locked to its current value and will not
+    // change. "false" means the auto-white balance routine is free to
+    // change white balance values. If auto-white balance is already
+    // locked, setting this to true again has no effect (the driver
+    // will not recalculate white balance values). Stopping preview or
+    // taking a still image will not change the lock. In conjunction
+    // with exposure compensation, this allows for capturing
+    // multi-exposure brackets with fixed white balance. Locking
+    // auto-white balance after open but before the first call to
+    // startPreview may result in severely incorrect color.  The
+    // driver will not change the AWB lock after auto-focus
+    // completes.
+    static const char KEY_AUTO_WHITEBALANCE_LOCK[];
+    // Whether locking the auto-white balance is supported. "true"
+    // means it is, and "false" or this key not existing means it is
+    // not supported.
+    static const char KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED[];
+
+    // The maximum number of metering areas supported. This is the maximum
+    // length of KEY_METERING_AREAS.
+    // Example value: "0" or "2". Read only.
+    static const char KEY_MAX_NUM_METERING_AREAS[];
+    // Current metering areas. Camera driver uses these areas to decide
+    // exposure.
+    //
+    // Before accessing this parameter, apps should check
+    // KEY_MAX_NUM_METERING_AREAS first to know the maximum number of metering
+    // areas first. If the value is 0, metering area is not supported.
+    //
+    // Each metering area is a rectangle with specified weight. The direction is
+    // relative to the sensor orientation, that is, what the sensor sees. The
+    // direction is not affected by the rotation or mirroring of
+    // CAMERA_CMD_SET_DISPLAY_ORIENTATION. Coordinates of the rectangle range
+    // from -1000 to 1000. (-1000, -1000) is the upper left point. (1000, 1000)
+    // is the lower right point. The width and height of metering areas cannot
+    // be 0 or negative.
+    //
+    // The fifth element is the weight. Values for weight must range from 1 to
+    // 1000.  The weight should be interpreted as a per-pixel weight - all
+    // pixels in the area have the specified weight. This means a small area
+    // with the same weight as a larger area will have less influence on the
+    // metering than the larger area. Metering areas can partially overlap and
+    // the driver will add the weights in the overlap region.
+    //
+    // A special case of all-zero single metering area means driver to decide
+    // the metering area. For example, the driver may use more signals to decide
+    // metering areas and change them dynamically. Apps can set all-zero if they
+    // want the driver to decide metering areas.
+    //
+    // Metering areas are relative to the current field of view (KEY_ZOOM).
+    // No matter what the zoom level is, (-1000,-1000) represents the top of the
+    // currently visible camera frame. The metering area cannot be set to be
+    // outside the current field of view, even when using zoom.
+    //
+    // No matter what metering areas are, the final exposure are compensated
+    // by KEY_EXPOSURE_COMPENSATION.
+    // Example value: "(-10,-10,0,0,300),(0,0,10,10,700)". Read/write.
+    static const char KEY_METERING_AREAS[];
+    // Current zoom value.
+    // Example value: "0" or "6". Read/write.
+    static const char KEY_ZOOM[];
+    // Maximum zoom value.
+    // Example value: "6". Read only.
+    static const char KEY_MAX_ZOOM[];
+    // The zoom ratios of all zoom values. The zoom ratio is in 1/100
+    // increments. Ex: a zoom of 3.2x is returned as 320. The number of list
+    // elements is KEY_MAX_ZOOM + 1. The first element is always 100. The last
+    // element is the zoom ratio of zoom value KEY_MAX_ZOOM.
+    // Example value: "100,150,200,250,300,350,400". Read only.
+    static const char KEY_ZOOM_RATIOS[];
+    // Whether zoom is supported. Zoom is supported if the value is "true". Zoom
+    // is not supported if the value is not "true" or the key does not exist.
+    // Example value: "true". Read only.
+    static const char KEY_ZOOM_SUPPORTED[];
+    // Whether if smooth zoom is supported. Smooth zoom is supported if the
+    // value is "true". It is not supported if the value is not "true" or the
+    // key does not exist.
+    // See CAMERA_CMD_START_SMOOTH_ZOOM, CAMERA_CMD_STOP_SMOOTH_ZOOM, and
+    // CAMERA_MSG_ZOOM in frameworks/base/include/camera/Camera.h.
+    // Example value: "true". Read only.
+    static const char KEY_SMOOTH_ZOOM_SUPPORTED[];
+
+    // The distances (in meters) from the camera to where an object appears to
+    // be in focus. The object is sharpest at the optimal focus distance. The
+    // depth of field is the far focus distance minus near focus distance.
+    //
+    // Focus distances may change after starting auto focus, canceling auto
+    // focus, or starting the preview. Applications can read this anytime to get
+    // the latest focus distances. If the focus mode is FOCUS_MODE_CONTINUOUS,
+    // focus distances may change from time to time.
+    //
+    // This is intended to estimate the distance between the camera and the
+    // subject. After autofocus, the subject distance may be within near and far
+    // focus distance. However, the precision depends on the camera hardware,
+    // autofocus algorithm, the focus area, and the scene. The error can be
+    // large and it should be only used as a reference.
+    //
+    // Far focus distance > optimal focus distance > near focus distance. If
+    // the far focus distance is infinity, the value should be "Infinity" (case
+    // sensitive). The format is three float values separated by commas. The
+    // first is near focus distance. The second is optimal focus distance. The
+    // third is far focus distance.
+    // Example value: "0.95,1.9,Infinity" or "0.049,0.05,0.051". Read only.
+    static const char KEY_FOCUS_DISTANCES[];
+
+    // The current dimensions in pixels (width x height) for video frames.
+    // The width and height must be one of the supported sizes retrieved
+    // via KEY_SUPPORTED_VIDEO_SIZES.
+    // Example value: "1280x720". Read/write.
+    static const char KEY_VIDEO_SIZE[];
+    // A list of the supported dimensions in pixels (width x height)
+    // for video frames. See CAMERA_MSG_VIDEO_FRAME for details in
+    // frameworks/base/include/camera/Camera.h.
+    // Example: "176x144,1280x720". Read only.
+    static const char KEY_SUPPORTED_VIDEO_SIZES[];
+
+    // The maximum number of detected faces supported by hardware face
+    // detection. If the value is 0, hardware face detection is not supported.
+    // Example: "5". Read only
+    static const char KEY_MAX_NUM_DETECTED_FACES_HW[];
+
+    // The maximum number of detected faces supported by software face
+    // detection. If the value is 0, software face detection is not supported.
+    // Example: "5". Read only
+    static const char KEY_MAX_NUM_DETECTED_FACES_SW[];
+
+    // Preferred preview frame size in pixels for video recording.
+    // The width and height must be one of the supported sizes retrieved
+    // via KEY_SUPPORTED_PREVIEW_SIZES. This key can be used only when
+    // getSupportedVideoSizes() does not return an empty Vector of Size.
+    // Camcorder applications are recommended to set the preview size
+    // to a value that is not larger than the preferred preview size.
+    // In other words, the product of the width and height of the
+    // preview size should not be larger than that of the preferred
+    // preview size. In addition, we recommend to choos a preview size
+    // that has the same aspect ratio as the resolution of video to be
+    // recorded.
+    // Example value: "800x600". Read only.
+    static const char KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO[];
+
+    // The image format for video frames. See CAMERA_MSG_VIDEO_FRAME in
+    // frameworks/base/include/camera/Camera.h.
+    // Example value: "yuv420sp" or PIXEL_FORMAT_XXX constants. Read only.
+    static const char KEY_VIDEO_FRAME_FORMAT[];
+
+    // Sets the hint of the recording mode. If this is true, MediaRecorder.start
+    // may be faster or has less glitches. This should be called before starting
+    // the preview for the best result. But it is allowed to change the hint
+    // while the preview is active. The default value is false.
+    //
+    // The apps can still call Camera.takePicture when the hint is true. The
+    // apps can call MediaRecorder.start when the hint is false. But the
+    // performance may be worse.
+    // Example value: "true" or "false". Read/write.
+    static const char KEY_RECORDING_HINT[];
+
+    // Returns true if video snapshot is supported. That is, applications
+    // can call Camera.takePicture during recording. Applications do not need to
+    // call Camera.startPreview after taking a picture. The preview will be
+    // still active. Other than that, taking a picture during recording is
+    // identical to taking a picture normally. All settings and methods related
+    // to takePicture work identically. Ex: KEY_PICTURE_SIZE,
+    // KEY_SUPPORTED_PICTURE_SIZES, KEY_JPEG_QUALITY, KEY_ROTATION, and etc.
+    // The picture will have an EXIF header. FLASH_MODE_AUTO and FLASH_MODE_ON
+    // also still work, but the video will record the flash.
+    //
+    // Applications can set shutter callback as null to avoid the shutter
+    // sound. It is also recommended to set raw picture and post view callbacks
+    // to null to avoid the interrupt of preview display.
+    //
+    // Field-of-view of the recorded video may be different from that of the
+    // captured pictures.
+    // Example value: "true" or "false". Read only.
+    static const char KEY_VIDEO_SNAPSHOT_SUPPORTED[];
+
+    // The state of the video stabilization. If set to true, both the
+    // preview stream and the recorded video stream are stabilized by
+    // the camera. Only valid to set if KEY_VIDEO_STABILIZATION_SUPPORTED is
+    // set to true.
+    //
+    // The value of this key can be changed any time the camera is
+    // open. If preview or recording is active, it is acceptable for
+    // there to be a slight video glitch when video stabilization is
+    // toggled on and off.
+    //
+    // This only stabilizes video streams (between-frames stabilization), and
+    // has no effect on still image capture.
+    static const char KEY_VIDEO_STABILIZATION[];
+
+    // Returns true if video stabilization is supported. That is, applications
+    // can set KEY_VIDEO_STABILIZATION to true and have a stabilized preview
+    // stream and record stabilized videos.
+    static const char KEY_VIDEO_STABILIZATION_SUPPORTED[];
+
+    // Supported modes for special effects with light.
+    // Example values: "lowlight,hdr".
+    static const char KEY_LIGHTFX[];
+
+    // Value for KEY_ZOOM_SUPPORTED or KEY_SMOOTH_ZOOM_SUPPORTED.
+    static const char TRUE[];
+    static const char FALSE[];
+
+    // Value for KEY_FOCUS_DISTANCES.
+    static const char FOCUS_DISTANCE_INFINITY[];
+
+    // Values for white balance settings.
+    static const char WHITE_BALANCE_AUTO[];
+    static const char WHITE_BALANCE_INCANDESCENT[];
+    static const char WHITE_BALANCE_FLUORESCENT[];
+    static const char WHITE_BALANCE_WARM_FLUORESCENT[];
+    static const char WHITE_BALANCE_DAYLIGHT[];
+    static const char WHITE_BALANCE_CLOUDY_DAYLIGHT[];
+    static const char WHITE_BALANCE_TWILIGHT[];
+    static const char WHITE_BALANCE_SHADE[];
+    static const char WHITE_BALANCE_MANUAL_CCT[];
+
+    // Values for effect settings.
+    static const char EFFECT_NONE[];
+    static const char EFFECT_MONO[];
+    static const char EFFECT_NEGATIVE[];
+    static const char EFFECT_SOLARIZE[];
+    static const char EFFECT_SEPIA[];
+    static const char EFFECT_POSTERIZE[];
+    static const char EFFECT_WHITEBOARD[];
+    static const char EFFECT_BLACKBOARD[];
+    static const char EFFECT_AQUA[];
+
+    // Values for antibanding settings.
+    static const char ANTIBANDING_AUTO[];
+    static const char ANTIBANDING_50HZ[];
+    static const char ANTIBANDING_60HZ[];
+    static const char ANTIBANDING_OFF[];
+
+    // Values for flash mode settings.
+    // Flash will not be fired.
+    static const char FLASH_MODE_OFF[];
+    // Flash will be fired automatically when required. The flash may be fired
+    // during preview, auto-focus, or snapshot depending on the driver.
+    static const char FLASH_MODE_AUTO[];
+    // Flash will always be fired during snapshot. The flash may also be
+    // fired during preview or auto-focus depending on the driver.
+    static const char FLASH_MODE_ON[];
+    // Flash will be fired in red-eye reduction mode.
+    static const char FLASH_MODE_RED_EYE[];
+    // Constant emission of light during preview, auto-focus and snapshot.
+    // This can also be used for video recording.
+    static const char FLASH_MODE_TORCH[];
+
+    // Values for scene mode settings.
+    static const char SCENE_MODE_AUTO[];
+    static const char SCENE_MODE_ACTION[];
+    static const char SCENE_MODE_PORTRAIT[];
+    static const char SCENE_MODE_LANDSCAPE[];
+    static const char SCENE_MODE_NIGHT[];
+    static const char SCENE_MODE_NIGHT_PORTRAIT[];
+    static const char SCENE_MODE_THEATRE[];
+    static const char SCENE_MODE_BEACH[];
+    static const char SCENE_MODE_SNOW[];
+    static const char SCENE_MODE_SUNSET[];
+    static const char SCENE_MODE_STEADYPHOTO[];
+    static const char SCENE_MODE_FIREWORKS[];
+    static const char SCENE_MODE_SPORTS[];
+    static const char SCENE_MODE_PARTY[];
+    static const char SCENE_MODE_CANDLELIGHT[];
+    // Applications are looking for a barcode. Camera driver will be optimized
+    // for barcode reading.
+    static const char SCENE_MODE_BARCODE[];
+    // A high-dynamic range mode. In this mode, the HAL module will use a
+    // capture strategy that extends the dynamic range of the captured
+    // image in some fashion. Only the final image is returned.
+    static const char SCENE_MODE_HDR[];
+
+    // Pixel color formats for KEY_PREVIEW_FORMAT, KEY_PICTURE_FORMAT,
+    // and KEY_VIDEO_FRAME_FORMAT
+    static const char PIXEL_FORMAT_YUV422SP[];
+    static const char PIXEL_FORMAT_YUV420SP[]; // NV21
+    static const char PIXEL_FORMAT_YUV422I[]; // YUY2
+    static const char PIXEL_FORMAT_YUV420P[]; // YV12
+    static const char PIXEL_FORMAT_RGB565[];
+    static const char PIXEL_FORMAT_RGBA8888[];
+    static const char PIXEL_FORMAT_JPEG[];
+    // Raw bayer format used for images, which is 10 bit precision samples
+    // stored in 16 bit words. The filter pattern is RGGB.
+    static const char PIXEL_FORMAT_BAYER_RGGB[];
+    // Pixel format is not known to the framework
+    static const char PIXEL_FORMAT_ANDROID_OPAQUE[];
+
+    // Values for focus mode settings.
+    // Auto-focus mode. Applications should call
+    // CameraHardwareInterface.autoFocus to start the focus in this mode.
+    static const char FOCUS_MODE_AUTO[];
+    // Focus is set at infinity. Applications should not call
+    // CameraHardwareInterface.autoFocus in this mode.
+    static const char FOCUS_MODE_INFINITY[];
+    // Macro (close-up) focus mode. Applications should call
+    // CameraHardwareInterface.autoFocus to start the focus in this mode.
+    static const char FOCUS_MODE_MACRO[];
+    // Focus is fixed. The camera is always in this mode if the focus is not
+    // adjustable. If the camera has auto-focus, this mode can fix the
+    // focus, which is usually at hyperfocal distance. Applications should
+    // not call CameraHardwareInterface.autoFocus in this mode.
+    static const char FOCUS_MODE_FIXED[];
+    // Extended depth of field (EDOF). Focusing is done digitally and
+    // continuously. Applications should not call
+    // CameraHardwareInterface.autoFocus in this mode.
+    static const char FOCUS_MODE_EDOF[];
+    // Continuous auto focus mode intended for video recording. The camera
+    // continuously tries to focus. This is the best choice for video
+    // recording because the focus changes smoothly . Applications still can
+    // call CameraHardwareInterface.takePicture in this mode but the subject may
+    // not be in focus. Auto focus starts when the parameter is set.
+    //
+    // Applications can call CameraHardwareInterface.autoFocus in this mode. The
+    // focus callback will immediately return with a boolean that indicates
+    // whether the focus is sharp or not. The focus position is locked after
+    // autoFocus call. If applications want to resume the continuous focus,
+    // cancelAutoFocus must be called. Restarting the preview will not resume
+    // the continuous autofocus. To stop continuous focus, applications should
+    // change the focus mode to other modes.
+    static const char FOCUS_MODE_CONTINUOUS_VIDEO[];
+    // Continuous auto focus mode intended for taking pictures. The camera
+    // continuously tries to focus. The speed of focus change is more aggressive
+    // than FOCUS_MODE_CONTINUOUS_VIDEO. Auto focus starts when the parameter is
+    // set.
+    //
+    // Applications can call CameraHardwareInterface.autoFocus in this mode. If
+    // the autofocus is in the middle of scanning, the focus callback will
+    // return when it completes. If the autofocus is not scanning, focus
+    // callback will immediately return with a boolean that indicates whether
+    // the focus is sharp or not. The apps can then decide if they want to take
+    // a picture immediately or to change the focus mode to auto, and run a full
+    // autofocus cycle. The focus position is locked after autoFocus call. If
+    // applications want to resume the continuous focus, cancelAutoFocus must be
+    // called. Restarting the preview will not resume the continuous autofocus.
+    // To stop continuous focus, applications should change the focus mode to
+    // other modes.
+    static const char FOCUS_MODE_CONTINUOUS_PICTURE[];
+
+    static const char FOCUS_MODE_MANUAL_POSITION[];
+
+    // Values for light special effects
+    // Low-light enhancement mode
+    static const char LIGHTFX_LOWLIGHT[];
+    // High-dynamic range mode
+    static const char LIGHTFX_HDR[];
+
+private:
+    //DefaultKeyedVector<string,string>    mMap;
+    map<string, string> mMap;
+};
+
+}; // namespace android
+
+#endif
diff --git a/QCamera2/HAL/Makefile.am b/QCamera2/HAL/Makefile.am
new file mode 100644
index 0000000..257c825
--- /dev/null
+++ b/QCamera2/HAL/Makefile.am
@@ -0,0 +1,35 @@
+ACLOCAL_AMFLAGS = -I m4
+
+# build camera-hal Library
+lib_LTLIBRARIES = libqcamera2.la
+
+libqcamera2_la_CXXFLAGS  = -fPIC
+libqcamera2_la_CXXFLAGS += -g
+
+libqcamera2_la_CXXFLAGS += -I ../stack/common
+libqcamera2_la_CXXFLAGS += -I ../stack/mm-camera-interface/inc
+libqcamera2_la_CXXFLAGS += -I ../../mm-image-codec/qexif
+libqcamera2_la_CXXFLAGS += -I ../../mm-image-codec/qomx_core
+libqcamera2_la_CXXFLAGS += -I ../util
+libqcamera2_la_CXXFLAGS += -I ../..
+
+libqcamera2_la_SOURCES  = QCamera2Factory.cpp
+libqcamera2_la_SOURCES += CameraParameters.cpp
+libqcamera2_la_SOURCES += QCamera2Hal.cpp
+libqcamera2_la_SOURCES += QCamera2HWI.cpp
+libqcamera2_la_SOURCES += QCameraMem.cpp
+libqcamera2_la_SOURCES += ../util/QCameraQueue.cpp
+libqcamera2_la_SOURCES += ../util/QCameraCmdThread.cpp
+libqcamera2_la_SOURCES += QCameraStateMachine.cpp
+libqcamera2_la_SOURCES += QCameraChannel.cpp
+libqcamera2_la_SOURCES += QCameraStream.cpp
+libqcamera2_la_SOURCES += QCameraPostProc.cpp
+libqcamera2_la_SOURCES += QCamera2HWICallbacks.cpp
+libqcamera2_la_SOURCES += QCameraParameters.cpp
+libqcamera2_la_SOURCES += QCameraThermalAdapter.cpp
+
+libqcamera2_la_LDFLAGS = -shared
+
+libqcamera2_la_LIBADD  = -ldl -lpthread -lglib-2.0 -lcutils
+libqcamera2_la_LIBADD += ../stack/mm-camera-interface/libmmcamera_interface.la
+libqcamera2_la_LIBADD += ../stack/mm-jpeg-interface/libmmjpeg_interface.la
diff --git a/QCamera2/HAL/QCamera2HWI.cpp b/QCamera2/HAL/QCamera2HWI.cpp
index 67d56aa..c4baf3d 100644
--- a/QCamera2/HAL/QCamera2HWI.cpp
+++ b/QCamera2/HAL/QCamera2HWI.cpp
@@ -29,12 +29,18 @@
 
 #define LOG_TAG "QCamera2HWI"
 
-#include <cutils/properties.h>
 #include <hardware/camera.h>
 #include <stdlib.h>
+#ifdef _ANDROID_
+#include <cutils/properties.h>
 #include <utils/Errors.h>
-#include <gralloc_priv.h>
 #include <gui/Surface.h>
+#include <gralloc_priv.h>
+#else
+#include "android_adapter.h"
+#endif
+#include <cassert>
+#include <sstream>
 
 #include "QCamera2HWI.h"
 #include "QCameraMem.h"
@@ -1003,6 +1009,8 @@ QCamera2HardwareInterface::QCamera2HardwareInterface(int cameraId)
     mCameraDevice.ops = &mCameraOps;
     mCameraDevice.priv = this;
 
+    pthread_mutex_init(&mDeffLock, NULL);
+    pthread_cond_init(&mDeffCond, NULL);
     pthread_mutex_init(&m_lock, NULL);
     pthread_cond_init(&m_cond, NULL);
      m_apiResultList = NULL;
@@ -1015,11 +1023,13 @@ QCamera2HardwareInterface::QCamera2HardwareInterface(int cameraId)
 
     memset(m_channels, 0, sizeof(m_channels));
 
+#ifdef _ANDROID_
 #ifdef HAS_MULTIMEDIA_HINTS
     if (hw_get_module(POWER_HARDWARE_MODULE_ID, (const hw_module_t **)&m_pPowerModule)) {
         ALOGE("%s: %s module not found", __func__, POWER_HARDWARE_MODULE_ID);
     }
 #endif
+#endif
 
     memset(mDeffOngoingJobs, 0, sizeof(mDeffOngoingJobs));
 
@@ -1042,6 +1052,8 @@ QCamera2HardwareInterface::~QCamera2HardwareInterface()
     mDefferedWorkThread.exit();
 
     closeCamera();
+    pthread_mutex_destroy(&mDeffLock);
+    pthread_cond_destroy(&mDeffCond);
     pthread_mutex_destroy(&m_lock);
     pthread_cond_destroy(&m_cond);
     pthread_mutex_destroy(&m_evtLock);
@@ -1139,8 +1151,12 @@ int QCamera2HardwareInterface::openCamera()
     gCamCapability[mCameraId]->video_sizes_tbl_cnt = savedSizes[mCameraId].all_video_sizes_cnt;
 
     //check if video size 4k x 2k support is enabled
+#ifdef _ANDROID_
     property_get("persist.camera.4k2k.enable", value, "0");
     enable_4k2k = atoi(value) > 0 ? 1 : 0;
+#else
+    enable_4k2k = 1;
+#endif
     ALOGD("%s: enable_4k2k is %d", __func__, enable_4k2k);
     if (!enable_4k2k) {
        //if the 4kx2k size exists in the supported preview size or
@@ -1460,9 +1476,12 @@ uint8_t QCamera2HardwareInterface::getBufNumRequired(cam_stream_type_t stream_ty
                 ALOGE("get_min_undequeued_buffer_count  failed");
             }
         } else {
+#ifdef _ANDROID_
             //preview window might not be set at this point. So, query directly
             //from BufferQueue implementation of gralloc buffers.
+
             minUndequeCount = BufferQueue::MIN_UNDEQUEUED_BUFFERS;
+#endif
         }
     }
 
@@ -1621,6 +1640,7 @@ QCameraMemory *QCamera2HardwareInterface::allocateStreamBuf(cam_stream_type_t st
                                               &m_memoryPool,
                                               stream_type);
             } else {
+#ifdef _ANDROID_
                 cam_dimension_t dim;
                 QCameraGrallocMemory *grallocMemory =
                     new QCameraGrallocMemory(mGetMemory);
@@ -1631,6 +1651,10 @@ QCameraMemory *QCamera2HardwareInterface::allocateStreamBuf(cam_stream_type_t st
                         dim.height, stride, scanline,
                         mParameters.getPreviewHalPixelFormat());
                 mem = grallocMemory;
+#else
+                ALOGE("%s:%d, display mode not supported", __func__, __LINE__);
+                assert(0);
+#endif
             }
         }
         break;
@@ -1639,6 +1663,7 @@ QCameraMemory *QCamera2HardwareInterface::allocateStreamBuf(cam_stream_type_t st
             if (isPreviewRestartEnabled() || isNoDisplayMode()) {
                 mem = new QCameraStreamMemory(mGetMemory, bCachedMem);
             } else {
+#ifdef _ANDROID_
                 cam_dimension_t dim;
                 QCameraGrallocMemory *grallocMemory =
                     new QCameraGrallocMemory(mGetMemory);
@@ -1653,6 +1678,10 @@ QCameraMemory *QCamera2HardwareInterface::allocateStreamBuf(cam_stream_type_t st
                         mParameters.getPreviewHalPixelFormat());
                 }
                 mem = grallocMemory;
+#else
+                ALOGE("%s:%d, display mode not supported", __func__, __LINE__);
+                assert(0);
+#endif
             }
         }
         break;
@@ -1668,8 +1697,13 @@ QCameraMemory *QCamera2HardwareInterface::allocateStreamBuf(cam_stream_type_t st
     case CAM_STREAM_TYPE_VIDEO:
         {
             char value[PROPERTY_VALUE_MAX];
+#ifdef _ANDROID_
             property_get("persist.camera.mem.usecache", value, "1");
-            if (atoi(value) == 0) {
+            int use_cache = atoi(value);
+#else
+            int use_cache = 1;
+#endif
+            if (use_cache == 0) {
                 bCachedMem = QCAMERA_ION_USE_NOCACHE;
             }
             ALOGD("%s: vidoe buf using cached memory = %d", __func__, bCachedMem);
@@ -2393,23 +2427,36 @@ int32_t QCamera2HardwareInterface::configureZSLHDRBracketing()
     memset(&aeBracket, 0, sizeof(cam_exp_bracketing_t));
     aeBracket.mode =
         gCamCapability[mCameraId]->hdr_bracketing_setting.exp_val.mode;
-    String8 tmp;
+#ifndef _ANDROID_
+    ostringstream str_stream;
+#endif
     for ( unsigned int i = 0; i < hdrFrameCount ; i++ ) {
+#ifdef _ANDROID_
         tmp.appendFormat("%d",
             (int8_t) gCamCapability[mCameraId]->hdr_bracketing_setting.exp_val.values[i]);
         tmp.append(",");
+#else
+        str_stream << (int8_t) gCamCapability[mCameraId]->
+            hdr_bracketing_setting.exp_val.values[i] << ",";
+#endif
     }
     if (mParameters.isHDR1xFrameEnabled()
         && mParameters.isHDR1xExtraBufferNeeded()) {
-            tmp.appendFormat("%d", 0);
-            tmp.append(",");
+#ifdef _ANDROID_
+        tmp.appendFormat("%d", 0);
+        tmp.append(",");
+#else
+        str_stream << 0 << ",";
+#endif
     }
 
-    if( !tmp.isEmpty() &&
+    string tmp = str_stream.str();
+
+    if( !tmp.empty() &&
         ( MAX_EXP_BRACKETING_LENGTH > tmp.length() ) ) {
         //Trim last comma
         memset(aeBracket.values, '\0', MAX_EXP_BRACKETING_LENGTH);
-        memcpy(aeBracket.values, tmp.string(), tmp.length() - 1);
+        memcpy(aeBracket.values, tmp.c_str(), tmp.length() - 1);
     }
 
     ALOGE("%s : HDR config values %s",
@@ -2927,7 +2974,7 @@ int QCamera2HardwareInterface::cancelLiveSnapshot()
 char* QCamera2HardwareInterface::getParameters()
 {
     char* strParams = NULL;
-    String8 str;
+    string str;
 
     int cur_width, cur_height;
 
@@ -2939,7 +2986,7 @@ char* QCamera2HardwareInterface::getParameters()
         mParameters.m_reprocScaleParam.getPicSizeFromAPK(scale_width,scale_height);
         mParameters.getPictureSize(&cur_width, &cur_height);
 
-        String8 pic_size;
+        string pic_size;
         char buffer[32];
         snprintf(buffer, sizeof(buffer), "%dx%d", scale_width, scale_height);
         pic_size.append(buffer);
@@ -2950,14 +2997,14 @@ char* QCamera2HardwareInterface::getParameters()
     strParams = (char *)malloc(sizeof(char)*(str.length()+1));
     if(strParams != NULL){
         memset(strParams, 0, sizeof(char)*(str.length()+1));
-        strncpy(strParams, str.string(), str.length());
+        strncpy(strParams, str.c_str(), str.length());
         strParams[str.length()] = 0;
     }
 
     if(mParameters.m_reprocScaleParam.isScaleEnabled() &&
         mParameters.m_reprocScaleParam.isUnderScaling()){
         //need set back picture size
-        String8 pic_size;
+        string pic_size;
         char buffer[32];
         snprintf(buffer, sizeof(buffer), "%dx%d", cur_width, cur_height);
         pic_size.append(buffer);
@@ -4248,8 +4295,12 @@ int32_t QCamera2HardwareInterface::addZSLChannel()
         return rc;
     }
 
+#ifdef _ANDROID_
     property_get("persist.camera.raw_yuv", value, "0");
     raw_yuv = atoi(value) > 0 ? true : false;
+#else
+    raw_yuv = false;
+#endif
     if ( raw_yuv ) {
         rc = addStreamToChannel(pChannel,
                                 CAM_STREAM_TYPE_RAW,
@@ -4357,8 +4408,12 @@ int32_t QCamera2HardwareInterface::addCaptureChannel()
         return rc;
     }
 
+#ifdef _ANDROID_
     property_get("persist.camera.raw_yuv", value, "0");
     raw_yuv = atoi(value) > 0 ? true : false;
+#else
+    raw_yuv = false;
+#endif
     if ( raw_yuv ) {
         rc = addStreamToChannel(pChannel,
                                 CAM_STREAM_TYPE_RAW,
@@ -5414,7 +5469,7 @@ int QCamera2HardwareInterface::updateParameters(const char *parms, bool &needRes
 {
     int rc = NO_ERROR;
     pthread_mutex_lock(&m_parm_lock);
-    String8 str = String8(parms);
+    string str = string(parms);
     QCameraParameters param(str);
     rc =  mParameters.updateParameters(param, needRestart);
 
@@ -5508,8 +5563,12 @@ bool QCamera2HardwareInterface::isPreviewRestartEnabled()
 {
     char prop[PROPERTY_VALUE_MAX];
     memset(prop, 0, sizeof(prop));
+#ifdef _ANDROID_
     property_get("persist.camera.feature.restart", prop, "0");
     int earlyRestart = atoi(prop);
+#else
+    int earlyRestart = 0;
+#endif
     return earlyRestart == 1;
 }
 
@@ -6072,10 +6131,13 @@ void *QCamera2HardwareInterface::defferedWorkRoutine(void *obj)
                             }
                         }
                         {
-                            Mutex::Autolock l(pme->mDeffLock);
+                            //Mutex::Autolock l(pme->mDeffLock);
+                            pthread_mutex_lock(&pme->mDeffLock);
                             pme->mDeffOngoingJobs[dw->id] = false;
                             delete dw;
-                            pme->mDeffCond.signal();
+                            //pme->mDeffCond.signal();
+                            pthread_cond_signal(&pme->mDeffCond);
+                            pthread_mutex_unlock(&pme->mDeffLock);
                         }
 
                     }
@@ -6090,10 +6152,13 @@ void *QCamera2HardwareInterface::defferedWorkRoutine(void *obj)
                             pme->delChannel(QCAMERA_CH_TYPE_CAPTURE);
                         }
                         {
-                            Mutex::Autolock l(pme->mDeffLock);
+                            //Mutex::Autolock l(pme->mDeffLock);
+                            pthread_mutex_lock(&pme->mDeffLock);
                             pme->mDeffOngoingJobs[dw->id] = false;
                             delete dw;
-                            pme->mDeffCond.signal();
+                            //pme->mDeffCond.signal();
+                            pthread_cond_signal(&pme->mDeffCond);
+                            pthread_mutex_unlock(&pme->mDeffLock);
                         }
                     }
                     break;
@@ -6152,7 +6217,8 @@ bool QCamera2HardwareInterface::isCaptureShutterEnabled()
 int32_t QCamera2HardwareInterface::queueDefferedWork(DefferedWorkCmd cmd,
                                                      DefferWorkArgs args)
 {
-    Mutex::Autolock l(mDeffLock);
+    //Mutex::Autolock l(mDeffLock);
+    pthread_mutex_lock(&mDeffLock);
     for (int i = 0; i < MAX_ONGOING_JOBS; ++i) {
         if (!mDeffOngoingJobs[i]) {
             mCmdQueue.enqueue(new DeffWork(cmd, i, args));
@@ -6160,9 +6226,11 @@ int32_t QCamera2HardwareInterface::queueDefferedWork(DefferedWorkCmd cmd,
             mDefferedWorkThread.sendCmd(CAMERA_CMD_TYPE_DO_NEXT_JOB,
                                         FALSE,
                                         FALSE);
+            pthread_mutex_unlock(&mDeffLock);
             return i;
         }
     }
+    pthread_mutex_unlock(&mDeffLock);
     return -1;
 }
 
@@ -6180,17 +6248,21 @@ int32_t QCamera2HardwareInterface::queueDefferedWork(DefferedWorkCmd cmd,
  *==========================================================================*/
 int32_t QCamera2HardwareInterface::waitDefferedWork(int32_t &job_id)
 {
-    Mutex::Autolock l(mDeffLock);
+    //Mutex::Autolock l(mDeffLock);
+    pthread_mutex_lock(&mDeffLock);
 
     if ((MAX_ONGOING_JOBS <= job_id) || (0 > job_id)) {
+        pthread_mutex_unlock(&mDeffLock);
         return NO_ERROR;
     }
 
     while ( mDeffOngoingJobs[job_id] == true ) {
-        mDeffCond.wait(mDeffLock);
+        //mDeffCond.wait(mDeffLock);
+        pthread_cond_wait(&mDeffCond, &mDeffLock);
     }
 
     job_id = MAX_ONGOING_JOBS;
+    pthread_mutex_unlock(&mDeffLock);
     return NO_ERROR;
 }
 
diff --git a/QCamera2/HAL/QCamera2HWI.h b/QCamera2/HAL/QCamera2HWI.h
index 03737e3..41a6b81 100644
--- a/QCamera2/HAL/QCamera2HWI.h
+++ b/QCamera2/HAL/QCamera2HWI.h
@@ -32,9 +32,17 @@
 
 #include <hardware/camera.h>
 #include <hardware/power.h>
+
+#ifdef _ANDROID_
 #include <utils/Log.h>
 #include <utils/Mutex.h>
 #include <utils/Condition.h>
+#include <mutex>
+#include <condition_variable>
+#else
+#include <pthread.h>
+#endif
+
 #include <QCameraParameters.h>
 
 #include "QCameraQueue.h"
@@ -581,8 +589,13 @@ private:
     QCameraCmdThread      mDefferedWorkThread;
     QCameraQueue          mCmdQueue;
 
+#ifdef _ANDROID_
     Mutex                 mDeffLock;
     Condition             mDeffCond;
+#else
+    pthread_mutex_t         mDeffLock;
+    pthread_cond_t          mDeffCond;
+#endif
 
     int32_t queueDefferedWork(DefferedWorkCmd cmd,
                               DefferWorkArgs args);
diff --git a/QCamera2/HAL/QCamera2HWICallbacks.cpp b/QCamera2/HAL/QCamera2HWICallbacks.cpp
index 7e1272e..bbb3e3d 100644
--- a/QCamera2/HAL/QCamera2HWICallbacks.cpp
+++ b/QCamera2/HAL/QCamera2HWICallbacks.cpp
@@ -34,6 +34,9 @@
 #include <utils/Errors.h>
 #include <utils/Timers.h>
 #include "QCamera2HWI.h"
+#include <sys/time.h>
+
+#include <cassert>
 
 namespace qcamera {
 
@@ -92,8 +95,12 @@ void QCamera2HardwareInterface::zsl_channel_cb(mm_camera_super_buf_t *recvd_fram
     }
 
     // DUMP RAW if available
+#ifdef _ANDROID_
     property_get("persist.camera.zsl_raw", value, "0");
     dump_raw = atoi(value) > 0 ? true : false;
+#else
+    dump_raw = false;
+#endif
     if ( dump_raw ) {
         for ( int i= 0 ; i < recvd_frame->num_bufs ; i++ ) {
             if ( recvd_frame->bufs[i]->stream_type == CAM_STREAM_TYPE_RAW ) {
@@ -109,8 +116,12 @@ void QCamera2HardwareInterface::zsl_channel_cb(mm_camera_super_buf_t *recvd_fram
     //
 
     // DUMP YUV before reprocess if needed
+#ifdef _ANDROID_
     property_get("persist.camera.zsl_yuv", value, "0");
     dump_yuv = atoi(value) > 0 ? true : false;
+#else
+    dump_yuv = false;
+#endif
     if ( dump_yuv ) {
         for ( int i= 0 ; i < recvd_frame->num_bufs ; i++ ) {
             if ( recvd_frame->bufs[i]->stream_type == CAM_STREAM_TYPE_SNAPSHOT ) {
@@ -167,8 +178,12 @@ void QCamera2HardwareInterface::zsl_channel_cb(mm_camera_super_buf_t *recvd_fram
         }
     }
 
+#ifdef _ANDROID_
     property_get("persist.camera.dumpmetadata", value, "0");
     int32_t enabled = atoi(value);
+#else
+    int32_t enabled = 0;
+#endif
     if (enabled) {
         mm_camera_buf_def_t *pMetaFrame = NULL;
         QCameraStream *pStream = NULL;
@@ -390,6 +405,7 @@ void QCamera2HardwareInterface::preview_stream_cb_routine(mm_camera_super_buf_t
                                                           QCameraStream * stream,
                                                           void *userdata)
 {
+#ifdef _ANDROID_
     ALOGD("[KPI Perf] %s : BEGIN", __func__);
     int err = NO_ERROR;
     QCamera2HardwareInterface *pme = (QCamera2HardwareInterface *)userdata;
@@ -503,6 +519,10 @@ void QCamera2HardwareInterface::preview_stream_cb_routine(mm_camera_super_buf_t
 
     free(super_frame);
     ALOGD("[KPI Perf] %s : END", __func__);
+#else
+    ALOGE("%s: Display mode not supported", __func__);
+    assert(0);
+#endif
     return;
 }
 
@@ -523,9 +543,9 @@ void QCamera2HardwareInterface::preview_stream_cb_routine(mm_camera_super_buf_t
  *             responsibility to free super_frame once it's done.
  *==========================================================================*/
 void QCamera2HardwareInterface::nodisplay_preview_stream_cb_routine(
-                                                          mm_camera_super_buf_t *super_frame,
-                                                          QCameraStream *stream,
-                                                          void * userdata)
+                                          mm_camera_super_buf_t *super_frame,
+                                          QCameraStream *stream,
+                                          void * userdata)
 {
     ALOGD("[KPI Perf] %s E",__func__);
     QCamera2HardwareInterface *pme = (QCamera2HardwareInterface *)userdata;
@@ -544,6 +564,14 @@ void QCamera2HardwareInterface::nodisplay_preview_stream_cb_routine(
         return;
     }
 
+#ifndef _ANDROID_
+    nsecs_t timeStamp;
+    if(pme->mParameters.isAVTimerEnabled() == true) {
+        timeStamp = (nsecs_t)((frame->ts.tv_sec * 1000000LL) + frame->ts.tv_nsec) * 1000;
+    } else {
+        timeStamp = nsecs_t(frame->ts.tv_sec) * 1000000000LL + frame->ts.tv_nsec;
+    }
+#endif
     if (!pme->needProcessPreviewFrame()) {
         ALOGD("%s: preview is not running, no need to process", __func__);
         stream->bufDone(frame->buf_idx);
@@ -560,6 +588,7 @@ void QCamera2HardwareInterface::nodisplay_preview_stream_cb_routine(
     if (previewMemObj != NULL) {
         preview_mem = previewMemObj->getMemory(frame->buf_idx, false);
     }
+#ifdef _ANDROID_
     if (NULL != previewMemObj && NULL != preview_mem) {
         pme->dumpFrameToFile(stream, frame, QCAMERA_DUMP_FRM_PREVIEW);
 
@@ -583,6 +612,32 @@ void QCamera2HardwareInterface::nodisplay_preview_stream_cb_routine(
         } else {
             stream->bufDone(frame->buf_idx);
         }
+#else
+    /* send preview frames on dataTimeStamp Callback instead of
+           dataCallback */
+    if (NULL != previewMemObj && NULL != preview_mem) {
+        pme->dumpFrameToFile(stream, frame, QCAMERA_DUMP_FRM_PREVIEW);
+        if ((pme->mDataCbTimestamp != NULL) &&
+                pme->msgTypeEnabledWithLock(CAMERA_MSG_PREVIEW_FRAME) > 0) {
+            int user_data = frame->buf_idx;
+            qcamera_callback_argm_t cbArg;
+            memset(&cbArg, 0, sizeof(qcamera_callback_argm_t));
+            cbArg.cb_type = QCAMERA_DATA_TIMESTAMP_CALLBACK;
+            cbArg.msg_type = CAMERA_MSG_PREVIEW_FRAME;
+            cbArg.data = preview_mem;
+            cbArg.timestamp = timeStamp;
+            cbArg.user_data = ( void * ) user_data;
+            cbArg.cookie = stream;
+            cbArg.release_cb = returnStreamBuffer;
+            int32_t rc = pme->m_cbNotifier.notifyCallback(cbArg);
+            if (rc != NO_ERROR) {
+                ALOGE("%s: fail sending data notify", __func__);
+                stream->bufDone(frame->buf_idx);
+            }
+        } else {
+            stream->bufDone(frame->buf_idx);
+        }
+#endif
     }
     free(super_frame);
     ALOGD("[KPI Perf] %s X",__func__);
@@ -609,15 +664,18 @@ void QCamera2HardwareInterface::postview_stream_cb_routine(mm_camera_super_buf_t
 {
     int err = NO_ERROR;
     QCamera2HardwareInterface *pme = (QCamera2HardwareInterface *)userdata;
+#ifdef _ANDROID_
     QCameraGrallocMemory *memory = (QCameraGrallocMemory *)super_frame->bufs[0]->mem_info;
 
-    if (pme == NULL) {
-        ALOGE("%s: Invalid hardware object", __func__);
+    if (memory == NULL) {
+        ALOGE("%s: Invalid memory object", __func__);
         free(super_frame);
         return;
     }
-    if (memory == NULL) {
-        ALOGE("%s: Invalid memory object", __func__);
+#endif
+
+    if (pme == NULL) {
+        ALOGE("%s: Invalid hardware object", __func__);
         free(super_frame);
         return;
     }
@@ -635,7 +693,6 @@ void QCamera2HardwareInterface::postview_stream_cb_routine(mm_camera_super_buf_t
     if (NULL != memObj) {
         pme->dumpFrameToFile(stream, frame, QCAMERA_DUMP_FRM_THUMBNAIL);
     }
-
     // Return buffer back to driver
     err = stream->bufDone(frame->buf_idx);
     if ( err < 0) {
@@ -863,9 +920,12 @@ void QCamera2HardwareInterface::preview_raw_stream_cb_routine(mm_camera_super_bu
         free(super_frame);
         return;
     }
-
+#ifdef _ANDROID_
     property_get("persist.camera.preview_raw", value, "0");
     dump_raw = atoi(value) > 0 ? true : false;
+#else
+    dump_raw = false;
+#endif
 
     for ( i= 0 ; i < super_frame->num_bufs ; i++ ) {
         if ( super_frame->bufs[i]->stream_type == CAM_STREAM_TYPE_RAW ) {
@@ -916,9 +976,12 @@ void QCamera2HardwareInterface::snapshot_raw_stream_cb_routine(mm_camera_super_b
         free(super_frame);
         return;
     }
-
+#ifdef _ANDROID_
     property_get("persist.camera.snapshot_raw", value, "0");
     dump_raw = atoi(value) > 0 ? true : false;
+#else
+    dump_raw = false;
+#endif
 
     for ( i= 0 ; i < super_frame->num_bufs ; i++ ) {
         if ( super_frame->bufs[i]->stream_type == CAM_STREAM_TYPE_RAW ) {
@@ -1283,8 +1346,13 @@ void QCamera2HardwareInterface::dumpMetadataToFile(QCameraStream *stream,
     char value[PROPERTY_VALUE_MAX];
     int frm_num = 0;
     cam_metadata_info_t *metadata = (cam_metadata_info_t *)frame->buffer;
+#ifdef _ANDROID_
     property_get("persist.camera.dumpmetadata", value, "0");
     int32_t enabled = atoi(value);
+#else
+    int32_t enabled = 0;
+#endif
+
     if (stream == NULL) {
         ALOGE("No op");
         return;
@@ -1314,11 +1382,11 @@ void QCamera2HardwareInterface::dumpMetadataToFile(QCameraStream *stream,
             time (&current_time);
             timeinfo = localtime (&current_time);
             strftime (timeBuf, sizeof(timeBuf),"/data/%Y%m%d%H%M%S", timeinfo);
-            String8 filePath(timeBuf);
+            string filePath(timeBuf);
             snprintf(buf, sizeof(buf), "%dm_%s_%d.bin",
                                          mDumpFrmCnt,type,frame->frame_idx);
             filePath.append(buf);
-            int file_fd = open(filePath.string(), O_RDWR | O_CREAT, 0777);
+            int file_fd = open(filePath.c_str(), O_RDWR | O_CREAT, 0777);
             if (file_fd > 0) {
                 int written_len = 0;
                 metadata->tuning_params.tuning_data_version = TUNING_DATA_VERSION;
@@ -1424,7 +1492,7 @@ void QCamera2HardwareInterface::dumpFrameToFile(QCameraStream *stream,
                     stream->getFrameOffset(offset);
 
                     strftime (timeBuf, sizeof(timeBuf),"/data/%Y%m%d%H%M%S", timeinfo);
-                    String8 filePath(timeBuf);
+                    string filePath(timeBuf);
                     switch (dump_type) {
                     case QCAMERA_DUMP_FRM_PREVIEW:
                         {
@@ -1464,7 +1532,7 @@ void QCamera2HardwareInterface::dumpFrameToFile(QCameraStream *stream,
                     }
 
                     filePath.append(buf);
-                    int file_fd = open(filePath.string(), O_RDWR | O_CREAT, 0777);
+                    int file_fd = open(filePath.c_str(), O_RDWR | O_CREAT, 0777);
                     if (file_fd > 0) {
                         void *data = NULL;
                         int written_len = 0;
@@ -1513,7 +1581,10 @@ void QCamera2HardwareInterface::debugShowVideoFPS()
     static nsecs_t n_vLastFpsTime = 0;
     static float n_vFps = 0;
     n_vFrameCount++;
-    nsecs_t now = systemTime();
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    nsecs_t now = tv.tv_usec * 1000;
+    //nsecs_t now = systemTime();
     nsecs_t diff = now - n_vLastFpsTime;
     if (diff > ms2ns(250)) {
         n_vFps =  ((n_vFrameCount - n_vLastFrameCount) * float(s2ns(1))) / diff;
@@ -1539,7 +1610,10 @@ void QCamera2HardwareInterface::debugShowPreviewFPS()
     static nsecs_t n_pLastFpsTime = 0;
     static float n_pFps = 0;
     n_pFrameCount++;
-    nsecs_t now = systemTime();
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    nsecs_t now = tv.tv_usec * 1000;
+    //nsecs_t now = systemTime();
     nsecs_t diff = now - n_pLastFpsTime;
     if (diff > ms2ns(250)) {
         n_pFps =  ((n_pFrameCount - n_pLastFrameCount) * float(s2ns(1))) / diff;
diff --git a/QCamera2/HAL/QCameraMem.cpp b/QCamera2/HAL/QCameraMem.cpp
index 8260968..425da77 100644
--- a/QCamera2/HAL/QCameraMem.cpp
+++ b/QCamera2/HAL/QCameraMem.cpp
@@ -33,10 +33,16 @@
 #include <fcntl.h>
 #include <sys/mman.h>
 #include <utils/Errors.h>
-#include <gralloc_priv.h>
 #include <QComOMXMetadata.h>
 #include "QCamera2HWI.h"
 #include "QCameraMem.h"
+#include <sys/ioctl.h>
+#include "cutils/native_handle.h"
+#include "android_adapter.h"
+
+#ifdef _ANDROID_
+#include <gralloc_priv.h>
+#endif
 
 extern "C" {
 #include <mm_camera_interface.h>
@@ -1225,7 +1231,7 @@ int QCameraVideoMemory::getMatchBufIndex(const void *opaque,
     }
     return index;
 }
-
+#ifdef _ANDROID_
 /*===========================================================================
  * FUNCTION   : QCameraGrallocMemory
  *
@@ -1692,5 +1698,5 @@ void *QCameraGrallocMemory::getPtr(int index) const
     }
     return mCameraMemory[index]->data;
 }
-
+#endif /* #ifdef _ANDROID_ */
 }; //namespace qcamera
diff --git a/QCamera2/HAL/QCameraMem.h b/QCamera2/HAL/QCameraMem.h
index c961900..5b8aabb 100644
--- a/QCamera2/HAL/QCameraMem.h
+++ b/QCamera2/HAL/QCameraMem.h
@@ -191,6 +191,7 @@ private:
 };
 ;
 
+#ifdef _ANDROID_
 // Gralloc Memory is acquired from preview window
 class QCameraGrallocMemory : public QCameraMemory {
     enum {
@@ -228,7 +229,7 @@ private:
     camera_memory_t *mCameraMemory[MM_CAMERA_MAX_NUM_FRAMES];
     int mMinUndequeuedBuffers;
 };
-
+#endif
 }; // namespace qcamera
 
 #endif /* __QCAMERA2HWI_MEM_H__ */
diff --git a/QCamera2/HAL/QCameraParameters.cpp b/QCamera2/HAL/QCameraParameters.cpp
index 059c735..453dc9e 100644
--- a/QCamera2/HAL/QCameraParameters.cpp
+++ b/QCamera2/HAL/QCameraParameters.cpp
@@ -29,14 +29,18 @@
 
 #define LOG_TAG "QCameraParameters"
 
-#include <cutils/properties.h>
 #include <math.h>
-#include <utils/Errors.h>
 #include <string.h>
 #include <stdlib.h>
-#include <gralloc_priv.h>
 #include "QCamera2HWI.h"
 #include "QCameraParameters.h"
+#ifdef _ANDROID_
+#include <cutils/properties.h>
+#include <utils/Errors.h>
+#include <gralloc_priv.h>
+#else
+#include "android_adapter.h"
+#endif
 
 #define ASPECT_TOLERANCE 0.001
 #define FLIP_V_H (FLIP_H | FLIP_V)
@@ -692,7 +696,7 @@ QCameraParameters::QCameraParameters()
  *
  * RETURN     : None
  *==========================================================================*/
-QCameraParameters::QCameraParameters(const String8 &params)
+QCameraParameters::QCameraParameters(const string &params)
     : CameraParameters(params),
     m_reprocScaleParam(this),
     m_pCapability(NULL),
@@ -768,9 +772,9 @@ QCameraParameters::~QCameraParameters()
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createSizesString(const cam_dimension_t *sizes, int len)
+string QCameraParameters::createSizesString(const cam_dimension_t *sizes, int len)
 {
-    String8 str;
+    string str;
     char buffer[32];
 
     if (len > 0) {
@@ -798,12 +802,12 @@ String8 QCameraParameters::createSizesString(const cam_dimension_t *sizes, int l
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createValuesString(const int *values,
+string QCameraParameters::createValuesString(const int *values,
                                               int len,
                                               const QCameraMap* map,
                                               int map_len)
 {
-    String8 str;
+    string str;
     int count = 0;
 
     for (int i = 0; i < len; i++ ) {
@@ -833,10 +837,10 @@ String8 QCameraParameters::createValuesString(const int *values,
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createValuesStringFromMap(const QCameraMap* map,
+string QCameraParameters::createValuesStringFromMap(const QCameraMap* map,
                                                      int map_len)
 {
-    String8 str;
+    string str;
 
     for (int i = 0; i < map_len; i++) {
         if (NULL != map[i].desc) {
@@ -860,9 +864,9 @@ String8 QCameraParameters::createValuesStringFromMap(const QCameraMap* map,
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createZoomRatioValuesString(int *zoomRatios, int length)
+string QCameraParameters::createZoomRatioValuesString(int *zoomRatios, int length)
 {
-    String8 str;
+    string str;
     char buffer[32] = {0};
 
     if(length > 0){
@@ -892,13 +896,13 @@ String8 QCameraParameters::createZoomRatioValuesString(int *zoomRatios, int leng
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createHfrValuesString(
+string QCameraParameters::createHfrValuesString(
                                 const cam_hfr_info_t *values,
                                 int len,
                                 const QCameraMap* map,
                                 int map_len)
 {
-    String8 str;
+    string str;
     int count = 0;
 
     for (int i = 0; i < len; i++ ) {
@@ -932,11 +936,11 @@ String8 QCameraParameters::createHfrValuesString(
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createHfrSizesString(
+string QCameraParameters::createHfrSizesString(
                                 const cam_hfr_info_t *values,
                                 int len)
 {
-    String8 str;
+    string str;
     char buffer[32];
 
     if (len > 0) {
@@ -962,10 +966,10 @@ String8 QCameraParameters::createHfrSizesString(
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createFpsString(cam_fps_range_t &fps)
+string QCameraParameters::createFpsString(cam_fps_range_t &fps)
 {
     char buffer[32];
-    String8 fpsValues;
+    string fpsValues;
 
     int min_fps = int(fps.min_fps);
     int max_fps = int(fps.max_fps);
@@ -1001,11 +1005,11 @@ String8 QCameraParameters::createFpsString(cam_fps_range_t &fps)
  *
  * RETURN     : string obj
  *==========================================================================*/
-String8 QCameraParameters::createFpsRangeString(const cam_fps_range_t* fps,
+string QCameraParameters::createFpsRangeString(const cam_fps_range_t* fps,
                                                 int len,
                                                 int &default_fps_index)
 {
-    String8 str;
+    string str;
     char buffer[32];
     int max_range = 0;
     int min_fps, max_fps;
@@ -2346,7 +2350,6 @@ int32_t QCameraParameters::setStatsDebugMask()
 {
     uint32_t mask = 0;
     char value[PROPERTY_VALUE_MAX];
-
     property_get("persist.camera.stats.debug.mask", value, "0");
     mask = (uint32_t)atoi(value);
 
@@ -3001,6 +3004,7 @@ int32_t QCameraParameters::setAEBracket(const QCameraParameters& params)
         char prop[PROPERTY_VALUE_MAX];
         memset(prop, 0, sizeof(prop));
         property_get("persist.capture.burst.exposures", prop, "");
+
         if (strlen(prop) > 0) {
             set(KEY_QC_CAPTURE_BURST_EXPOSURE, prop);
         } else {
@@ -3823,10 +3827,10 @@ int32_t QCameraParameters::initDefaultParameters()
     // Set supported preview sizes
     if (m_pCapability->preview_sizes_tbl_cnt > 0 &&
         m_pCapability->preview_sizes_tbl_cnt <= MAX_SIZES_CNT) {
-        String8 previewSizeValues = createSizesString(
+        string previewSizeValues = createSizesString(
                 m_pCapability->preview_sizes_tbl, m_pCapability->preview_sizes_tbl_cnt);
-        set(KEY_SUPPORTED_PREVIEW_SIZES, previewSizeValues.string());
-        ALOGD("%s: supported preview sizes: %s", __func__, previewSizeValues.string());
+        set(KEY_SUPPORTED_PREVIEW_SIZES, previewSizeValues.c_str());
+        ALOGD("%s: supported preview sizes: %s", __func__, previewSizeValues.c_str());
         // Set default preview size
         CameraParameters::setPreviewSize(m_pCapability->preview_sizes_tbl[0].width,
                                          m_pCapability->preview_sizes_tbl[0].height);
@@ -3837,17 +3841,17 @@ int32_t QCameraParameters::initDefaultParameters()
     // Set supported video sizes
     if (m_pCapability->video_sizes_tbl_cnt > 0 &&
         m_pCapability->video_sizes_tbl_cnt <= MAX_SIZES_CNT) {
-        String8 videoSizeValues = createSizesString(
+        string videoSizeValues = createSizesString(
                 m_pCapability->video_sizes_tbl, m_pCapability->video_sizes_tbl_cnt);
-        set(KEY_SUPPORTED_VIDEO_SIZES, videoSizeValues.string());
-        ALOGD("%s: supported video sizes: %s", __func__, videoSizeValues.string());
+        set(KEY_SUPPORTED_VIDEO_SIZES, videoSizeValues.c_str());
+        ALOGD("%s: supported video sizes: %s", __func__, videoSizeValues.c_str());
         // Set default video size
         CameraParameters::setVideoSize(m_pCapability->video_sizes_tbl[0].width,
                                        m_pCapability->video_sizes_tbl[0].height);
 
         //Set preferred Preview size for video
-        String8 vSize = createSizesString(&m_pCapability->video_sizes_tbl[0], 1);
-        set(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, vSize.string());
+        string vSize = createSizesString(&m_pCapability->video_sizes_tbl[0], 1);
+        set(KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, vSize.c_str());
     } else {
         ALOGE("%s: supported video sizes cnt is 0 or exceeds max!!!", __func__);
     }
@@ -3855,10 +3859,10 @@ int32_t QCameraParameters::initDefaultParameters()
     // Set supported picture sizes
     if (m_pCapability->picture_sizes_tbl_cnt > 0 &&
         m_pCapability->picture_sizes_tbl_cnt <= MAX_SIZES_CNT) {
-        String8 pictureSizeValues = createSizesString(
+        string pictureSizeValues = createSizesString(
                 m_pCapability->picture_sizes_tbl, m_pCapability->picture_sizes_tbl_cnt);
-        set(KEY_SUPPORTED_PICTURE_SIZES, pictureSizeValues.string());
-        ALOGD("%s: supported pic sizes: %s", __func__, pictureSizeValues.string());
+        set(KEY_SUPPORTED_PICTURE_SIZES, pictureSizeValues.c_str());
+        ALOGD("%s: supported pic sizes: %s", __func__, pictureSizeValues.c_str());
         // Set default picture size to the smallest resolution
         CameraParameters::setPictureSize(
            m_pCapability->picture_sizes_tbl[m_pCapability->picture_sizes_tbl_cnt-1].width,
@@ -3876,10 +3880,10 @@ int32_t QCameraParameters::initDefaultParameters()
             m_pCapability->scale_picture_sizes_cnt, m_pCapability->scale_picture_sizes,
             m_pCapability->picture_sizes_tbl_cnt, m_pCapability->picture_sizes_tbl);
         if(rc_s == NO_ERROR){
-            String8 scaledPictureSizeValues = createSizesString(
+            string scaledPictureSizeValues = createSizesString(
                 m_pCapability->scale_picture_sizes, m_pCapability->scale_picture_sizes_cnt);
-            set(KEY_QC_SCALED_PICTURE_SIZES, scaledPictureSizeValues.string());
-            ALOGE("%s: scaled supported pic sizes: %s", __func__, scaledPictureSizeValues.string());
+            set(KEY_QC_SCALED_PICTURE_SIZES, scaledPictureSizeValues.c_str());
+            ALOGE("%s: scaled supported pic sizes: %s", __func__, scaledPictureSizeValues.c_str());
         }else{
             m_reprocScaleParam.setScaleEnable(false);
             ALOGE("%s: reset scaled picture size table failed.", __func__);
@@ -3889,10 +3893,10 @@ int32_t QCameraParameters::initDefaultParameters()
     }
 
     // Set supported thumbnail sizes
-    String8 thumbnailSizeValues = createSizesString(
+    string thumbnailSizeValues = createSizesString(
             THUMBNAIL_SIZES_MAP,
             sizeof(THUMBNAIL_SIZES_MAP)/sizeof(cam_dimension_t));
-    set(KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, thumbnailSizeValues.string());
+    set(KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES, thumbnailSizeValues.c_str());
     // Set default thumnail size
     set(KEY_JPEG_THUMBNAIL_WIDTH, THUMBNAIL_SIZES_MAP[0].width);
     set(KEY_JPEG_THUMBNAIL_HEIGHT, THUMBNAIL_SIZES_MAP[0].height);
@@ -3900,22 +3904,22 @@ int32_t QCameraParameters::initDefaultParameters()
     // Set supported livesnapshot sizes
     if (m_pCapability->livesnapshot_sizes_tbl_cnt > 0 &&
         m_pCapability->livesnapshot_sizes_tbl_cnt <= MAX_SIZES_CNT) {
-        String8 liveSnpashotSizeValues = createSizesString(
+        string liveSnpashotSizeValues = createSizesString(
                 m_pCapability->livesnapshot_sizes_tbl,
                 m_pCapability->livesnapshot_sizes_tbl_cnt);
-        set(KEY_QC_SUPPORTED_LIVESNAPSHOT_SIZES, liveSnpashotSizeValues.string());
-        ALOGI("%s: supported live snapshot sizes: %s", __func__, liveSnpashotSizeValues.string());
+        set(KEY_QC_SUPPORTED_LIVESNAPSHOT_SIZES, liveSnpashotSizeValues.c_str());
+        ALOGI("%s: supported live snapshot sizes: %s", __func__, liveSnpashotSizeValues.c_str());
         m_LiveSnapshotSize =
             m_pCapability->livesnapshot_sizes_tbl[m_pCapability->livesnapshot_sizes_tbl_cnt-1];
     }
 
     // Set supported preview formats
-    String8 previewFormatValues = createValuesString(
+    string previewFormatValues = createValuesString(
             (int *)m_pCapability->supported_preview_fmts,
             m_pCapability->supported_preview_fmt_cnt,
             PREVIEW_FORMATS_MAP,
             sizeof(PREVIEW_FORMATS_MAP)/sizeof(QCameraMap));
-    set(KEY_SUPPORTED_PREVIEW_FORMATS, previewFormatValues.string());
+    set(KEY_SUPPORTED_PREVIEW_FORMATS, previewFormatValues.c_str());
     // Set default preview format
     CameraParameters::setPreviewFormat(PIXEL_FORMAT_YUV420SP);
 
@@ -3923,18 +3927,18 @@ int32_t QCameraParameters::initDefaultParameters()
     set(KEY_VIDEO_FRAME_FORMAT, PIXEL_FORMAT_YUV420SP);
 
     // Set supported picture formats
-    String8 pictureTypeValues(PIXEL_FORMAT_JPEG);
-    String8 str = createValuesString(
+    string pictureTypeValues(PIXEL_FORMAT_JPEG);
+    string str = createValuesString(
             (int *)m_pCapability->supported_raw_fmts,
             m_pCapability->supported_raw_fmt_cnt,
             PICTURE_TYPES_MAP,
             sizeof(PICTURE_TYPES_MAP)/sizeof(QCameraMap));
-    if (str.string() != NULL) {
+    if (str.c_str() != NULL) {
         pictureTypeValues.append(",");
         pictureTypeValues.append(str);
     }
 
-    set(KEY_SUPPORTED_PICTURE_FORMATS, pictureTypeValues.string());
+    set(KEY_SUPPORTED_PICTURE_FORMATS, pictureTypeValues.c_str());
     // Set default picture Format
     CameraParameters::setPictureFormat(PIXEL_FORMAT_JPEG);
     // Set raw image size
@@ -3947,15 +3951,19 @@ int32_t QCameraParameters::initDefaultParameters()
     set(KEY_JPEG_QUALITY, 85);
     set(KEY_JPEG_THUMBNAIL_QUALITY, 85);
 
+    // set no-display-mode by default
+    set(KEY_QC_NO_DISPLAY_MODE, "1");
+    m_bNoDisplayMode = true;
+
     // Set FPS ranges
     if (m_pCapability->fps_ranges_tbl_cnt > 0 &&
         m_pCapability->fps_ranges_tbl_cnt <= MAX_SIZES_CNT) {
         int default_fps_index = 0;
-        String8 fpsRangeValues = createFpsRangeString(m_pCapability->fps_ranges_tbl,
+        string fpsRangeValues = createFpsRangeString(m_pCapability->fps_ranges_tbl,
                                                       m_pCapability->fps_ranges_tbl_cnt,
                                                       default_fps_index);
-        set(KEY_SUPPORTED_PREVIEW_FPS_RANGE, fpsRangeValues.string());
-        ALOGD("%s: supported fps ranges: %s", __func__, fpsRangeValues.string());
+        set(KEY_SUPPORTED_PREVIEW_FPS_RANGE, fpsRangeValues.c_str());
+        ALOGD("%s: supported fps ranges: %s", __func__, fpsRangeValues.c_str());
 
         int min_fps =
             int(m_pCapability->fps_ranges_tbl[default_fps_index].min_fps * 1000);
@@ -3966,9 +3974,9 @@ int32_t QCameraParameters::initDefaultParameters()
         setPreviewFpsRange(min_fps, max_fps, min_fps, max_fps);
 
         // Set legacy preview fps
-        String8 fpsValues = createFpsString(m_pCapability->fps_ranges_tbl[default_fps_index]);
-        set(KEY_SUPPORTED_PREVIEW_FRAME_RATES, fpsValues.string());
-        ALOGD("%s: supported fps rates: %s", __func__, fpsValues.string());
+        string fpsValues = createFpsString(m_pCapability->fps_ranges_tbl[default_fps_index]);
+        set(KEY_SUPPORTED_PREVIEW_FRAME_RATES, fpsValues.c_str());
+        ALOGD("%s: supported fps rates: %s", __func__, fpsValues.c_str());
         CameraParameters::setPreviewFrameRate(int(m_pCapability->fps_ranges_tbl[default_fps_index].max_fps));
     } else {
         ALOGE("%s: supported fps ranges cnt is 0 or exceeds max!!!", __func__);
@@ -3976,12 +3984,12 @@ int32_t QCameraParameters::initDefaultParameters()
 
     // Set supported focus modes
     if (m_pCapability->supported_focus_modes_cnt > 0) {
-        String8 focusModeValues = createValuesString(
+        string focusModeValues = createValuesString(
                 (int *)m_pCapability->supported_focus_modes,
                 m_pCapability->supported_focus_modes_cnt,
                 FOCUS_MODES_MAP,
                 sizeof(FOCUS_MODES_MAP)/sizeof(QCameraMap));
-        set(KEY_SUPPORTED_FOCUS_MODES, focusModeValues);
+        set(KEY_SUPPORTED_FOCUS_MODES, focusModeValues.c_str());
 
         // Set default focus mode and update corresponding parameter buf
         const char *focusMode = lookupNameByValue(FOCUS_MODES_MAP,
@@ -4056,12 +4064,12 @@ int32_t QCameraParameters::initDefaultParameters()
     setBrightness(m_pCapability->brightness_ctrl.def_value);
 
     // Set Auto exposure
-    String8 autoExposureValues = createValuesString(
+    string autoExposureValues = createValuesString(
             (int *)m_pCapability->supported_aec_modes,
             m_pCapability->supported_aec_modes_cnt,
             AUTO_EXPOSURE_MAP,
             sizeof(AUTO_EXPOSURE_MAP) / sizeof(QCameraMap));
-    set(KEY_QC_SUPPORTED_AUTO_EXPOSURE, autoExposureValues.string());
+    set(KEY_QC_SUPPORTED_AUTO_EXPOSURE, autoExposureValues.c_str());
     setAutoExposure(AUTO_EXPOSURE_FRAME_AVG);
 
     // Set Exposure Compensation
@@ -4071,16 +4079,16 @@ int32_t QCameraParameters::initDefaultParameters()
     setExposureCompensation(m_pCapability->exposure_compensation_default); // 0
 
     // Set Antibanding
-    String8 antibandingValues = createValuesString(
+    string antibandingValues = createValuesString(
             (int *)m_pCapability->supported_antibandings,
             m_pCapability->supported_antibandings_cnt,
             ANTIBANDING_MODES_MAP,
             sizeof(ANTIBANDING_MODES_MAP) / sizeof(QCameraMap));
-    set(KEY_SUPPORTED_ANTIBANDING, antibandingValues);
+    set(KEY_SUPPORTED_ANTIBANDING, antibandingValues.c_str());
     setAntibanding(ANTIBANDING_OFF);
 
     // Set Effect
-    String8 effectValues = createValuesString(
+    string effectValues = createValuesString(
             (int *)m_pCapability->supported_effects,
             m_pCapability->supported_effects_cnt,
             EFFECT_MODES_MAP,
@@ -4089,7 +4097,7 @@ int32_t QCameraParameters::initDefaultParameters()
     setEffect(EFFECT_NONE);
 
     // Set WhiteBalance
-    String8 whitebalanceValues = createValuesString(
+    string whitebalanceValues = createValuesString(
             (int *)m_pCapability->supported_white_balances,
             m_pCapability->supported_white_balances_cnt,
             WHITE_BALANCE_MODES_MAP,
@@ -4105,7 +4113,7 @@ int32_t QCameraParameters::initDefaultParameters()
 
     // Set Flash mode
     if(m_pCapability->supported_flash_modes_cnt > 0) {
-       String8 flashValues = createValuesString(
+       string flashValues = createValuesString(
                (int *)m_pCapability->supported_flash_modes,
                m_pCapability->supported_flash_modes_cnt,
                FLASH_MODES_MAP,
@@ -4117,7 +4125,7 @@ int32_t QCameraParameters::initDefaultParameters()
     }
 
     // Set Scene Mode
-    String8 sceneModeValues = createValuesString(
+    string sceneModeValues = createValuesString(
             (int *)m_pCapability->supported_scene_modes,
             m_pCapability->supported_scene_modes_cnt,
             SCENE_MODES_MAP,
@@ -4126,7 +4134,7 @@ int32_t QCameraParameters::initDefaultParameters()
     setSceneMode(SCENE_MODE_AUTO);
 
     // Set ISO Mode
-    String8 isoValues = createValuesString(
+    string isoValues = createValuesString(
             (int *)m_pCapability->supported_iso_modes,
             m_pCapability->supported_iso_modes_cnt,
             ISO_MODES_MAP,
@@ -4142,22 +4150,22 @@ int32_t QCameraParameters::initDefaultParameters()
     //setExposureTime("0");
 
     // Set HFR
-    String8 hfrValues = createHfrValuesString(
+    string hfrValues = createHfrValuesString(
             m_pCapability->hfr_tbl,
             m_pCapability->hfr_tbl_cnt,
             HFR_MODES_MAP,
             sizeof(HFR_MODES_MAP) / sizeof(QCameraMap));
-    set(KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES, hfrValues.string());
+    set(KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES, hfrValues.c_str());
     set(KEY_QC_VIDEO_HIGH_SPEED_RECORDING, "off");
     set(KEY_QC_VIDEO_HIGH_FRAME_RATE, "off");
-    String8 hfrSizeValues = createHfrSizesString(
+    string hfrSizeValues = createHfrSizesString(
             m_pCapability->hfr_tbl,
             m_pCapability->hfr_tbl_cnt);
-    set(KEY_QC_SUPPORTED_HFR_SIZES, hfrSizeValues.string());
+    set(KEY_QC_SUPPORTED_HFR_SIZES, hfrSizeValues.c_str());
     setHighFrameRate(CAM_HFR_MODE_OFF);
 
     // Set Focus algorithms
-    String8 focusAlgoValues = createValuesString(
+    string focusAlgoValues = createValuesString(
             (int *)m_pCapability->supported_focus_algos,
             m_pCapability->supported_focus_algos_cnt,
             FOCUS_ALGO_MAP,
@@ -4167,7 +4175,7 @@ int32_t QCameraParameters::initDefaultParameters()
 
     // Set Zoom Ratios
     if (m_pCapability->zoom_supported > 0) {
-        String8 zoomRatioValues = createZoomRatioValuesString(
+        string zoomRatioValues = createZoomRatioValuesString(
                 m_pCapability->zoom_ratio_tbl,
                 m_pCapability->zoom_ratio_tbl_cnt);
         set(KEY_ZOOM_RATIOS, zoomRatioValues);
@@ -4182,7 +4190,7 @@ int32_t QCameraParameters::initDefaultParameters()
     if (strlen(prop) > 0) {
         set(KEY_QC_CAPTURE_BURST_EXPOSURE, prop);
     }
-    String8 bracketingValues = createValuesStringFromMap(
+    string bracketingValues = createValuesStringFromMap(
             BRACKETING_MODES_MAP,
             sizeof(BRACKETING_MODES_MAP) / sizeof(QCameraMap));
     set(KEY_QC_SUPPORTED_AE_BRACKET_MODES, bracketingValues);
@@ -4193,7 +4201,7 @@ int32_t QCameraParameters::initDefaultParameters()
         if ((CAM_FOCUS_MODE_AUTO == m_pCapability->supported_focus_modes[i]) &&
                 ((m_pCapability->qcom_supported_feature_mask &
                         CAM_QCOM_FEATURE_UBIFOCUS) > 0)) {
-            String8 afBracketingValues = createValuesStringFromMap(
+            string afBracketingValues = createValuesStringFromMap(
                     AF_BRACKETING_MODES_MAP,
                     sizeof(AF_BRACKETING_MODES_MAP) / sizeof(QCameraMap));
             set(KEY_QC_SUPPORTED_AF_BRACKET_MODES, afBracketingValues);
@@ -4205,7 +4213,7 @@ int32_t QCameraParameters::initDefaultParameters()
     if ((m_pCapability->supported_flash_modes_cnt > 0) &&
             (m_pCapability->qcom_supported_feature_mask &
             CAM_QCOM_FEATURE_CHROMA_FLASH) > 0) {
-        String8 chromaFlashValues = createValuesStringFromMap(
+        string chromaFlashValues = createValuesStringFromMap(
                 CHROMA_FLASH_MODES_MAP,
                 sizeof(CHROMA_FLASH_MODES_MAP) / sizeof(QCameraMap));
         set(KEY_QC_SUPPORTED_CHROMA_FLASH_MODES, chromaFlashValues);
@@ -4216,7 +4224,7 @@ int32_t QCameraParameters::initDefaultParameters()
     if (m_pCapability->zoom_supported &&
             (m_pCapability->qcom_supported_feature_mask &
             CAM_QCOM_FEATURE_OPTIZOOM) > 0){
-        String8 optiZoomValues = createValuesStringFromMap(
+        string optiZoomValues = createValuesStringFromMap(
                 OPTI_ZOOM_MODES_MAP,
                 sizeof(OPTI_ZOOM_MODES_MAP) / sizeof(QCameraMap));
         set(KEY_QC_SUPPORTED_OPTI_ZOOM_MODES, optiZoomValues);
@@ -4225,9 +4233,9 @@ int32_t QCameraParameters::initDefaultParameters()
 
     // Set Denoise
     if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_DENOISE2D) > 0){
-    String8 denoiseValues = createValuesStringFromMap(
+    string denoiseValues = createValuesStringFromMap(
        DENOISE_ON_OFF_MODES_MAP, sizeof(DENOISE_ON_OFF_MODES_MAP) / sizeof(QCameraMap));
-    set(KEY_QC_SUPPORTED_DENOISE, denoiseValues.string());
+    set(KEY_QC_SUPPORTED_DENOISE, denoiseValues.c_str());
 #ifdef DEFAULT_DENOISE_MODE_ON
     setWaveletDenoise(DENOISE_ON);
 #else
@@ -4236,7 +4244,7 @@ int32_t QCameraParameters::initDefaultParameters()
     }
 
     // Set feature enable/disable
-    String8 enableDisableValues = createValuesStringFromMap(
+    string enableDisableValues = createValuesStringFromMap(
         ENABLE_DISABLE_MODES_MAP, sizeof(ENABLE_DISABLE_MODES_MAP) / sizeof(QCameraMap));
 
     // Set Lens Shading
@@ -4264,7 +4272,7 @@ int32_t QCameraParameters::initDefaultParameters()
     set(KEY_QC_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES, enableDisableValues);
 
     // Set feature on/off
-    String8 onOffValues = createValuesStringFromMap(
+    string onOffValues = createValuesStringFromMap(
         ON_OFF_MODES_MAP, sizeof(ON_OFF_MODES_MAP) / sizeof(QCameraMap));
 
     //Set Scene Detection
@@ -4286,6 +4294,7 @@ int32_t QCameraParameters::initDefaultParameters()
     char value[PROPERTY_VALUE_MAX];
 
     property_get("persist.camera.hdr.outcrop", value, VALUE_DISABLE);
+
     if (strncmp(VALUE_ENABLE, value, sizeof(VALUE_ENABLE))) {
       m_bHDROutputCropEnabled = false;
     } else {
@@ -4319,7 +4328,7 @@ int32_t QCameraParameters::initDefaultParameters()
     // Set VT TimeStamp
     set(KEY_QC_VT_ENABLE, VALUE_DISABLE);
     //Set Touch AF/AEC
-    String8 touchValues = createValuesStringFromMap(
+    string touchValues = createValuesStringFromMap(
        TOUCH_AF_AEC_MODES_MAP, sizeof(TOUCH_AF_AEC_MODES_MAP) / sizeof(QCameraMap));
 
     set(KEY_QC_SUPPORTED_TOUCH_AF_AEC, touchValues);
@@ -4327,7 +4336,7 @@ int32_t QCameraParameters::initDefaultParameters()
 
     //set flip mode
     if ((m_pCapability->qcom_supported_feature_mask & CAM_QCOM_FEATURE_FLIP) > 0) {
-        String8 flipModes = createValuesStringFromMap(
+        string flipModes = createValuesStringFromMap(
            FLIP_MODES_MAP, sizeof(FLIP_MODES_MAP) / sizeof(QCameraMap));
         set(KEY_QC_SUPPORTED_FLIP_MODES, flipModes);
         set(KEY_QC_PREVIEW_FLIP, FLIP_MODE_OFF);
@@ -4433,7 +4442,7 @@ void QCameraParameters::deinit()
     sem_destroy(&m_pParamBuf->cam_sync_sem);
 
     //clear all entries in the map
-    String8 emptyStr;
+    string emptyStr;
     QCameraParameters::unflatten(emptyStr);
 
     if (NULL != m_pCamOpsTbl) {
@@ -4512,7 +4521,7 @@ int32_t QCameraParameters::parse_pair(const char *str,
  *
  * RETURN     : none
  *==========================================================================*/
-void QCameraParameters::parseSizesList(const char *sizesStr, Vector<Size> &sizes)
+void QCameraParameters::parseSizesList(const char *sizesStr, vector<Size> &sizes)
 {
     if (sizesStr == 0) {
         return;
@@ -4528,7 +4537,7 @@ void QCameraParameters::parseSizesList(const char *sizesStr, Vector<Size> &sizes
             ALOGE("Picture sizes string \"%s\" contains invalid character.", sizesStr);
             return;
         }
-        sizes.push(Size(width, height));
+        sizes.push_back(Size(width, height));
 
         if (*sizeStartPtr == '\0') {
             return;
@@ -4547,7 +4556,7 @@ void QCameraParameters::parseSizesList(const char *sizesStr, Vector<Size> &sizes
  *
  * RETURN     : none
  *==========================================================================*/
-void QCameraParameters::getSupportedHfrSizes(Vector<Size> &sizes)
+void QCameraParameters::getSupportedHfrSizes(vector<Size> &sizes)
 {
     const char *hfrSizesStr = get(KEY_QC_SUPPORTED_HFR_SIZES);
     parseSizesList(hfrSizesStr, sizes);
@@ -6529,8 +6538,6 @@ int32_t QCameraParameters::updateFlash(bool commitSettings)
     }
 
     if (value != mFlashDaemonValue) {
-
-        ALOGV("%s: Setting Flash value %d", __func__, value);
         rc = AddSetParmEntryToBatch(m_pParamBuf,
                                       CAM_INTF_PARM_LED_MODE,
                                       sizeof(value),
@@ -6879,7 +6886,7 @@ int32_t QCameraParameters::getStreamFormat(cam_stream_type_t streamType,
             format = CAM_FORMAT_YUV_422_NV16;
         } else {
             char prop[PROPERTY_VALUE_MAX];
-            int snapshotFormat;
+            int snapshotFormat = 0;
             memset(prop, 0, sizeof(prop));
             property_get("persist.camera.snap.format", prop, "0");
             snapshotFormat = atoi(prop);
@@ -7057,7 +7064,7 @@ int32_t QCameraParameters::getStreamDimension(cam_stream_type_t streamType,
     }
     return ret;
 }
-
+#ifdef _ANDROID_
 /*===========================================================================
  * FUNCTION   : getPreviewHalPixelFormat
  *
@@ -7096,7 +7103,7 @@ int QCameraParameters::getPreviewHalPixelFormat() const
     ALOGE("%s: format %d\n", __func__, halPixelFormat);
     return halPixelFormat;
 }
-
+#endif
 /*===========================================================================
  * FUNCTION   : getthumbnailSize
  *
@@ -7724,7 +7731,7 @@ int32_t QCameraParameters::getExifGpsDateTimeStamp(char *gpsDateStamp,
  *==========================================================================*/
 int32_t QCameraParameters::updateFocusDistances(cam_focus_distances_info_t *focusDistances)
 {
-    String8 str;
+    string str;
     char buffer[32] = {0};
     //set all distances to infinity if focus mode is infinity
     if(mFocusMode == CAM_FOCUS_MODE_INFINITY) {
@@ -7737,8 +7744,8 @@ int32_t QCameraParameters::updateFocusDistances(cam_focus_distances_info_t *focu
         snprintf(buffer, sizeof(buffer), ",%f", focusDistances->focus_distance[2]);
         str.append(buffer);
     }
-    ALOGD("%s: setting KEY_FOCUS_DISTANCES as %s", __FUNCTION__, str.string());
-    set(QCameraParameters::KEY_FOCUS_DISTANCES, str.string());
+    ALOGD("%s: setting KEY_FOCUS_DISTANCES as %s", __FUNCTION__, str.c_str());
+    set(QCameraParameters::KEY_FOCUS_DISTANCES, str.c_str());
     return NO_ERROR;
 }
 
@@ -8474,7 +8481,11 @@ int32_t QCameraParameters::commitGetBatch()
  *==========================================================================*/
 int32_t QCameraParameters::updateParamEntry(const char *key, const char *value)
 {
-    m_tempMap.replaceValueFor(String8(key), String8(value));
+#ifdef _ANDROID_
+    m_tempMap.replaceValueFor(string(key), string(value));
+#else
+    m_tempMap[string(key)] = string(value);
+#endif
     return NO_ERROR;
 }
 
@@ -8491,13 +8502,23 @@ int32_t QCameraParameters::updateParamEntry(const char *key, const char *value)
  *==========================================================================*/
 int32_t QCameraParameters::commitParamChanges()
 {
+#ifndef _ANDROID_
     size_t size = m_tempMap.size();
+    map<string, string>::iterator iter;
+    for (iter = m_tempMap.begin(); iter != m_tempMap.end(); iter++) {
+        string k, v;
+        k = iter->first;
+        v = iter->second;
+        set(k, v);
+    }
+#else
     for (size_t i = 0; i < size; i++) {
-        String8 k, v;
+        string k, v;
         k = m_tempMap.keyAt(i);
         v = m_tempMap.valueAt(i);
         set(k, v);
     }
+#endif
     m_tempMap.clear();
 
     // update local changes
diff --git a/QCamera2/HAL/QCameraParameters.h b/QCamera2/HAL/QCameraParameters.h
index bdf2f25..f979405 100644
--- a/QCamera2/HAL/QCameraParameters.h
+++ b/QCamera2/HAL/QCameraParameters.h
@@ -19,8 +19,6 @@
 #ifndef ANDROID_HARDWARE_QCAMERA_PARAMETERS_H
 #define ANDROID_HARDWARE_QCAMERA_PARAMETERS_H
 
-#include <camera/CameraParameters.h>
-#include <cutils/properties.h>
 #include <hardware/camera.h>
 #include <stdlib.h>
 #include <utils/Errors.h>
@@ -28,6 +26,21 @@
 #include "QCameraMem.h"
 #include "QCameraThermalAdapter.h"
 
+#ifdef _ANDROID_
+#include <cutils/properties.h>
+#include <camera/CameraParameters.h>
+#else
+#include "CameraParameters.h"
+#include "android_adapter.h"
+#endif
+
+#include <string>
+#include <map>
+using namespace std;
+
+#include "glib.h"
+#define strlcpy g_strlcpy
+
 extern "C" {
 #include <mm_jpeg_interface.h>
 }
@@ -112,7 +125,7 @@ class QCameraParameters: public CameraParameters
 {
 public:
     QCameraParameters();
-    QCameraParameters(const String8 &params);
+    QCameraParameters(const string &params);
     ~QCameraParameters();
 
     // Supported PREVIEW/RECORDING SIZES IN HIGH FRAME RATE recording, sizes in pixels.
@@ -475,7 +488,7 @@ public:
     QCameraReprocScaleParam m_reprocScaleParam;
     static const QCameraMap EFFECT_MODES_MAP[];
 
-    void getSupportedHfrSizes(Vector<Size> &sizes);
+    void getSupportedHfrSizes(vector<Size> &sizes);
     void setPreviewFrameRateMode(const char *mode);
     const char *getPreviewFrameRateMode() const;
     void setTouchIndexAec(int x, int y);
@@ -492,7 +505,9 @@ public:
     int32_t initDefaultParameters();
     int32_t updateParameters(QCameraParameters&, bool &needRestart);
     int32_t commitParameters();
+#ifdef _ANDROID_
     int getPreviewHalPixelFormat() const;
+#endif
     int32_t getStreamRotation(cam_stream_type_t streamType,
                                cam_pp_feature_config_t &featureConfig,
                                cam_dimension_t &dim);
@@ -718,26 +733,26 @@ private:
 
     int32_t parse_pair(const char *str, int *first, int *second,
                        char delim, char **endptr);
-    void parseSizesList(const char *sizesStr, Vector<Size> &sizes);
+    void parseSizesList(const char *sizesStr, vector<Size> &sizes);
     int32_t parseNDimVector(const char *str, int *num, int N, char delim);
     int32_t parseCameraAreaString(const char *str, int max_num_areas,
                                   cam_area_t *pAreas, int& num_areas_found);
     bool validateCameraAreas(cam_area_t *areas, int num_areas);
     int parseGPSCoordinate(const char *coord_str, rat_t *coord);
     int32_t getRational(rat_t *rat, int num, int denom);
-    String8 createSizesString(const cam_dimension_t *sizes, int len);
-    String8 createValuesString(const int *values, int len,
+    string createSizesString(const cam_dimension_t *sizes, int len);
+    string createValuesString(const int *values, int len,
                                const QCameraMap *map, int map_len);
-    String8 createValuesStringFromMap(const QCameraMap *map,
+    string createValuesStringFromMap(const QCameraMap *map,
                                       int map_len);
-    String8 createHfrValuesString(const cam_hfr_info_t *values, int len,
+    string createHfrValuesString(const cam_hfr_info_t *values, int len,
                                   const QCameraMap *map, int map_len);
-    String8 createHfrSizesString(const cam_hfr_info_t *values, int len);
-    String8 createFpsRangeString(const cam_fps_range_t *fps,
+    string createHfrSizesString(const cam_hfr_info_t *values, int len);
+    string createFpsRangeString(const cam_fps_range_t *fps,
                                  int len,
                                  int &default_fps_index);
-    String8 createFpsString(cam_fps_range_t &fps);
-    String8 createZoomRatioValuesString(int *zoomRatios, int length);
+    string createFpsString(cam_fps_range_t &fps);
+    string createZoomRatioValuesString(int *zoomRatios, int length);
     int lookupAttr(const QCameraMap arr[], int len, const char *name);
     const char *lookupNameByValue(const QCameraMap arr[], int len, int value);
 
@@ -826,7 +841,7 @@ private:
     int32_t m_curCCT;
     int32_t m_curFocusPos;
 
-    DefaultKeyedVector<String8,String8> m_tempMap; // map for temororily store parameters to be set
+    map<string,string> m_tempMap; // map for temororily store parameters to be set
     cam_fps_range_t m_default_fps_range;
 
     bool m_bAFBracketingOn;
diff --git a/QCamera2/HAL/QCameraPostProc.cpp b/QCamera2/HAL/QCameraPostProc.cpp
index 686dbf3..f8aff7a 100644
--- a/QCamera2/HAL/QCameraPostProc.cpp
+++ b/QCamera2/HAL/QCameraPostProc.cpp
@@ -220,7 +220,6 @@ int32_t QCameraPostProcessor::start(QCameraChannel *pSrcChannel)
             return rc;
         }
     }
-
     property_get("persist.camera.longshot.save", prop, "0");
     mUseSaveProc = atoi(prop) > 0 ? true : false;
 
@@ -1046,9 +1045,9 @@ void QCameraPostProcessor::releaseNotifyData(void *user_data,
              app_cb->release_data.unlinkFile &&
              ( NO_ERROR != cb_status ) ) {
 
-            String8 unlinkPath((const char *) app_cb->release_data.data->data,
+            string unlinkPath((const char *) app_cb->release_data.data->data,
                                 app_cb->release_data.data->size);
-            int rc = unlink(unlinkPath.string());
+            int rc = unlink(unlinkPath.c_str());
             ALOGD("%s : Unlinking stored file rc = %d",
                   __func__,
                   rc);
diff --git a/QCamera2/HAL/QCameraThermalAdapter.cpp b/QCamera2/HAL/QCameraThermalAdapter.cpp
index abdae3e..a9ca7ef 100644
--- a/QCamera2/HAL/QCameraThermalAdapter.cpp
+++ b/QCamera2/HAL/QCameraThermalAdapter.cpp
@@ -40,6 +40,7 @@ using namespace android;
 
 namespace qcamera {
 
+const char* THERMAL_CLIENT_LIB_NAME = "libthermalclient.so.0";
 
 QCameraThermalAdapter& QCameraThermalAdapter::getInstance()
 {
@@ -63,7 +64,7 @@ int QCameraThermalAdapter::init(QCameraThermalCallback *thermalCb)
     int rc = NO_ERROR;
 
     ALOGV("%s E", __func__);
-    mHandle = dlopen("/vendor/lib/libthermalclient.so", RTLD_NOW);
+    mHandle = dlopen(THERMAL_CLIENT_LIB_NAME, RTLD_NOW);
     if (!mHandle) {
         error = dlerror();
         ALOGE("%s: dlopen failed with error %s",
diff --git a/QCamera2/stack/common/cam_list.h b/QCamera2/stack/common/cam_list.h
old mode 100755
new mode 100644
index 36379af..959ee57
--- a/QCamera2/stack/common/cam_list.h
+++ b/QCamera2/stack/common/cam_list.h
@@ -33,6 +33,9 @@
 #ifndef __CAMLIST_H
 #define __CAMLIST_H
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 #include <stddef.h>
 
 #define member_of(ptr, type, member) ({ \
@@ -80,4 +83,8 @@ static inline void cam_list_del_node(struct cam_list *ptr)
   ptr->prev = ptr;
 }
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* __CAMLIST_H */
diff --git a/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c b/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c
old mode 100755
new mode 100644
index 290d1e1..ce0a72e
--- a/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c
+++ b/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c
@@ -39,6 +39,7 @@
 #include <stdint.h>
 #include <media/msm_cam_sensor.h>
 #include <stdlib.h>
+#include <stdio.h>
 
 #ifdef _ANDROID_
 #include <cutils/properties.h>
diff --git a/QCamera2/util/QCameraCmdThread.cpp b/QCamera2/util/QCameraCmdThread.cpp
index a3fe103..5111370 100644
--- a/QCamera2/util/QCameraCmdThread.cpp
+++ b/QCamera2/util/QCameraCmdThread.cpp
@@ -28,8 +28,14 @@
 */
 
 #include <utils/Errors.h>
+#ifdef _ANDROID_
 #include <utils/Log.h>
+#else
+#include "android_adapter.h"
+#include "CameraParameters.h"
+#endif
 #include "QCameraCmdThread.h"
+#include <cstdlib>
 
 using namespace android;
 
diff --git a/QCamera2/util/QCameraQueue.cpp b/QCamera2/util/QCameraQueue.cpp
index 4c6585d..5b1b206 100644
--- a/QCamera2/util/QCameraQueue.cpp
+++ b/QCamera2/util/QCameraQueue.cpp
@@ -27,9 +27,14 @@
 *
 */
 
+#ifdef _ANDROID_
 #include <utils/Errors.h>
 #include <utils/Log.h>
+#else
+#include "android_adapter.h"
+#endif
 #include "QCameraQueue.h"
+#include <cstdlib>
 
 namespace qcamera {
 
diff --git a/QCameraParameters.h b/QCameraParameters.h
deleted file mode 100644
index dd29dda..0000000
--- a/QCameraParameters.h
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
-**
-** Copyright 2008, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-#ifndef ANDROID_HARDWARE_QCAMERA_PARAMETERS_H
-#define ANDROID_HARDWARE_QCAMERA_PARAMETERS_H
-
-//#include <utils/KeyedVector.h>
-//#include <utils/String8.h>
-#include <camera/CameraParameters.h>
-
-namespace android {
-
-struct FPSRange{
-    int minFPS;
-    int maxFPS;
-    FPSRange(){
-        minFPS=0;
-        maxFPS=0;
-    };
-    FPSRange(int min,int max){
-        minFPS=min;
-        maxFPS=max;
-    };
-};
-class QCameraParameters: public CameraParameters
-{
-public:
-#if 1
-    QCameraParameters() : CameraParameters() {};
-    QCameraParameters(const String8 &params): CameraParameters(params) {};
-    #else
-    QCameraParameters() : CameraParameters() {};
-    QCameraParameters(const String8 &params) { unflatten(params); }
-#endif
-    ~QCameraParameters();
-
-    // Supported PREVIEW/RECORDING SIZES IN HIGH FRAME RATE recording, sizes in pixels.
-    // Example value: "800x480,432x320". Read only.
-    static const char KEY_SUPPORTED_HFR_SIZES[];
-    // The mode of preview frame rate.
-    // Example value: "frame-rate-auto, frame-rate-fixed".
-    static const char KEY_PREVIEW_FRAME_RATE_MODE[];
-    static const char KEY_SUPPORTED_PREVIEW_FRAME_RATE_MODES[];
-    static const char KEY_PREVIEW_FRAME_RATE_AUTO_MODE[];
-    static const char KEY_PREVIEW_FRAME_RATE_FIXED_MODE[];
-
-    static const char KEY_SKIN_TONE_ENHANCEMENT[] ;
-    static const char KEY_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES[] ;
-
-    //Touch Af/AEC settings.
-    static const char KEY_TOUCH_AF_AEC[];
-    static const char KEY_SUPPORTED_TOUCH_AF_AEC[];
-    //Touch Index for AEC.
-    static const char KEY_TOUCH_INDEX_AEC[];
-    //Touch Index for AF.
-    static const char KEY_TOUCH_INDEX_AF[];
-    // Current auto scene detection mode.
-    // Example value: "off" or SCENE_DETECT_XXX constants. Read/write.
-    static const char KEY_SCENE_DETECT[];
-    // Supported auto scene detection settings.
-    // Example value: "off,backlight,snow/cloudy". Read only.
-    static const char KEY_SUPPORTED_SCENE_DETECT[];
-	   // Returns true if video snapshot is supported. That is, applications
-    static const char KEY_FULL_VIDEO_SNAP_SUPPORTED[];
-    static const char KEY_POWER_MODE_SUPPORTED[];
-
-    static const char KEY_ISO_MODE[];
-    static const char KEY_SUPPORTED_ISO_MODES[];
-    static const char KEY_LENSSHADE[] ;
-    static const char KEY_SUPPORTED_LENSSHADE_MODES[] ;
-
-    static const char KEY_AUTO_EXPOSURE[];
-    static const char KEY_SUPPORTED_AUTO_EXPOSURE[];
-
-    static const char KEY_GPS_LATITUDE_REF[];
-    static const char KEY_GPS_LONGITUDE_REF[];
-    static const char KEY_GPS_ALTITUDE_REF[];
-    static const char KEY_GPS_STATUS[];
-    static const char KEY_EXIF_DATETIME[];
-    static const char KEY_MEMORY_COLOR_ENHANCEMENT[];
-    static const char KEY_SUPPORTED_MEM_COLOR_ENHANCE_MODES[];
-
-
-    static const char KEY_POWER_MODE[];
-
-    static const char KEY_ZSL[];
-    static const char KEY_SUPPORTED_ZSL_MODES[];
-
-    static const char KEY_CAMERA_MODE[];
-
-    static const char KEY_VIDEO_HIGH_FRAME_RATE[];
-    static const char KEY_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES[];
-    static const char KEY_HIGH_DYNAMIC_RANGE_IMAGING[];
-    static const char KEY_SUPPORTED_HDR_IMAGING_MODES[];
-    static const char KEY_AE_BRACKET_HDR[];
-
-
-    // DENOISE
-    static const char KEY_DENOISE[];
-    static const char KEY_SUPPORTED_DENOISE[];
-
-    //Selectable zone AF.
-    static const char KEY_SELECTABLE_ZONE_AF[];
-    static const char KEY_SUPPORTED_SELECTABLE_ZONE_AF[];
-
-    //Face Detection
-    static const char KEY_FACE_DETECTION[];
-    static const char KEY_SUPPORTED_FACE_DETECTION[];
-
-    //Redeye Reduction
-    static const char KEY_REDEYE_REDUCTION[];
-    static const char KEY_SUPPORTED_REDEYE_REDUCTION[];
-    static const char EFFECT_EMBOSS[];
-    static const char EFFECT_SKETCH[];
-    static const char EFFECT_NEON[];
-
-    // Values for Touch AF/AEC
-    static const char TOUCH_AF_AEC_OFF[] ;
-    static const char TOUCH_AF_AEC_ON[] ;
-    static const char SCENE_MODE_ASD[];
-    static const char SCENE_MODE_BACKLIGHT[];
-    static const char SCENE_MODE_FLOWERS[];
-    static const char SCENE_MODE_AR[];
-    static const char SCENE_MODE_HDR[];
-	static const char SCENE_DETECT_OFF[];
-    static const char SCENE_DETECT_ON[];
-    static const char PIXEL_FORMAT_YUV420SP_ADRENO[]; // ADRENO
-	static const char PIXEL_FORMAT_RAW[];
-    static const char PIXEL_FORMAT_YV12[]; // NV12
-    static const char PIXEL_FORMAT_NV12[]; //NV12
-    // Normal focus mode. Applications should call
-    // CameraHardwareInterface.autoFocus to start the focus in this mode.
-    static const char FOCUS_MODE_NORMAL[];
-    static const char ISO_AUTO[];
-    static const char ISO_HJR[] ;
-    static const char ISO_100[];
-    static const char ISO_200[] ;
-    static const char ISO_400[];
-    static const char ISO_800[];
-    static const char ISO_1600[];
-    // Values for Lens Shading
-    static const char LENSSHADE_ENABLE[] ;
-    static const char LENSSHADE_DISABLE[] ;
-
-    // Values for auto exposure settings.
-    static const char AUTO_EXPOSURE_FRAME_AVG[];
-    static const char AUTO_EXPOSURE_CENTER_WEIGHTED[];
-    static const char AUTO_EXPOSURE_SPOT_METERING[];
-
-    static const char KEY_SHARPNESS[];
-    static const char KEY_MAX_SHARPNESS[];
-    static const char KEY_CONTRAST[];
-    static const char KEY_MAX_CONTRAST[];
-    static const char KEY_SATURATION[];
-    static const char KEY_MAX_SATURATION[];
-
-    static const char KEY_HISTOGRAM[] ;
-    static const char KEY_SUPPORTED_HISTOGRAM_MODES[] ;
-    // Values for HISTOGRAM
-    static const char HISTOGRAM_ENABLE[] ;
-    static const char HISTOGRAM_DISABLE[] ;
-
-    // Values for SKIN TONE ENHANCEMENT
-    static const char SKIN_TONE_ENHANCEMENT_ENABLE[] ;
-    static const char SKIN_TONE_ENHANCEMENT_DISABLE[] ;
-
-    // Values for Denoise
-    static const char DENOISE_OFF[] ;
-    static const char DENOISE_ON[] ;
-
-    // Values for auto exposure settings.
-    static const char SELECTABLE_ZONE_AF_AUTO[];
-    static const char SELECTABLE_ZONE_AF_SPOT_METERING[];
-    static const char SELECTABLE_ZONE_AF_CENTER_WEIGHTED[];
-    static const char SELECTABLE_ZONE_AF_FRAME_AVERAGE[];
-
-    // Values for Face Detection settings.
-    static const char FACE_DETECTION_OFF[];
-    static const char FACE_DETECTION_ON[];
-
-    // Values for MCE settings.
-    static const char MCE_ENABLE[];
-    static const char MCE_DISABLE[];
-
-    // Values for ZSL settings.
-    static const char ZSL_OFF[];
-    static const char ZSL_ON[];
-
-    // Values for HDR Bracketing settings.
-    static const char AE_BRACKET_HDR_OFF[];
-    static const char AE_BRACKET_HDR[];
-    static const char AE_BRACKET[];
-
-    // Values for Power mode settings.
-    static const char LOW_POWER[];
-    static const char NORMAL_POWER[];
-
-    // Values for HFR settings.
-    static const char VIDEO_HFR_OFF[];
-    static const char VIDEO_HFR_2X[];
-    static const char VIDEO_HFR_3X[];
-    static const char VIDEO_HFR_4X[];
-
-    // Values for Redeye Reduction settings.
-    static const char REDEYE_REDUCTION_ENABLE[];
-    static const char REDEYE_REDUCTION_DISABLE[];
-    // Values for HDR settings.
-    static const char HDR_ENABLE[];
-    static const char HDR_DISABLE[];
-
-   // Values for Redeye Reduction settings.
-   // static const char REDEYE_REDUCTION_ENABLE[];
-   // static const char REDEYE_REDUCTION_DISABLE[];
-   // Values for HDR settings.
-   //    static const char HDR_ENABLE[];
-   //    static const char HDR_DISABLE[];
-
-
-   static const char KEY_SINGLE_ISP_OUTPUT_ENABLED[];
-   static const char KEY_SUPPORTED_CAMERA_FEATURES[];
-   static const char KEY_MAX_NUM_REQUESTED_FACES[];
-
-    enum {
-        CAMERA_ORIENTATION_UNKNOWN = 0,
-        CAMERA_ORIENTATION_PORTRAIT = 1,
-        CAMERA_ORIENTATION_LANDSCAPE = 2,
-    };
-    int getOrientation() const;
-    void setOrientation(int orientation);
-    void getSupportedHfrSizes(Vector<Size> &sizes) const;
-    void setPreviewFpsRange(int minFPS,int maxFPS);
-	void setPreviewFrameRateMode(const char *mode);
-    const char *getPreviewFrameRateMode() const;
-    void setTouchIndexAec(int x, int y);
-    void getTouchIndexAec(int *x, int *y) const;
-    void setTouchIndexAf(int x, int y);
-    void getTouchIndexAf(int *x, int *y) const;
-    void getMeteringAreaCenter(int * x, int *y) const;
-
-};
-
-}; // namespace android
-
-#endif
diff --git a/android_adapter.h b/android_adapter.h
new file mode 100644
index 0000000..0146ffd
--- /dev/null
+++ b/android_adapter.h
@@ -0,0 +1,20 @@
+#ifndef ANDROID_ADAPTER_H
+#define ANDROID_ADAPTER_H
+
+#include <string.h>
+#include <syslog.h>
+
+#define PROPERTY_VALUE_MAX 128
+
+#define property_get(name, value_str, default_value) \
+do { \
+    strncpy(value_str, default_value, PROPERTY_VALUE_MAX); \
+} while (0)
+
+#define ALOGE(fmt, args...) syslog(LOG_ERR, fmt, ##args)
+#define ALOGV(fmt, args...) syslog(LOG_INFO, fmt, ##args)
+#define ALOGI(fmt, args...) syslog(LOG_INFO, fmt, ##args)
+#define ALOGD(fmt, args...) syslog(LOG_DEBUG, fmt, ##args)
+
+#endif
+
diff --git a/configure.ac b/configure.ac
index a3d185a..bd57302 100644
--- a/configure.ac
+++ b/configure.ac
@@ -40,11 +40,13 @@ DEBUG_CFLAGS=
 DEBUG_LDFLAGS=
 
 AC_ARG_WITH([sanitized-headers],
-	[AS_HELP_STRING([--with-sanitized-headers=DIR],[location of the sanitized Linux kernel headers])],
-	[CPPFLAGS="$CPPFLAGS -I$withval"; CFLAGS="$CFLAGS -I$withval"])
+	[AS_HELP_STRING([--with-sanitized-headers=DIR],
+	[location of the sanitized Linux kernel headers])],
+	[CPPFLAGS="$CPPFLAGS -I$withval"])
 
 AC_ARG_WITH([additional-include-directives],
-        [AS_HELP_STRING([--with-additional-include-directives=DIR],[additional -I include paths for the C pre-processor])],
+        [AS_HELP_STRING([--with-additional-include-directives=DIR],
+	[additional -I include paths for the C pre-processor])],
         [CPPFLAGS="$CPPFLAGS -I$withval"])
 
 AC_ARG_ENABLE([target],
@@ -94,10 +96,12 @@ AM_CONDITIONAL([BUILD_JPEG], [test "x$BUILD_JPEG" = "xtrue"])
 AC_OUTPUT([ \
   Makefile \
   QCamera2/stack/Makefile \
+  QCamera2/HAL/Makefile \
   QCamera2/stack/mm-camera-interface/Makefile \
   QCamera2/stack/mm-jpeg-interface/Makefile \
   QCamera2/stack/mm-camera-test/Makefile \
   mm-image-codec/Makefile \
   qcamlib/Makefile \
+  libcamera/Makefile \
 ])
 
diff --git a/libcamera/Makefile.am b/libcamera/Makefile.am
new file mode 100644
index 0000000..7d7bc09
--- /dev/null
+++ b/libcamera/Makefile.am
@@ -0,0 +1,41 @@
+ACLOCAL_AMFLAGS = -I m4
+
+## build libcamera ##
+lib_LTLIBRARIES = libcamera.la
+
+include_HEADERS = inc/camera.h
+include_HEADERS += inc/camera_parameters.h
+
+libcamera_la_CXXFLAGS  = -fPIC
+
+libcamera_la_CXXFLAGS += -I src
+libcamera_la_CXXFLAGS += -I inc
+libcamera_la_CXXFLAGS += -I ../QCamera2/HAL
+libcamera_la_CXXFLAGS += -I ../QCamera2/util
+libcamera_la_CXXFLAGS += -I ../QCamera2/stack/common
+libcamera_la_CXXFLAGS += -I ../mm-image-codec/qomx_core
+libcamera_la_CXXFLAGS += -I ../mm-image-codec/qexif
+
+
+libcamera_la_SOURCES  = src/qcamera2.cpp
+libcamera_la_SOURCES += src/camera_memory.cpp
+libcamera_la_SOURCES += src/camera_parameters.cpp
+# TODO: copy this file to src
+libcamera_la_SOURCES += ../QCamera2/HAL/CameraParameters.cpp
+
+libcamera_la_LDFLAGS = -shared
+libcamera_la_LIBADD = -ldl -lrt
+
+## build camera-test ##
+
+bin_PROGRAMS = camera-test
+
+camera_test_CXXFLAGS  = -I inc
+camera_test_CXXFLAGS += -I src
+camera_test_CXXFLAGS += -I test
+camera_test_CXXFLAGS += -I ../QCamera2/HAL
+
+#camera_test_SOURCES = test/libcamera_test.cpp
+camera_test_SOURCES = test/camera_test.cpp
+
+camera_test_LDADD = libcamera.la
diff --git a/libcamera/inc/camera.h b/libcamera/inc/camera.h
new file mode 100644
index 0000000..138a4a5
--- /dev/null
+++ b/libcamera/inc/camera.h
@@ -0,0 +1,350 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __CAMERA_H__
+#define __CAMERA_H__
+
+
+#include <stdint.h>
+#include <string>
+#include <vector>
+#include <ostream>
+
+#ifndef DISALLOW_COPY_AND_ASSIGN
+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
+  TypeName(const TypeName&);               \
+  void operator=(const TypeName&)
+#endif
+
+namespace camera
+{
+
+/**
+ * Type of image frame received from the camera
+ */
+enum FrameType
+{
+    /**
+     * frame type for preview stream
+     */
+    CAMERA_FRAME_PREVIEW,
+    /**
+     * frame type for video stream
+     */
+    CAMERA_FRAME_VIDEO,
+};
+
+/**
+ * Type of control event received from camera
+ */
+enum EventType
+{
+    CAMERA_EVT_NONE = 0x0000,
+    CAMERA_EVT_FOCUS = 0x0001,
+    CAMERA_EVT_ALL = 0xFFFF,
+};
+
+/**
+ * data structure to represent a single control event
+ **/
+struct ControlEvent
+{
+    int ext1;
+    int ext2;
+    EventType type;
+};
+
+/**
+ * Interface to an object that represents single image/metadata
+ * frame
+ */
+class ICameraFrame
+{
+    DISALLOW_COPY_AND_ASSIGN(ICameraFrame);
+protected:
+    uint32_t refs_;
+
+    ICameraFrame() : refs_(1) {}
+    virtual ~ICameraFrame() {}
+
+public:
+
+    /**
+     * aquire a reference to the frame, this is required if client
+     * wants to hold the frame for further processing after camera
+     * callback returns
+     *
+     * @return uint32_t : number of refs to the frame.
+     */
+    virtual uint32_t acquireRef() = 0;
+
+    /**
+     * release reference to the frame object. This will release
+     * memory associated with image data as well.
+     *
+     * @return uint32_t : number of refs to the frame
+     */
+    virtual uint32_t releaseRef() = 0;
+
+    /**
+     * frame timestamp
+     */
+    uint64_t timeStamp;
+
+    /**
+     * frame data size in bytes
+     */
+    uint32_t size;
+
+    /**
+     * pointer to start of image data
+     */
+    uint8_t* data;
+
+    /**
+     * frame type
+     */
+    FrameType type;
+};
+
+/**
+ * Interface to a parameters object.
+ */
+class ICameraParameters
+{
+public:
+    /**
+     * Get serialized representation of the parameter object in a
+     * ostream
+     *
+     * @param ps : reference to an ostream object
+     *
+     * @return int : 0 on success
+     */
+    virtual int writeObject(std::ostream& ps) const = 0;
+};
+
+/**
+ * Interface for camera listener object. Client needs to
+ * implement this interface to get access to camera data and
+ * control events. The methods in listener can be invoked from
+ * multiple different threads. Client needs to make sure that
+ * implementation is thread-safe.
+ */
+class ICameraListener
+{
+public:
+
+    virtual ~ICameraListener() {}
+
+    /**
+     * This function is called when an error is generated by camera
+     * driver
+     */
+    virtual void onError() {}
+
+    /**
+     * This function is called when a control event needs to be
+     * delivered to a client.
+     *
+     * @param control [in]: control event object
+     */
+    virtual void onControl(const ControlEvent& control) {}
+
+    /**
+     * This function is called when a preview frame is generated by
+     * camera.
+     *
+     * @param frame [in]: pointer to an existing ICameraFrame
+     *              generated by camera
+     */
+    virtual void onPreviewFrame(ICameraFrame *frame) {}
+
+    /**
+     * This function is called when a preview frame is generated by
+     * camera.
+     *
+     * @param frame [in]: pointer to an existing ICameraFrame
+     *              generated by camera
+     */
+    virtual void onVideoFrame(ICameraFrame *frame) {}
+
+    /**
+     * This function is called when a metadata frame is generated by
+     * camera.
+     *
+     * @param frame [in]: pointer to an existing ICameraFrame
+     *              generated by camera
+     */
+    virtual void onMetadataFrame(ICameraFrame *frame) {}
+};
+
+/**
+ * Interface to a camera device. Client uses the API provided by
+ * this interface to interact with camera device.
+ */
+class ICameraDevice
+{
+    DISALLOW_COPY_AND_ASSIGN(ICameraDevice);
+protected:
+    ICameraDevice() {}
+    virtual ~ICameraDevice() {}
+
+public:
+
+    /**
+     * Factory method to create an instance of ICameraDevice
+     *
+     * @param index [in]: camera ID
+     * @param device [out]: pointer to to a ICameraDevice* to be
+     *               created
+     *
+     * @return int : 0 on Success
+     */
+    static int createInstance(int index, ICameraDevice** device);
+
+    /**
+     * delete instance of an ICameraDevice
+     *
+     * @param device [out]: pointer to an ICameraDevice* to be
+     *               deleted
+     */
+    static void deleteInstance(ICameraDevice** device);
+
+    /**
+     * Add listener to handle various notifications and data frames from the
+     * camera device.
+     * @param listener [in]
+     **/
+    virtual void addListener(ICameraListener *listener) = 0;
+
+    /**
+     * Removes a previously added listener from camera device
+     *
+     * @param listener [in]
+     */
+    virtual void removeListener(ICameraListener *listener) = 0;
+
+    /**
+     * Subscribe for camera control events
+     *
+     * @param eventMask : is a bitmask of values in enum EventType
+     * @return int : 0 on success
+     **/
+    virtual void subscribe(uint32_t eventMask) = 0;
+
+    /**
+     * Unsubscribe to previously subscribed control events.
+     *
+     * @param eventMask : is a bitmask of values in enum EventType
+     * @return int : 0 on success
+     **/
+    virtual void unsubscribe(uint32_t eventMask) = 0;
+
+    /**
+     * Set parameters in camera device. Camera device state will be
+     * updated with new settings when this call returns.
+     *
+     * @param params [in]: populated parameters object with new
+     *               camera parameters to be set
+     *
+     * @return int : 0 on success
+     */
+    virtual int setParameters(const ICameraParameters& params) = 0;
+
+    /**
+     * Retrieve the octet stream of parameters as name,value pairs. Note the
+     * parameters fetched in to be buffer may be partial to the extent of bufSize.
+     * Use the bufSizeRequired to determine the total length of buffer needed to
+     * get all the parameters.
+     *
+     * @param buf [out]: buffer will be populated with the octet stream of
+     *            parameters.
+     * @param bufSize [in]: sizeof memory at buf.
+     * @param bufSizeRequired [out]: optional if provided will be populated
+     * with total size of buffer needed to fetch all the parameters.
+     *
+     * @return int : 0 on success
+     **/
+    virtual int getParameters(uint8_t* buf, uint32_t bufSize,
+                              int* bufSizeRequired = NULL) = 0;
+
+    /**
+     * Start preview stream on camera
+     *
+     * @return int : 0 on success
+     */
+    virtual int startPreview() = 0;
+
+    /**
+     * Stop preview streaming
+     */
+    virtual void stopPreview() = 0;
+
+    /**
+     * Start video recording stream
+     *
+     * @return int : 0 on success
+     */
+    virtual int startRecording() = 0;
+
+    /**
+     * Stop video recording
+     */
+    virtual void stopRecording() = 0;
+};
+
+/**
+ * Structure to hold information about a single camera
+ * device
+ */
+struct CameraInfo {
+    int func;
+};
+
+/**
+ * Get the number of camera (sensors) detected on the device.
+ *
+ * @return int
+ **/
+int getNumberOfCameras();
+
+/**
+ * Get the additional information about camera by index. index 0 identifies
+ * the first camera.
+ *
+ * @param idx : index of the camera device. index 0 identifies first
+ *            camera.
+ * @param info
+ * @return int : 0 is success
+ **/
+int getCameraInfo(int idx, struct CameraInfo& info);
+
+} /* namespace camera */
+
+#endif  /* !__CAMERA_H__ */
diff --git a/libcamera/inc/camera_parameters.h b/libcamera/inc/camera_parameters.h
new file mode 100644
index 0000000..a994039
--- /dev/null
+++ b/libcamera/inc/camera_parameters.h
@@ -0,0 +1,414 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef __CAMERA_PARAMETERS_H__
+#define __CAMERA_PARAMETERS_H__
+
+#include <vector>
+#include <string>
+
+#include "camera.h"
+
+namespace camera
+{
+
+/**
+ * Image frame dimensions
+ */
+struct ImageSize
+{
+    int width;  /*!< Image width in pixels */
+    int height; /*!< Image height in pixels */
+
+    ImageSize() : width(0), height(0) {}
+    ImageSize(int w, int h) : width(w), height(h) {}
+};
+
+/**
+ * Structure for storing values for ranged parameters such as
+ * brightness, contrast, fps etc.
+ */
+struct Range
+{
+    int min;    /*!< minimum value */
+    int max;    /*!< maximum value */
+    int step;   /*!< step increment for intermediate values */
+};
+
+/**
+ * Available values for video FPS
+ */
+enum VideoFPS
+{
+    VIDEO_FPS_30 = 30,   /*!< 30fps regular framerate mode */
+    VIDEO_FPS_60 = 60,   /*!< 60fps High framerate mode */
+    VIDEO_FPS_90 = 90,   /*!< 90fps High framerate mode */
+    VIDEO_FPS_120 = 120, /*!< 120fps High framerate mode */
+    VIDEO_FPS_150 = 150, /*!< 150fps High framerate mode */
+};
+
+/* focus mode values */
+const std::string FOCUS_MODE_AUTO = "auto";
+const std::string FOCUS_MODE_INFINITY = "infinity";
+const std::string FOCUS_MODE_MACRO = "macro";
+const std::string FOCUS_MODE_FIXED = "fixed";
+const std::string FOCUS_MODE_EDOF = "edof";
+const std::string FOCUS_MODE_CONTINUOUS_VIDEO = "continuous-video";
+const std::string FOCUS_MODE_CONTINUOUS_PICTURE = "continuous-picture";
+const std::string FOCUS_MODE_MANUAL_POSITION = "manual";
+
+/* ISO values */
+const std::string ISO_AUTO = "auto";
+const std::string ISO_HJR = "ISO_HJR";
+const std::string ISO_100 = "ISO100";
+const std::string ISO_200 = "ISO200";
+const std::string ISO_400 = "ISO400";
+const std::string ISO_800 = "ISO800";
+const std::string ISO_1600 = "ISO1600";
+const std::string ISO_3200 = "ISO3200";
+
+/* White Balance values */
+const std::string WHITE_BALANCE_AUTO = "auto";
+const std::string WHITE_BALANCE_INCANDESCENT = "incandescent";
+const std::string WHITE_BALANCE_FLUORESCENT = "fluorescent";
+const std::string WHITE_BALANCE_WARM_FLUORESCENT = "warm-fluorescent";
+const std::string WHITE_BALANCE_DAYLIGHT = "daylight";
+const std::string WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";
+const std::string WHITE_BALANCE_TWILIGHT = "twilight";
+const std::string WHITE_BALANCE_SHADE = "shade";
+const std::string WHITE_BALANCE_MANUAL_CCT = "manual-cct";
+
+class CameraParams : public ICameraParameters
+{
+public:
+
+    CameraParams();
+
+    virtual ~CameraParams();
+
+    /**
+     * initialize the object by getting current state of parameters
+     * from device.
+     *
+     * @param device : A valid camera device object
+     *
+     * @return int : 0 on success
+     */
+    int init(ICameraDevice* device);
+
+    virtual int writeObject(std::ostream& ps) const;
+
+    /**
+     * get a string representation of the object
+     *
+     * @return std::string
+     */
+    std::string toString() const;
+
+    /**
+     * Updates the current state of the parameters to camera device.
+     * Fails for any invalid entries.
+     *
+     * @return int : 0 on success
+     */
+    int commit();
+
+    /**
+     * get preview sizes supported by the camera
+     *
+     * @return std::vector<ImageSize> : list of preview sizes
+     */
+    std::vector<ImageSize> getSupportedPreviewSizes() const;
+
+    /**
+     * set preview size
+     *
+     * @param size
+     */
+    void setPreviewSize(const ImageSize& size);
+
+    /**
+     * get current preview size
+     *
+     * @return ImageSize
+     */
+    ImageSize getPreviewSize() const;
+
+    /**
+     * get video sizes supported by the camera
+     *
+     * @return std::vector<ImageSize> : list of video sizes
+     */
+    std::vector<ImageSize> getSupportedVideoSizes() const;
+
+    /**
+     * get current video size
+     *
+     * @return ImageSize
+     */
+    ImageSize getVideoSize() const;
+
+    /**
+     * set video size
+     *
+     * @param size
+     */
+    void setVideoSize(const ImageSize& size);
+
+    /**
+     * generic get function to get string representation of value of
+     * a parameter using a key.
+     *
+     * @param key [in]
+     *
+     * @return std::string : value
+     */
+    virtual std::string get(const std::string& key) const;
+
+    /**
+     * generic set function to set value of a parameter using
+     * key-value pair
+     *
+     * @param key [in]
+     * @param value [in]
+     */
+    virtual void set(const std::string& key, const std::string& value);
+
+    /**
+     * get a list of supported focus modes
+     *
+     * @return vector<string> : focus mode values
+     */
+    std::vector<std::string> getSupportedFocusModes() const;
+
+    /**
+     * get current value of focus mode
+     *
+     * @return std::string
+     */
+    std::string getFocusMode() const;
+
+    /**
+     * set focus mode value
+     *
+     * @param value
+     */
+    void setFocusMode(const std::string& value);
+
+    /**
+     * get a list of supported whitebalance modes
+     *
+     * @return vector<string> : whitebalance values
+     */
+    std::vector<std::string> getSupportedWhiteBalance() const;
+
+    /**
+     * get current value of whitebalance mode
+     *
+     * @return std::string
+     */
+    std::string getWhiteBalance() const;
+
+    /**
+     * set whitebalance mode value
+     *
+     * @param value
+     */
+    void setWhiteBalance(const std::string& value);
+
+    /**
+     * get a list of supported ISO modes
+     *
+     * @return vector<string> : ISO values
+     */
+    std::vector<std::string> getSupportedISO() const;
+
+    /**
+     * get current value of ISO mode
+     *
+     * @return std::string
+     */
+    std::string getISO() const;
+
+    /**
+     * set ISO mode value
+     *
+     * @param value
+     */
+    void setISO(const std::string& value);
+
+    /**
+     * get a range of supported sharpness values
+     *
+     * @return Range : sharpness range
+     */
+    Range getSupportedSharpness() const;
+
+    /**
+     * get current sharpness value
+     *
+     * @return int
+     */
+    int getSharpness() const;
+
+    /**
+     * set sharpness value
+     *
+     * @param value
+     */
+    void setSharpness(int value);
+
+    /**
+     * get a range of supported brightness values
+     *
+     * @return Range : brightness range
+     */
+    Range getSupportedBrightness() const;
+
+    /**
+     * get current brightness value
+     *
+     * @return int
+     */
+    int getBrightness() const;
+
+    /**
+     * set brightness value
+     *
+     * @param value
+     */
+    void setBrightness(int value);
+
+    /**
+     * get a range of supported contrast values
+     *
+     * @return Range : contrast range
+     */
+    Range getSupportedContrast() const;
+
+    /**
+     * get current contrast value
+     *
+     * @return int
+     */
+    int getContrast() const;
+
+    /**
+     * set contrast value
+     *
+     * @param value
+     */
+    void setContrast(int value);
+
+    /**
+     * get supported ranges for preview FPS The FPS range has valid
+     * min and max value. Actual fixed point FPS value is calculated
+     * by dividing the min and max values by 1000. For example, max
+     * value of 26123 represents 26.123 fps.
+     *
+     * @return vector<Range> : preview fps ranges
+     */
+    std::vector<Range> getSupportedPreviewFpsRanges() const;
+
+    /**
+     * get current preview fps range value
+     *
+     * @return Range
+     */
+    Range getPreviewFpsRange() const;
+
+    /**
+     * set preview fps range value
+     *
+     * @param value
+     */
+    void setPreviewFpsRange(const Range& value);
+
+    /**
+     * get a list of fixed FPS values for video stream.
+     *
+     * @return vector<VideoFPS> : video fps values
+     */
+    std::vector<VideoFPS> getSupportedVideoFps() const;
+
+    /**
+     * get current video fps mode
+     *
+     * @return VideoFPS
+     */
+    VideoFPS getVideoFPS() const;
+
+    /**
+     * set video fps mode.
+     *
+     * Note: Setting the mode to high framerate will override
+     * preview FPS settings. see \ref VideoFPS for high framerate
+     * values.
+     *
+     * @param VideoFPS
+     */
+    void setVideoFPS(VideoFPS value);
+
+    /**
+     * get a list of supported preview formats
+     *
+     * @return std::vector<std::string>
+     */
+    std::vector<std::string> getSupportedPreviewFormats() const;
+
+    /**
+     * get current preview format
+     *
+     * @return std::string
+     */
+    std::string getPreviewFormat() const;
+
+    /**
+     * set preview format
+     *
+     * @param value
+     */
+    void setPreviewFormat(const std::string& value);
+
+private:
+
+    /**
+     * private implementation and storage handle for parameters
+     */
+    void *priv_;
+
+    /**
+     * handle to attached camera device
+     */
+    ICameraDevice *device_;
+}; /* class CameraParams */
+
+} /* namespace camera */
+
+#endif  /* __CAMERA_PARAMETERS_H__ */
+
diff --git a/libcamera/src/camera_log.h b/libcamera/src/camera_log.h
new file mode 100644
index 0000000..e290eb8
--- /dev/null
+++ b/libcamera/src/camera_log.h
@@ -0,0 +1,53 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __CAMERA_LOG_H__
+#define __CAMERA_LOG_H__
+
+#include <syslog.h>
+#include <stdio.h>
+
+#define CAM_ERR(fmt, args...) do { \
+    syslog(LOG_ERR, "%s:%d ERROR: "fmt, __func__, __LINE__, ##args); \
+} while (0)
+
+#define CAM_DBG(fmt, args...) do { \
+    syslog(LOG_DEBUG, "%s:%d DEBUG: "fmt, __func__, __LINE__, ##args); \
+} while (0)
+
+#define CAM_INFO(fmt, args...) do { \
+    syslog(LOG_INFO, "%s:%d INFO: "fmt, __func__, __LINE__, ##args); \
+} while (0)
+
+#define CAM_PRINT(fmt, args...) do { \
+    fprintf(stderr, "%s:%d, "fmt "\n", __func__, __LINE__, ##args); \
+    syslog(LOG_INFO, "%s:%d PRINT: "fmt, __func__, __LINE__, ##args); \
+} while (0)
+
+#endif
diff --git a/libcamera/src/camera_memory.cpp b/libcamera/src/camera_memory.cpp
new file mode 100644
index 0000000..8b83e8b
--- /dev/null
+++ b/libcamera/src/camera_memory.cpp
@@ -0,0 +1,113 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <sys/mman.h>
+#include <cstdlib>
+#include "camera_memory.h"
+#include "camera_log.h"
+
+namespace camera
+{
+
+/* create a new memory object and map/allocate the buffer */
+CameraMemory::CameraMemory(int fd, uint32_t size)
+{
+    valid_ = false;
+    mem_ = (camera_memory_t*)malloc(sizeof(camera_memory_t));
+    if (mem_ == NULL) {
+        CAM_ERR("malloc() failed");
+        return;
+    }
+    if (fd < 0) {
+        /* allocate new memory */
+        mem_->data = malloc(size);
+        if (mem_->data == NULL) {
+            CAM_ERR("malloc() failed");
+        }
+        type_ = MEM_ALLOCATED;
+    } else {
+        /* map the memory specified by fd using mmap */
+        mem_->data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED,
+                          fd, 0);
+        if (mem_->data == MAP_FAILED) {
+            CAM_ERR("mmap() failed\n");
+        }
+        type_ = MEM_MAPPED;
+    }
+    valid_ = true;
+    mem_->handle = this;
+    mem_->size = size;
+    mem_->release = releaseMemory;
+}
+
+/* unmap/free the buffer and destroy the memory object */
+CameraMemory::~CameraMemory()
+{
+    switch (type_) {
+      case MEM_ALLOCATED:
+          free(mem_->data);
+          break;
+      case MEM_MAPPED:
+          if (munmap(mem_->data, mem_->size) < 0) {
+              CAM_ERR("munmap() failed");
+          }
+          break;
+      default:
+          CAM_ERR("failed, invalid type, %d", type_);
+          break;
+    }
+    free(mem_);
+}
+
+/* function to serve the request_memory_callback from camera HAL */
+camera_memory_t* CameraMemory::requestMemory(int fd, size_t buf_size,
+                                      unsigned int num_bufs,
+                                      void* user)
+{
+    CAM_DBG("");
+    CameraMemory* me = new CameraMemory(fd, buf_size * num_bufs);
+    if (!me || (me && me->valid_ == false)) {
+        CAM_ERR("failed, obj=%p", me);
+        return NULL;
+    }
+    return me->mem_;
+}
+
+/* function to serve the release_memory_callback from camera HAL */
+void CameraMemory::releaseMemory(struct camera_memory* mem)
+{
+    CAM_DBG("");
+    CameraMemory* me = (CameraMemory*) mem->handle;
+    if (!me) {
+        CAM_ERR("failed");
+        return;
+    }
+    delete me;
+}
+
+} /* namespace camera */
diff --git a/libcamera/src/camera_memory.h b/libcamera/src/camera_memory.h
new file mode 100644
index 0000000..2facc1e
--- /dev/null
+++ b/libcamera/src/camera_memory.h
@@ -0,0 +1,65 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <stdint.h>
+#include <hardware/camera.h>
+
+namespace camera
+{
+
+enum MemType
+{
+    MEM_MAPPED,
+    MEM_ALLOCATED,
+    MEM_INVALID,
+};
+
+class CameraMemory
+{
+
+ public:
+    /* create a new memory object and map/allocate the buffer */
+    CameraMemory(int fd, uint32_t size);
+
+    /* unmap/free the buffer and destroy the memory object */
+    ~CameraMemory();
+
+    /* function to serve the request_memory_callback from camera HAL */
+    static camera_memory_t* requestMemory(int fd, size_t buf_size,
+                                          unsigned int num_bufs,
+                                          void* user);
+    /* function to serve the release_memory_callback from camera HAL */
+    static void releaseMemory(struct camera_memory* mem);
+
+ private:
+    bool valid_;
+    camera_memory_t* mem_;
+    MemType type_;
+};
+
+} /* namespace camera */
diff --git a/libcamera/src/camera_parameters.cpp b/libcamera/src/camera_parameters.cpp
new file mode 100644
index 0000000..ca50938
--- /dev/null
+++ b/libcamera/src/camera_parameters.cpp
@@ -0,0 +1,492 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include "CameraParameters.h"
+#include "camera_parameters.h"
+#include "camera_log.h"
+#include "qcamera_extensions.h"
+
+#include <string>
+#include <vector>
+#include <cstdlib>
+#include <errno.h>
+#include <sstream>
+
+using namespace std;
+using namespace android;
+
+namespace camera
+{
+
+static const int VALUE_SIZE_MAX = 32;
+
+/* helper function to cast the private params to CameraParameters */
+inline static CameraParameters* params_cast(void *priv)
+{
+    return static_cast<CameraParameters*> (priv);
+}
+
+/**
+ * parses the comma separated values from a string and returns a
+ * vector of individual strings
+ *
+ * @param valueStr [in] comma separated value string
+ *
+ * @return vector<string>
+ */
+static vector<string> parseCSV(const char *valueStr)
+{
+    vector<string> values;
+    CAM_DBG("valueStr = %s", valueStr);
+
+    string input(valueStr);
+    istringstream ss(input);
+    string token;
+    while(getline(ss, token, ',')) {
+        values.push_back(token);
+    }
+    return values;
+}
+
+/**
+ * parses text within paranthesis and sends a vector of all such
+ * text found.
+ * For example with input  "(10, 20), (15, 30)", it returns
+ * vector with elements "10, 20" and "15, 30"
+ *
+ * @param valueStr
+ *
+ * @return vector<string>
+ */
+static vector<string> parseParanthesis(const char *valueStr)
+{
+    vector<string> values;
+    char *p = (char *) valueStr;
+    char buf[VALUE_SIZE_MAX];
+    int idx = 0;
+
+    while (true) {
+        idx = 0;
+        /* find opening paranthesis */
+        while (*p != '(' && *p != '\0') {
+            p++;
+        }
+        if (*p == '\0') {
+            break;
+        }
+        p++;
+        /* find closing parenthesis */
+        while (*p != ')' && *p != '\0') {
+            buf[idx] = *p;
+            idx++;
+            p++;
+        }
+        if (*p == '\0') {
+            CAM_ERR("parse error: valueStr=%s", valueStr);
+            break;
+        }
+        buf[idx] = '\0';
+        string str(buf);
+        values.push_back(str);
+    }
+    return values;
+}
+
+/**
+ * convert hfr string value to corresponding VideoFPS enum value
+ */
+inline static const char *toHFRMode(VideoFPS fps)
+{
+    if (fps == VIDEO_FPS_30) {
+        return VIDEO_HFR_OFF;
+    }
+    if (fps == VIDEO_FPS_60) {
+        return VIDEO_HFR_2X;
+    }
+    if (fps == VIDEO_FPS_90) {
+        return VIDEO_HFR_3X;
+    }
+    if (fps == VIDEO_FPS_120) {
+        return VIDEO_HFR_4X;
+    }
+    if (fps == VIDEO_FPS_150) {
+        return VIDEO_HFR_5X;
+    }
+}
+
+/**
+ * convert hfr string value to corresponding VideoFPS enum value
+ */
+inline static VideoFPS toVideoFPS(string hfrMode)
+{
+    if (hfrMode == VIDEO_HFR_OFF) {
+        return VIDEO_FPS_30;
+    }
+    if (hfrMode == VIDEO_HFR_2X) {
+        return VIDEO_FPS_60;
+    }
+    if (hfrMode == VIDEO_HFR_3X) {
+        return VIDEO_FPS_90;
+    }
+    if (hfrMode == VIDEO_HFR_4X) {
+        return VIDEO_FPS_120;
+    }
+    if (hfrMode == VIDEO_HFR_5X) {
+        return VIDEO_FPS_150;
+    }
+}
+
+/* writes serialized version of parameters to ostream object
+   provided by the caller*/
+int CameraParams::writeObject(std::ostream& ps) const
+
+{
+    ps << params_cast(priv_)->flatten().c_str();
+    return 0;
+}
+
+CameraParams::CameraParams()
+{
+    priv_ = (void *) new CameraParameters();
+}
+
+int CameraParams::init(ICameraDevice* device)
+{
+    int rc = 0;
+    int paramBufSize = 0;
+    uint8_t* paramBuf = 0;
+
+    rc = device->getParameters(0, 0, &paramBufSize);
+    if (0 != rc) {
+        goto bail;
+    }
+
+    paramBuf = (uint8_t*)calloc(paramBufSize+1, 1);
+    if (0 == paramBuf) {
+        rc = ENOMEM;
+        goto bail;
+    }
+
+    rc = device->getParameters(paramBuf, paramBufSize);
+    if (0 != rc) {
+        goto bail;
+    }
+
+    params_cast(priv_)->unflatten((const char *)paramBuf);
+    device_ = device;
+bail:
+   free(paramBuf);
+   return rc;
+}
+
+CameraParams::~CameraParams()
+{
+    delete params_cast(priv_);
+}
+
+vector<ImageSize> CameraParams::getSupportedPreviewSizes() const
+{
+    vector<Size> sizes;
+    vector<ImageSize> imgSizes;
+    params_cast(priv_)->getSupportedPreviewSizes(sizes);
+    imgSizes.resize(sizes.size());
+
+    for(vector<Size>::size_type i=0; i<sizes.size(); i++) {
+        imgSizes[i].width = sizes[i].width;
+        imgSizes[i].height = sizes[i].height;
+    }
+    return imgSizes;
+}
+
+void CameraParams::setPreviewSize(const ImageSize& size)
+{
+    params_cast(priv_)->setPreviewSize(size.width, size.height);
+}
+
+ImageSize CameraParams::getPreviewSize() const
+{
+    ImageSize size;
+    params_cast(priv_)->getPreviewSize(&size.width, &size.height);
+    return size;
+}
+
+
+vector<ImageSize> CameraParams::getSupportedVideoSizes() const
+{
+    vector<Size> sizes;
+    vector<ImageSize> imgSizes;
+    params_cast(priv_)->getSupportedVideoSizes(sizes);
+    imgSizes.resize(sizes.size());
+
+    for(vector<Size>::size_type i=0; i<sizes.size(); i++) {
+        imgSizes[i].width = sizes[i].width;
+        imgSizes[i].height = sizes[i].height;
+    }
+    return imgSizes;
+}
+
+void CameraParams::setVideoSize(const ImageSize& size)
+{
+    params_cast(priv_)->setVideoSize(size.width, size.height);
+}
+
+ImageSize CameraParams::getVideoSize() const
+{
+    ImageSize size;
+    params_cast(priv_)->getVideoSize(&size.width, &size.height);
+    return size;
+}
+
+int CameraParams::commit()
+{
+    /* set the current state of paramters in camera device */
+    return device_->setParameters(*this);
+}
+
+string CameraParams::get(const string& key) const
+{
+    string str(params_cast(priv_)->get(key.c_str()));
+    return str;
+}
+
+void CameraParams::set(const string& key, const string& value)
+{
+    return params_cast(priv_)->set(key.c_str(), value.c_str());
+}
+
+vector<string> CameraParams::getSupportedFocusModes() const
+{
+    return parseCSV(
+        params_cast(priv_)->get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES));
+}
+
+string CameraParams::getFocusMode() const
+{
+    string str(params_cast(priv_)->get(CameraParameters::KEY_FOCUS_MODE));
+    return str;
+}
+
+void CameraParams::setFocusMode(const string& value)
+{
+    params_cast(priv_)->set(CameraParameters::KEY_FOCUS_MODE, value);
+}
+
+vector<string> CameraParams::getSupportedWhiteBalance() const
+{
+    return parseCSV(
+        params_cast(priv_)->get(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE));
+}
+
+string CameraParams::getWhiteBalance() const
+{
+    string str(params_cast(priv_)->get(CameraParameters::KEY_WHITE_BALANCE));
+    return str;
+}
+
+void CameraParams::setWhiteBalance(const string& value)
+{
+    params_cast(priv_)->set(CameraParameters::KEY_WHITE_BALANCE, value);
+}
+
+vector<string> CameraParams::getSupportedISO() const
+{
+    return parseCSV(
+        params_cast(priv_)->get(KEY_QC_SUPPORTED_ISO_MODES));
+}
+
+string CameraParams::getISO() const
+{
+    string str(params_cast(priv_)->get(KEY_QC_ISO_MODE));
+    return str;
+}
+
+void CameraParams::setISO(const string& value)
+{
+    params_cast(priv_)->set(KEY_QC_ISO_MODE, value);
+}
+
+Range CameraParams::getSupportedSharpness() const
+{
+    Range range;
+    range.min =
+        params_cast(priv_)->getInt(KEY_QC_MIN_SHARPNESS);
+    range.max =
+        params_cast(priv_)->getInt(KEY_QC_MAX_SHARPNESS);
+    range.step =
+        params_cast(priv_)->getInt(KEY_QC_SHARPNESS_STEP);
+    return range;
+}
+
+int CameraParams::getSharpness() const
+{
+    return params_cast(priv_)->getInt(KEY_QC_SHARPNESS);
+}
+
+void CameraParams::setSharpness(int value)
+{
+    char valStr[VALUE_SIZE_MAX];
+    snprintf(valStr, VALUE_SIZE_MAX, "%d", value);
+    params_cast(priv_)->set(KEY_QC_SHARPNESS, valStr);
+}
+
+Range CameraParams::getSupportedBrightness() const
+{
+    Range range;
+    range.min =
+        params_cast(priv_)->getInt(KEY_QC_MIN_BRIGHTNESS);
+    range.max =
+        params_cast(priv_)->getInt(KEY_QC_MAX_BRIGHTNESS);
+    range.step =
+        params_cast(priv_)->getInt(KEY_QC_BRIGHTNESS_STEP);
+    return range;
+}
+
+int CameraParams::getBrightness() const
+{
+    return params_cast(priv_)->getInt(KEY_QC_BRIGHTNESS);
+}
+
+void CameraParams::setBrightness(int value)
+{
+    char valStr[VALUE_SIZE_MAX];
+    snprintf(valStr, VALUE_SIZE_MAX, "%d", value);
+    params_cast(priv_)->set(KEY_QC_BRIGHTNESS, valStr);
+}
+
+Range CameraParams::getSupportedContrast() const
+{
+    Range range;
+    range.min =
+        params_cast(priv_)->getInt(KEY_QC_MIN_CONTRAST);
+    range.max =
+        params_cast(priv_)->getInt(KEY_QC_MAX_CONTRAST);
+    range.step =
+        params_cast(priv_)->getInt(KEY_QC_CONTRAST_STEP);
+    return range;
+}
+
+int CameraParams::getContrast() const
+{
+    return params_cast(priv_)->getInt(KEY_QC_CONTRAST);
+}
+
+void CameraParams::setContrast(int value)
+{
+    char valStr[VALUE_SIZE_MAX];
+    snprintf(valStr, VALUE_SIZE_MAX, "%d", value);
+    params_cast(priv_)->set(KEY_QC_CONTRAST, valStr);
+}
+
+std::vector<Range> CameraParams::getSupportedPreviewFpsRanges() const
+{
+    std::vector<Range> ranges;
+    int rc;
+
+    vector<string> strRanges = parseParanthesis(params_cast(priv_)->get(
+        CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE));
+
+    ranges.resize(strRanges.size());
+    for (int i=0; i<strRanges.size(); i++) {
+        rc = sscanf(strRanges[i].c_str(), "%d,%d",
+                    &ranges[i].min, &ranges[i].max);
+        /* sscanf returns number of arguments successfully assigned.
+           On success, it would be 2 */
+        if (rc != 2) {
+            CAM_ERR("parse failed for value: %s", strRanges[i].c_str());
+            break;
+        }
+        ranges[i].step = 1;
+    }
+    return ranges;
+}
+
+Range CameraParams::getPreviewFpsRange() const
+{
+    int rc;
+    Range range;
+    params_cast(priv_)->getPreviewFpsRange(&range.min, &range.max);
+    range.step = 1;
+    return range;
+}
+
+void CameraParams::setPreviewFpsRange(const Range& value)
+{
+    char valueStr[VALUE_SIZE_MAX];
+    snprintf(valueStr, VALUE_SIZE_MAX, "%d,%d", value.min, value.max);
+    params_cast(priv_)->set(CameraParameters::KEY_PREVIEW_FPS_RANGE, valueStr);
+}
+
+std::vector<VideoFPS> CameraParams::getSupportedVideoFps() const
+{
+    vector<VideoFPS> values;
+    vector<string> strValues = parseCSV(params_cast(priv_)->get(
+        KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES));
+
+    values.resize(strValues.size());
+    for (int i=0; i<values.size(); i++) {
+        values[i] = toVideoFPS(strValues[i]);
+    }
+    return values;
+}
+
+VideoFPS CameraParams::getVideoFPS() const
+{
+    return toVideoFPS(params_cast(priv_)->get(KEY_QC_VIDEO_HIGH_FRAME_RATE));
+}
+
+void CameraParams::setVideoFPS(VideoFPS value)
+{
+    params_cast(priv_)->set(KEY_QC_VIDEO_HIGH_FRAME_RATE, toHFRMode(value));
+}
+
+string CameraParams::toString() const
+{
+    return (params_cast(priv_))->flatten();
+}
+
+vector<string> CameraParams::getSupportedPreviewFormats() const
+{
+    return parseCSV(
+     params_cast(priv_)->get(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS));
+}
+
+string CameraParams::getPreviewFormat() const
+{
+    string str(params_cast(priv_)->get(CameraParameters::KEY_PREVIEW_FORMAT));
+    return str;
+}
+
+void CameraParams::setPreviewFormat(const string& value)
+{
+    params_cast(priv_)->set(CameraParameters::KEY_PREVIEW_FORMAT,
+                            value.c_str());
+}
+
+} /* namespace camera */
+
diff --git a/libcamera/src/qcamera2.cpp b/libcamera/src/qcamera2.cpp
new file mode 100644
index 0000000..a5ade51
--- /dev/null
+++ b/libcamera/src/qcamera2.cpp
@@ -0,0 +1,556 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <hardware/camera.h>
+#include <system/camera.h>
+#include <dlfcn.h>
+#include <cstdlib>
+#include <sys/param.h>
+#include <pthread.h>
+
+#include <vector>
+
+#include <sstream>
+
+#include "camera_log.h"
+#include "camera.h"
+#include "camera_memory.h"
+
+using namespace std;
+
+namespace camera
+{
+
+const char* CAMERA_HAL_LIB_NAME = "libqcamera2.so";
+const int ID_STR_LEN = 16;
+
+static camera_module_t* g_halModule = NULL;
+static pthread_mutex_t halMutex = PTHREAD_MUTEX_INITIALIZER;
+
+static vector<int> g_openCameras;
+
+/* load module, if not already loaded */
+static camera_module_t* getCameraHalModule()
+{
+    /* serialize access to hal module using mutex */
+    pthread_mutex_lock(&halMutex);
+    if (NULL == g_halModule) {
+        /* load the module library */
+        void* handle = dlopen(CAMERA_HAL_LIB_NAME, RTLD_NOW);
+        if (NULL != handle) {
+            camera_module_t* module = (camera_module_t*)
+                dlsym(handle, HAL_MODULE_INFO_SYM_AS_STR);
+            if (NULL == dlerror()) {
+                g_halModule = module;
+            } else {
+                CAM_ERR("dlsym failed for %s:%s", CAMERA_HAL_LIB_NAME,
+                        HAL_MODULE_INFO_SYM_AS_STR);
+                dlclose(handle);
+            }
+        } else {
+            CAM_ERR("dlopen failed for %s", CAMERA_HAL_LIB_NAME);
+        }
+    }
+    pthread_mutex_unlock(&halMutex);
+    return g_halModule;
+}
+
+/**
+ * check if given camera ID is already open
+ *
+ * @param id
+ *
+ * @return bool
+ */
+static bool isOpen(int id)
+{
+    bool ret = false;
+    pthread_mutex_lock(&halMutex);
+    for (int i=0; i < g_openCameras.size(); i++) {
+        if (g_openCameras[i] == id) {
+            ret = true;
+            break;
+        }
+    }
+    pthread_mutex_unlock(&halMutex);
+    return ret;
+}
+
+int getNumberOfCameras()
+{
+    camera_module_t* mod = getCameraHalModule();
+    if (!mod) {
+        CAM_ERR("failed");
+        return ELIBACC;
+    }
+    return mod->get_number_of_cameras();
+}
+
+int getCameraInfo(int id, struct CameraInfo& info)
+{
+    struct camera_info priv_info;
+    camera_module_t* mod = getCameraHalModule();
+    if (!mod) {
+        CAM_ERR("failed");
+        return ELIBACC;
+    }
+    mod->get_camera_info(id, &priv_info);
+
+    info.func = priv_info.facing;
+
+    return 0;
+}
+
+inline static EventType toEventType(int32_t msgType)
+{
+    switch (msgType) {
+      case CAMERA_MSG_FOCUS:
+          return CAMERA_EVT_FOCUS;
+      default:
+          return CAMERA_EVT_NONE;
+    }
+}
+
+/* convert camera event bitmask to device message type bitmask */
+inline static int32_t toDeviceMsgType(uint32_t eventMask)
+{
+    int32_t msgType = 0x00;
+    if (eventMask & CAMERA_EVT_FOCUS) {
+        msgType |= CAMERA_MSG_FOCUS;
+    }
+    return msgType;
+}
+
+class QCamera2Frame : public ICameraFrame
+{
+private:
+    struct camera_device* dev_;
+public:
+    QCamera2Frame(struct camera_device* dev, int64_t timestamp,
+                  int32_t msg_type, const camera_memory_t* mem) :
+        dev_(dev)
+    {
+        timeStamp = timestamp;
+        data      = static_cast<uint8_t*>(mem->data);
+        size      = mem->size;
+
+        /* TODO: support for snapshot */
+        switch (msg_type) {
+          case CAMERA_MSG_PREVIEW_FRAME:
+              type = CAMERA_FRAME_PREVIEW;
+              break;
+          case CAMERA_MSG_VIDEO_FRAME:
+              type = CAMERA_FRAME_VIDEO;
+          default:
+              CAM_ERR("unsupported msg type, msg=%d", msg_type);
+        }
+    }
+
+    virtual ~QCamera2Frame()
+    {
+        dev_ = 0;
+    }
+
+    virtual uint32_t acquireRef()
+    {
+        return ++refs_;
+    }
+
+    virtual uint32_t releaseRef()
+    {
+        uint32_t refs = --refs_;
+
+        if (0 == refs) {
+            /* currently in camera HAL, release is only required for
+               video frames. preview frames are released automatically when
+               the listener callback returns */
+            if (type == CAMERA_FRAME_VIDEO) {
+                dev_->ops->release_recording_frame(dev_, data);
+            }
+            delete this;
+        }
+        return refs;
+    }
+
+    static void dispatchFrame(ICameraListener* listener,
+                              struct camera_device* dev, int64_t timestamp,
+                              int32_t msg_type, const camera_memory_t* mem)
+    {
+        /* todo:  use pre-allocated frame pool */
+        QCamera2Frame* frame = new QCamera2Frame(dev, timestamp, msg_type, mem);
+        if (NULL != frame) {
+            switch (frame->type) {
+              case CAMERA_FRAME_PREVIEW:
+                  listener->onPreviewFrame(static_cast<ICameraFrame*>(frame));
+                  break;
+              case CAMERA_FRAME_VIDEO:
+                  listener->onVideoFrame(static_cast<ICameraFrame*>(frame));
+                  break;
+              default:
+                  listener->onMetadataFrame(static_cast<ICameraFrame*>(frame));
+            }
+            frame->releaseRef();
+        }
+    }
+};
+
+class QCamera2 : public ICameraDevice
+{
+    struct camera_device* dev_;
+    int id_;
+    ICameraParameters* params_;
+    vector<ICameraListener *> listeners_;
+
+    bool isPreviewRequested_;
+    bool isPreviewRunning_;
+    bool isVideoRunning_;
+
+    static void notify_callback(int32_t msg_type, int32_t ext1, int32_t ext2,
+                                void* user);
+
+    static void data_callback(int32_t msg_type, const camera_memory_t* data,
+                              unsigned int index,
+                              camera_frame_metadata_t* metadata, void* user);
+
+    static void data_timestamp_callback(int64_t timestamp, int32_t msg_type,
+                                        const camera_memory_t* data,
+                                        unsigned int index, void* user);
+public:
+    QCamera2();
+
+    virtual ~QCamera2();
+
+    int init(int index);
+
+    int getID() { return id_; }
+
+    /* Implementation of virtual methods of ICameraDevice interface */
+    virtual void addListener(ICameraListener* listener);
+    virtual void removeListener(ICameraListener* listener);
+
+    virtual void subscribe(uint32_t eventMask);
+
+    virtual void unsubscribe(uint32_t eventMask);
+
+    virtual int setParameters(const ICameraParameters& params);
+    virtual int getParameters(uint8_t* buf, uint32_t bufSize,
+                              int* bufSizeRequired);
+
+    virtual int startPreview();
+    virtual void stopPreview();
+
+    virtual int startRecording();
+    virtual void stopRecording();
+
+    virtual int startAutoFocus() { return dev_->ops->auto_focus(dev_); }
+    virtual void stopAutoFocus() { dev_->ops->cancel_auto_focus(dev_); }
+
+    virtual int takePicture() { return dev_->ops->take_picture(dev_); }
+    virtual void cancelPicture() { dev_->ops->cancel_picture(dev_); }
+};
+
+QCamera2::QCamera2() :
+    dev_(NULL),
+    id_(-1),
+    isPreviewRequested_(false),
+    isPreviewRunning_(false),
+    isVideoRunning_(false)
+{
+}
+
+int QCamera2::init(int idx)
+{
+    camera_module_t* mod = getCameraHalModule();
+    int nret = 0;
+    char idStr[ID_STR_LEN];
+
+    if (NULL == mod) {
+        CAM_ERR("camera HAL module loading failed");
+        nret = ELIBACC;
+        goto bail;
+    }
+
+    snprintf(idStr, ID_STR_LEN, "%d", idx);
+    mod->common.methods->open((hw_module_t*)mod, idStr, (hw_device_t**)&dev_);
+    if (NULL == dev_) {
+        CAM_ERR("camera device open failed");
+        nret = EBADR;
+        goto bail;
+    }
+
+    dev_->ops->set_callbacks(dev_, QCamera2::notify_callback,
+                             QCamera2::data_callback,
+                             QCamera2::data_timestamp_callback,
+                             CameraMemory::requestMemory, this);
+
+    /* enable error events by default */
+    dev_->ops->enable_msg_type(dev_, CAMERA_MSG_ERROR);
+
+    id_ = idx;
+bail:
+    return nret;
+}
+
+QCamera2::~QCamera2()
+{
+    /* close camera device */
+    if (NULL != dev_) {
+        dev_->common.close(&dev_->common);
+        dev_ = NULL;
+    }
+}
+
+void QCamera2::notify_callback(int32_t msg_type, int32_t ext1, int32_t ext2,
+                               void* user)
+{
+    QCamera2* me = (QCamera2*)user;
+
+    if (NULL == me) {
+        CAM_ERR("failed");
+        return;
+    }
+    ControlEvent control;
+    control.type = toEventType(msg_type);
+    if (control.type == CAMERA_EVT_NONE) {
+        CAM_ERR("unsupported msg type");
+        return;
+    }
+    control.ext1 = ext1;
+    control.ext2 = ext2;
+    /* notify each listener */
+    for (int i=0; i < me->listeners_.size(); i++) {
+        if (CAMERA_MSG_ERROR == msg_type) {
+            me->listeners_[i]->onError();
+        } else {
+            me->listeners_[i]->onControl(control);
+        }
+    }
+}
+
+void QCamera2::data_callback(int32_t msg_type,
+                             const camera_memory_t* data,
+                             unsigned int index,
+                             camera_frame_metadata_t* metadata,
+                             void* user)
+{
+    QCamera2* me = (QCamera2*)user;
+
+    if (NULL == me) {
+        CAM_ERR("failed");
+        return;
+    }
+    /* notify each listener */
+    for (int i=0; i < me->listeners_.size(); i++) {
+        QCamera2Frame::dispatchFrame(me->listeners_[i], me->dev_, 0,
+                                     msg_type, data);
+    }
+}
+
+void QCamera2::data_timestamp_callback(int64_t timestamp, int32_t msg_type,
+                                       const camera_memory_t* data,
+                                       unsigned int index, void* user)
+{
+    QCamera2* me = (QCamera2*)user;
+
+    if (NULL == me) {
+        CAM_ERR("failed");
+        return;
+    }
+    /* notify each listener */
+    for (int i=0; i < me->listeners_.size(); i++) {
+        QCamera2Frame::dispatchFrame(me->listeners_[i], me->dev_, timestamp,
+                                     msg_type, data);
+    }
+}
+
+int QCamera2::setParameters(const ICameraParameters& params)
+{
+    // empty buffer
+    std::stringbuf buffer;
+    // associate stream buffer to stream
+    std::ostream os(&buffer);
+
+    params.writeObject(os);
+
+    return dev_->ops->set_parameters(dev_, buffer.str().c_str());
+}
+
+int QCamera2::getParameters(uint8_t* buf, uint32_t bufSize, int* bufSizeRequired)
+{
+    int rc = 0;
+    char* p = dev_->ops->get_parameters(dev_);
+    int nlen = strlen(p);
+
+    memmove(buf, p, MIN(nlen, bufSize));
+    if (NULL != bufSizeRequired) {
+        *bufSizeRequired = nlen;
+    }
+    dev_->ops->put_parameters(dev_, p);
+    return rc;
+}
+
+void QCamera2::addListener(ICameraListener* listener)
+{
+    /* check if this listener is already added, to avoid adding
+       duplicates */
+    for (int i=0; i<listeners_.size(); i++) {
+        if (listener == listeners_[i]) {
+            CAM_ERR("this listener is already added");
+            return;
+        }
+    }
+    listeners_.push_back(listener);
+}
+
+void QCamera2::removeListener(ICameraListener* listener)
+{
+    /* erase if this listener is added */
+    for (int i=0; i<listeners_.size(); i++) {
+        if (listener == listeners_[i]) {
+            listeners_.erase(listeners_.begin() + i);
+            return;
+        }
+    }
+}
+
+void QCamera2::subscribe(uint32_t eventMask)
+{
+    dev_->ops->enable_msg_type(dev_, toDeviceMsgType(eventMask));
+}
+
+void QCamera2::unsubscribe(uint32_t eventMask)
+{
+    dev_->ops->disable_msg_type(dev_, toDeviceMsgType(eventMask));
+}
+
+int QCamera2::startPreview()
+{
+    int rc = 0;
+    isPreviewRequested_ = true;
+    dev_->ops->enable_msg_type(dev_, CAMERA_MSG_PREVIEW_FRAME);
+    if (isPreviewRunning_ == false) {
+        rc = dev_->ops->start_preview(dev_);
+        if (rc == 0) {
+            isPreviewRunning_ = true;
+        }
+    }
+    return rc;
+}
+
+void QCamera2::stopPreview()
+{
+    isPreviewRequested_ = false;
+    dev_->ops->disable_msg_type(dev_, CAMERA_MSG_PREVIEW_FRAME);
+    /* stop preview only if video is not running */
+    if (isPreviewRunning_ == true && isVideoRunning_ == false) {
+        dev_->ops->stop_preview(dev_);
+        isPreviewRunning_ = false;
+    }
+}
+
+int QCamera2::startRecording()
+{
+    int rc=0;
+    /* start preview internally */
+    if (isPreviewRunning_ == false) {
+        rc = dev_->ops->start_preview(dev_);
+        if (rc != 0) {
+            goto bail;
+        }
+        isPreviewRunning_ = true;
+    }
+    dev_->ops->enable_msg_type(dev_, CAMERA_MSG_VIDEO_FRAME);
+    rc = dev_->ops->start_recording(dev_);
+    if (rc == 0) {
+        isVideoRunning_ = true;
+    }
+bail:
+    return rc;
+}
+
+void QCamera2::stopRecording()
+{
+    dev_->ops->disable_msg_type(dev_, CAMERA_MSG_VIDEO_FRAME);
+    dev_->ops->stop_recording(dev_);
+    isVideoRunning_ = false;
+    /* stop preview if it is not requested */
+    if (isPreviewRequested_ == false && isPreviewRunning_ == true) {
+        dev_->ops->stop_preview(dev_);
+    }
+}
+
+int ICameraDevice::createInstance(int index, ICameraDevice** device)
+{
+    int rc = 0;
+    QCamera2* me = NULL;
+
+    if (isOpen(index) == true) {
+        rc = EBUSY;
+        goto bail;
+    }
+
+    me = new QCamera2;
+    if (me == NULL) {
+        rc = ENOMEM;
+        goto bail;
+    }
+    rc = me->init(index);
+    if (rc != 0) {
+        rc = ENODEV;
+        goto bail;
+    }
+    /* add entry to openCameras vector */
+    pthread_mutex_lock(&halMutex);
+    g_openCameras.push_back(index);
+    pthread_mutex_unlock(&halMutex);
+    *device = static_cast<ICameraDevice*>(me);
+    return 0;
+bail:
+    delete me;
+    return rc;
+}
+
+void ICameraDevice::deleteInstance(ICameraDevice** device)
+{
+    QCamera2* me = static_cast<QCamera2*>(*device);
+
+    /* erase entry from openCamera vector */
+    pthread_mutex_lock(&halMutex);
+    for (int i=0; i < g_openCameras.size(); i++) {
+        if (g_openCameras[i] == me->getID()) {
+            g_openCameras.erase(g_openCameras.begin() + i);
+            break;
+        }
+    }
+    pthread_mutex_unlock(&halMutex);
+
+    delete me;
+    *device = NULL;
+}
+
+} /* namespace camera */
diff --git a/libcamera/src/qcamera_extensions.h b/libcamera/src/qcamera_extensions.h
new file mode 100644
index 0000000..7590629
--- /dev/null
+++ b/libcamera/src/qcamera_extensions.h
@@ -0,0 +1,306 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+namespace camera
+{
+
+const char KEY_QC_SUPPORTED_HFR_SIZES[] = "hfr-size-values";
+const char KEY_QC_PREVIEW_FRAME_RATE_MODE[] = "preview-frame-rate-mode";
+const char KEY_QC_SUPPORTED_PREVIEW_FRAME_RATE_MODES[] = "preview-frame-rate-modes";
+const char KEY_QC_PREVIEW_FRAME_RATE_AUTO_MODE[] = "frame-rate-auto";
+const char KEY_QC_PREVIEW_FRAME_RATE_FIXED_MODE[] = "frame-rate-fixed";
+const char KEY_QC_TOUCH_AF_AEC[] = "touch-af-aec";
+const char KEY_QC_SUPPORTED_TOUCH_AF_AEC[] = "touch-af-aec-values";
+const char KEY_QC_TOUCH_INDEX_AEC[] = "touch-index-aec";
+const char KEY_QC_TOUCH_INDEX_AF[] = "touch-index-af";
+const char KEY_QC_SCENE_DETECT[] = "scene-detect";
+const char KEY_QC_SUPPORTED_SCENE_DETECT[] = "scene-detect-values";
+const char KEY_QC_ISO_MODE[] = "iso";
+const char KEY_QC_SUPPORTED_ISO_MODES[] = "iso-values";
+const char KEY_QC_EXPOSURE_TIME[] = "exposure-time";
+const char KEY_QC_MIN_EXPOSURE_TIME[] = "min-exposure-time";
+const char KEY_QC_MAX_EXPOSURE_TIME[] = "max-exposure-time";
+const char KEY_QC_LENSSHADE[] = "lensshade";
+const char KEY_QC_SUPPORTED_LENSSHADE_MODES[] = "lensshade-values";
+const char KEY_QC_AUTO_EXPOSURE[] = "auto-exposure";
+const char KEY_QC_SUPPORTED_AUTO_EXPOSURE[] = "auto-exposure-values";
+const char KEY_QC_DENOISE[] = "denoise";
+const char KEY_QC_SUPPORTED_DENOISE[] = "denoise-values";
+const char KEY_QC_FOCUS_ALGO[] = "selectable-zone-af";
+const char KEY_QC_SUPPORTED_FOCUS_ALGOS[] = "selectable-zone-af-values";
+const char KEY_QC_MANUAL_FOCUS_POSITION[] = "manual-focus-position";
+const char KEY_QC_MANUAL_FOCUS_POS_TYPE[] = "manual-focus-pos-type";
+const char KEY_QC_MIN_FOCUS_POS_INDEX[] = "min-focus-pos-index";
+const char KEY_QC_MAX_FOCUS_POS_INDEX[] = "max-focus-pos-index";
+const char KEY_QC_MIN_FOCUS_POS_DAC[] = "min-focus-pos-dac";
+const char KEY_QC_MAX_FOCUS_POS_DAC[] = "max-focus-pos-dac";
+const char KEY_QC_FACE_DETECTION[] = "face-detection";
+const char KEY_QC_SUPPORTED_FACE_DETECTION[] = "face-detection-values";
+const char KEY_QC_FACE_RECOGNITION[] = "face-recognition";
+const char KEY_QC_SUPPORTED_FACE_RECOGNITION[] = "face-recognition-values";
+const char KEY_QC_MEMORY_COLOR_ENHANCEMENT[] = "mce";
+const char KEY_QC_SUPPORTED_MEM_COLOR_ENHANCE_MODES[] = "mce-values";
+const char KEY_QC_DIS[] = "dis";
+const char KEY_QC_SUPPORTED_DIS_MODES[] = "dis-values";
+const char KEY_QC_VIDEO_HIGH_FRAME_RATE[] = "video-hfr";
+const char KEY_QC_VIDEO_HIGH_SPEED_RECORDING[] = "video-hsr";
+const char KEY_QC_SUPPORTED_VIDEO_HIGH_FRAME_RATE_MODES[] = "video-hfr-values";
+const char KEY_QC_REDEYE_REDUCTION[] = "redeye-reduction";
+const char KEY_QC_SUPPORTED_REDEYE_REDUCTION[] = "redeye-reduction-values";
+const char KEY_QC_HIGH_DYNAMIC_RANGE_IMAGING[] = "hdr";
+const char KEY_QC_SUPPORTED_HDR_IMAGING_MODES[] = "hdr-values";
+const char KEY_QC_ZSL[] = "zsl";
+const char KEY_QC_SUPPORTED_ZSL_MODES[] = "zsl-values";
+const char KEY_QC_ZSL_BURST_INTERVAL[] = "capture-burst-interval";
+const char KEY_QC_ZSL_BURST_LOOKBACK[] = "capture-burst-retroactive";
+const char KEY_QC_ZSL_QUEUE_DEPTH[] = "capture-burst-queue-depth";
+const char KEY_QC_CAMERA_MODE[] = "camera-mode";
+const char KEY_QC_AE_BRACKET_HDR[] = "ae-bracket-hdr";
+const char KEY_QC_SUPPORTED_AE_BRACKET_MODES[] = "ae-bracket-hdr-values";
+const char KEY_QC_SUPPORTED_RAW_FORMATS[] = "raw-format-values";
+const char KEY_QC_RAW_FORMAT[] = "raw-format";
+const char KEY_QC_ORIENTATION[] = "orientation";
+const char KEY_QC_SELECTABLE_ZONE_AF[] = "selectable-zone-af";
+const char KEY_QC_CAPTURE_BURST_EXPOSURE[] = "capture-burst-exposures";
+const char KEY_QC_NUM_SNAPSHOT_PER_SHUTTER[] = "num-snaps-per-shutter";
+const char KEY_QC_NO_DISPLAY_MODE[] = "no-display-mode";
+const char KEY_QC_RAW_PICUTRE_SIZE[] = "raw-size";
+const char KEY_QC_SUPPORTED_SKIN_TONE_ENHANCEMENT_MODES[] = "skinToneEnhancement-values";
+const char KEY_QC_SUPPORTED_LIVESNAPSHOT_SIZES[] = "supported-live-snapshot-sizes";
+const char KEY_QC_SCALED_PICTURE_SIZES[] = "scaled-picture-sizes";
+const char KEY_QC_HDR_NEED_1X[] = "hdr-need-1x";
+const char KEY_QC_PREVIEW_FLIP[] = "preview-flip";
+const char KEY_QC_VIDEO_FLIP[] = "video-flip";
+const char KEY_QC_SNAPSHOT_PICTURE_FLIP[] = "snapshot-picture-flip";
+const char KEY_QC_SUPPORTED_FLIP_MODES[] = "flip-mode-values";
+const char KEY_QC_VIDEO_HDR[] = "video-hdr";
+const char KEY_QC_VT_ENABLE[] = "avtimer";
+const char KEY_QC_SUPPORTED_VIDEO_HDR_MODES[] = "video-hdr-values";
+const char KEY_QC_AUTO_HDR_ENABLE [] = "auto-hdr-enable";
+const char KEY_QC_SNAPSHOT_BURST_NUM[] = "snapshot-burst-num";
+const char KEY_QC_SNAPSHOT_FD_DATA[] = "snapshot-fd-data-enable";
+const char KEY_QC_TINTLESS_ENABLE[] = "tintless";
+const char KEY_QC_CDS_MODE[] = "cds-mode";
+const char KEY_QC_VIDEO_ROTATION[] = "video-rotation";
+const char KEY_QC_AF_BRACKET[] = "af-bracket";
+const char KEY_QC_SUPPORTED_AF_BRACKET_MODES[] = "af-bracket-values";
+const char KEY_QC_CHROMA_FLASH[] = "chroma-flash";
+const char KEY_QC_SUPPORTED_CHROMA_FLASH_MODES[] = "chroma-flash-values";
+const char KEY_QC_OPTI_ZOOM[] = "opti-zoom";
+const char KEY_QC_SUPPORTED_OPTI_ZOOM_MODES[] = "opti-zoom-values";
+const char KEY_QC_WB_MANUAL_CCT[] = "wb-manual-cct";
+const char KEY_QC_MIN_WB_CCT[] = "min-wb-cct";
+const char KEY_QC_MAX_WB_CCT[] = "max-wb-cct";
+
+// Values for effect settings.
+const char EFFECT_EMBOSS[] = "emboss";
+const char EFFECT_SKETCH[] = "sketch";
+const char EFFECT_NEON[] = "neon";
+
+// Values for auto exposure settings.
+const char TOUCH_AF_AEC_OFF[] = "touch-off";
+const char TOUCH_AF_AEC_ON[] = "touch-on";
+
+// Values for scene mode settings.
+const char SCENE_MODE_ASD[] = "asd";   // corresponds to CAMERA_BESTSHOT_AUTO in HAL
+const char SCENE_MODE_BACKLIGHT[] = "backlight";
+const char SCENE_MODE_FLOWERS[] = "flowers";
+const char SCENE_MODE_AR[] = "AR";
+const char SCENE_MODE_HDR[] = "hdr";
+
+// Formats for setPreviewFormat and setPictureFormat.
+const char PIXEL_FORMAT_YUV420SP_ADRENO[] = "yuv420sp-adreno";
+const char PIXEL_FORMAT_YV12[] = "yuv420p";
+const char PIXEL_FORMAT_NV12[] = "nv12";
+const char QC_PIXEL_FORMAT_NV12_VENUS[] = "nv12-venus";
+
+// Values for raw image formats
+const char QC_PIXEL_FORMAT_YUV_RAW_8BIT_YUYV[] = "yuv-raw8-yuyv";
+const char QC_PIXEL_FORMAT_YUV_RAW_8BIT_YVYU[] = "yuv-raw8-yvyu";
+const char QC_PIXEL_FORMAT_YUV_RAW_8BIT_UYVY[] = "yuv-raw8-uyvy";
+const char QC_PIXEL_FORMAT_YUV_RAW_8BIT_VYUY[] = "yuv-raw8-vyuy";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8GBRG[] = "bayer-qcom-8gbrg";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8GRBG[] = "bayer-qcom-8grbg";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8RGGB[] = "bayer-qcom-8rggb";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_8BGGR[] = "bayer-qcom-8bggr";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10GBRG[] = "bayer-qcom-10gbrg";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10GRBG[] = "bayer-qcom-10grbg";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10RGGB[] = "bayer-qcom-10rggb";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_10BGGR[] = "bayer-qcom-10bggr";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12GBRG[] = "bayer-qcom-12gbrg";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12GRBG[] = "bayer-qcom-12grbg";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12RGGB[] = "bayer-qcom-12rggb";
+const char QC_PIXEL_FORMAT_BAYER_QCOM_RAW_12BGGR[] = "bayer-qcom-12bggr";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8GBRG[] = "bayer-mipi-8gbrg";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8GRBG[] = "bayer-mipi-8grbg";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8RGGB[] = "bayer-mipi-8rggb";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_8BGGR[] = "bayer-mipi-8bggr";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10GBRG[] = "bayer-mipi-10gbrg";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10GRBG[] = "bayer-mipi-10grbg";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10RGGB[] = "bayer-mipi-10rggb";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_10BGGR[] = "bayer-mipi-10bggr";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12GBRG[] = "bayer-mipi-12gbrg";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12GRBG[] = "bayer-mipi-12grbg";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12RGGB[] = "bayer-mipi-12rggb";
+const char QC_PIXEL_FORMAT_BAYER_MIPI_RAW_12BGGR[] = "bayer-mipi-12bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8GBRG[] = "bayer-ideal-qcom-8gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8GRBG[] = "bayer-ideal-qcom-8grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8RGGB[] = "bayer-ideal-qcom-8rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_8BGGR[] = "bayer-ideal-qcom-8bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10GBRG[] = "bayer-ideal-qcom-10gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10GRBG[] = "bayer-ideal-qcom-10grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10RGGB[] = "bayer-ideal-qcom-10rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_10BGGR[] = "bayer-ideal-qcom-10bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12GBRG[] = "bayer-ideal-qcom-12gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12GRBG[] = "bayer-ideal-qcom-12grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12RGGB[] = "bayer-ideal-qcom-12rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_QCOM_12BGGR[] = "bayer-ideal-qcom-12bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8GBRG[] = "bayer-ideal-mipi-8gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8GRBG[] = "bayer-ideal-mipi-8grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8RGGB[] = "bayer-ideal-mipi-8rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_8BGGR[] = "bayer-ideal-mipi-8bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10GBRG[] = "bayer-ideal-mipi-10gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10GRBG[] = "bayer-ideal-mipi-10grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10RGGB[] = "bayer-ideal-mipi-10rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_10BGGR[] = "bayer-ideal-mipi-10bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12GBRG[] = "bayer-ideal-mipi-12gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12GRBG[] = "bayer-ideal-mipi-12grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12RGGB[] = "bayer-ideal-mipi-12rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_MIPI_12BGGR[] = "bayer-ideal-mipi-12bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8GBRG[] = "bayer-ideal-plain8-8gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8GRBG[] = "bayer-ideal-plain8-8grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8RGGB[] = "bayer-ideal-plain8-8rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN8_8BGGR[] = "bayer-ideal-plain8-8bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8GBRG[] = "bayer-ideal-plain16-8gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8GRBG[] = "bayer-ideal-plain16-8grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8RGGB[] = "bayer-ideal-plain16-8rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_8BGGR[] = "bayer-ideal-plain16-8bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10GBRG[] = "bayer-ideal-plain16-10gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10GRBG[] = "bayer-ideal-plain16-10grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10RGGB[] = "bayer-ideal-plain16-10rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_10BGGR[] = "bayer-ideal-plain16-10bggr";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12GBRG[] = "bayer-ideal-plain16-12gbrg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12GRBG[] = "bayer-ideal-plain16-12grbg";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12RGGB[] = "bayer-ideal-plain16-12rggb";
+const char QC_PIXEL_FORMAT_BAYER_IDEAL_PLAIN16_12BGGR[] = "bayer-ideal-plain16-12bggr";
+
+// Values for auto exposure settings.
+const char AUTO_EXPOSURE_FRAME_AVG[] = "frame-average";
+const char AUTO_EXPOSURE_CENTER_WEIGHTED[] = "center-weighted";
+const char AUTO_EXPOSURE_SPOT_METERING[] = "spot-metering";
+const char AUTO_EXPOSURE_SMART_METERING[] = "smart-metering";
+const char AUTO_EXPOSURE_USER_METERING[] = "user-metering";
+const char AUTO_EXPOSURE_SPOT_METERING_ADV[] = "spot-metering-adv";
+const char AUTO_EXPOSURE_CENTER_WEIGHTED_ADV[] = "center-weighted-adv";
+
+const char KEY_QC_GPS_LATITUDE_REF[] = "gps-latitude-ref";
+const char KEY_QC_GPS_LONGITUDE_REF[] = "gps-longitude-ref";
+const char KEY_QC_GPS_ALTITUDE_REF[] = "gps-altitude-ref";
+const char KEY_QC_GPS_STATUS[] = "gps-status";
+
+const char KEY_QC_HISTOGRAM[] = "histogram";
+const char KEY_QC_SUPPORTED_HISTOGRAM_MODES[] = "histogram-values";
+
+const char VALUE_ENABLE[] = "enable";
+const char VALUE_DISABLE[] = "disable";
+const char VALUE_OFF[] = "off";
+const char VALUE_ON[] = "on";
+const char VALUE_TRUE[] = "true";
+const char VALUE_FALSE[] = "false";
+
+const char KEY_QC_SHARPNESS[] = "sharpness";
+const char KEY_QC_MIN_SHARPNESS[] = "min-sharpness";
+const char KEY_QC_MAX_SHARPNESS[] = "max-sharpness";
+const char KEY_QC_SHARPNESS_STEP[] = "sharpness-step";
+const char KEY_QC_CONTRAST[] = "contrast";
+const char KEY_QC_MIN_CONTRAST[] = "min-contrast";
+const char KEY_QC_MAX_CONTRAST[] = "max-contrast";
+const char KEY_QC_CONTRAST_STEP[] = "contrast-step";
+const char KEY_QC_SATURATION[] = "saturation";
+const char KEY_QC_MIN_SATURATION[] = "min-saturation";
+const char KEY_QC_MAX_SATURATION[] = "max-saturation";
+const char KEY_QC_SATURATION_STEP[] = "saturation-step";
+const char KEY_QC_BRIGHTNESS[] = "luma-adaptation";
+const char KEY_QC_MIN_BRIGHTNESS[] = "min-brightness";
+const char KEY_QC_MAX_BRIGHTNESS[] = "max-brightness";
+const char KEY_QC_BRIGHTNESS_STEP[] = "brightness-step";
+const char KEY_QC_SCE_FACTOR[] = "skinToneEnhancement";
+const char KEY_QC_MIN_SCE_FACTOR[] = "min-sce-factor";
+const char KEY_QC_MAX_SCE_FACTOR[] = "max-sce-factor";
+const char KEY_QC_SCE_FACTOR_STEP[] = "sce-factor-step";
+
+const char KEY_QC_SUPPORTED_CAMERA_FEATURES[] = "qc-camera-features";
+const char KEY_QC_MAX_NUM_REQUESTED_FACES[] = "qc-max-num-requested-faces";
+
+//Values for DENOISE
+const char DENOISE_OFF[] = "denoise-off";
+const char DENOISE_ON[] = "denoise-on";
+
+// Values for selectable zone af Settings
+const char FOCUS_ALGO_AUTO[] = "auto";
+const char FOCUS_ALGO_SPOT_METERING[] = "spot-metering";
+const char FOCUS_ALGO_CENTER_WEIGHTED[] = "center-weighted";
+const char FOCUS_ALGO_FRAME_AVERAGE[] = "frame-average";
+
+// Values for HFR settings.
+const char VIDEO_HFR_OFF[] = "off";
+const char VIDEO_HFR_2X[] = "60";
+const char VIDEO_HFR_3X[] = "90";
+const char VIDEO_HFR_4X[] = "120";
+const char VIDEO_HFR_5X[] = "150";
+
+// Values for HDR Bracketing settings.
+const char AE_BRACKET_OFF[] = "Off";
+const char AE_BRACKET[] = "AE-Bracket";
+
+// Values for AF Bracketing setting.
+const char AF_BRACKET_OFF[] = "af-bracket-off";
+const char AF_BRACKET_ON[] = "af-bracket-on";
+
+// Values for Chroma Flash setting.
+const char CHROMA_FLASH_OFF[] = "chroma-flash-off";
+const char CHROMA_FLASH_ON[] = "chroma-flash-on";
+
+// Values for Opti Zoom setting.
+const char OPTI_ZOOM_OFF[] = "opti-zoom-off";
+const char OPTI_ZOOM_ON[] = "opti-zoom-on";
+
+// Values for FLIP settings.
+const char FLIP_MODE_OFF[] = "off";
+const char FLIP_MODE_V[] = "flip-v";
+const char FLIP_MODE_H[] = "flip-h";
+const char FLIP_MODE_VH[] = "flip-vh";
+
+const char CDS_MODE_OFF[] = "off";
+const char CDS_MODE_ON[] = "on";
+const char CDS_MODE_AUTO[] = "auto";
+
+const char KEY_SELECTED_AUTO_SCENE[] = "selected-auto-scene";
+
+} /* namespace camera */
diff --git a/libcamera/test/camera_test.cpp b/libcamera/test/camera_test.cpp
new file mode 100644
index 0000000..8b15ee5
--- /dev/null
+++ b/libcamera/test/camera_test.cpp
@@ -0,0 +1,425 @@
+/* Copyright (c) 2015, The Linux Foundataion. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+
+#include <unistd.h>
+
+#include "camera.h"
+#include "camera_log.h"
+#include "camera_parameters.h"
+
+using namespace std;
+using namespace camera;
+
+struct CameraCaps
+{
+    vector<ImageSize> pSizes, vSizes;
+    vector<string> focusModes, wbModes, isoModes;
+    Range brightness, sharpness, contrast;
+    vector<Range> previewFpsRanges;
+    vector<VideoFPS> videoFpsValues;
+};
+
+enum CamFunction {
+    CAM_FUNC_HIRES = 0,
+    CAM_FUNC_OPTIC_FLOW = 1,
+};
+
+struct TestConfig
+{
+    bool dumpFrames;
+    bool infoMode;
+    int runTime;
+    CamFunction func;
+};
+
+class CameraTest : ICameraListener
+{
+public:
+
+    CameraTest();
+    CameraTest(TestConfig config);
+    ~CameraTest();
+    int run();
+
+    int initialize(int camId);
+
+    /* listener methods */
+    virtual void onError();
+    virtual void onPreviewFrame(ICameraFrame* frame);
+    virtual void onVideoFrame(ICameraFrame* frame);
+
+private:
+    ICameraDevice* camera_;
+    CameraParams params_;
+    ImageSize pSize_, vSize_;
+    CameraCaps caps_;
+    TestConfig config_;
+
+    uint32_t vFrameCount_, pFrameCount_;
+    float vFpsAvg_, pFpsAvg_;
+
+    uint64_t vTimeStampPrev_, pTimeStampPrev_;
+
+    int printCapabilities();
+    int setParameters();
+};
+
+CameraTest::CameraTest() :
+    vFrameCount_(0),
+    pFrameCount_(0),
+    vFpsAvg_(0.0f),
+    pFpsAvg_(0.0f),
+    vTimeStampPrev_(0),
+    pTimeStampPrev_(0)
+{
+}
+
+CameraTest::CameraTest(TestConfig config) :
+    vFrameCount_(0),
+    pFrameCount_(0),
+    vFpsAvg_(0.0f),
+    pFpsAvg_(0.0f),
+    vTimeStampPrev_(0),
+    pTimeStampPrev_(0)
+{
+    config_ = config;
+}
+
+int CameraTest::initialize(int camId)
+{
+    int rc;
+    rc = ICameraDevice::createInstance(camId, &camera_);
+    if (rc != 0) {
+        printf("could not open camera %d\n", camId);
+        return rc;
+    }
+    camera_->addListener(this);
+
+    rc = params_.init(camera_);
+    if (rc != 0) {
+        printf("failed to init parameters\n");
+        ICameraDevice::deleteInstance(&camera_);
+        return rc;
+    }
+    //printf("params = %s\n", params_.toString().c_str());
+    /* query capabilities */
+    caps_.pSizes = params_.getSupportedPreviewSizes();
+    caps_.vSizes = params_.getSupportedVideoSizes();
+    caps_.focusModes = params_.getSupportedFocusModes();
+    caps_.wbModes = params_.getSupportedWhiteBalance();
+    caps_.isoModes = params_.getSupportedISO();
+    caps_.brightness = params_.getSupportedBrightness();
+    caps_.sharpness = params_.getSupportedSharpness();
+    caps_.contrast = params_.getSupportedContrast();
+    caps_.previewFpsRanges = params_.getSupportedPreviewFpsRanges();
+    caps_.videoFpsValues = params_.getSupportedVideoFps();
+}
+
+CameraTest::~CameraTest()
+{
+    /* release camera device */
+    ICameraDevice::deleteInstance(&camera_);
+}
+
+static int dumpToFile(uint8_t* data, uint32_t size, char* name)
+{
+    FILE* fp;
+    fp = fopen(name, "wb");
+    if (!fp) {
+        printf("fopen failed for %s\n", name);
+        return -1;
+    }
+    fwrite(data, size, 1, fp);
+    printf("saved %s\n", name);
+    fclose(fp);
+}
+
+void CameraTest::onError()
+{
+    printf("camera error!, aborting\n");
+    exit(EXIT_FAILURE);
+}
+
+void CameraTest::onPreviewFrame(ICameraFrame* frame)
+{
+    if (pFrameCount_ > 0 && pFrameCount_ % 30 == 0) {
+        char name[32];
+        snprintf(name, 32, "P_%dx%d_%04d.yuv",
+                 pSize_.width, pSize_.height, pFrameCount_);
+        if (config_.dumpFrames == true) {
+            dumpToFile(frame->data, frame->size, name);
+        }
+        //printf("Preview FPS = %.2f\n", pFpsAvg_);
+    }
+
+    uint64_t diff = frame->timeStamp - pTimeStampPrev_;
+    pFpsAvg_ = ((pFpsAvg_ * pFrameCount_) + (1e9 / diff)) / (pFrameCount_ + 1);
+    pFrameCount_++;
+    pTimeStampPrev_  = frame->timeStamp;
+}
+
+void CameraTest::onVideoFrame(ICameraFrame* frame)
+{
+    if (vFrameCount_ > 0 && vFrameCount_ % 30 == 0) {
+        char name[32];
+        snprintf(name, 32, "V_%dx%d_%04d.yuv",
+                 vSize_.width, vSize_.height, vFrameCount_);
+        if (config_.dumpFrames == true) {
+            dumpToFile(frame->data, frame->size, name);
+        }
+        //printf("Video FPS = %.2f\n", vFpsAvg_);
+    }
+
+    uint64_t diff = frame->timeStamp - vTimeStampPrev_;
+    vFpsAvg_ = ((vFpsAvg_ * vFrameCount_) + (1e9 / diff)) / (vFrameCount_ + 1);
+    vFrameCount_++;
+    vTimeStampPrev_  = frame->timeStamp;
+}
+
+int CameraTest::printCapabilities()
+{
+    printf("Camera capabilities\n");
+
+    printf("available preview sizes:\n");
+    for (int i = 0; i < caps_.pSizes.size(); i++) {
+        printf("%d: %d x %d\n", i, caps_.pSizes[i].width, caps_.pSizes[i].height);
+    }
+    printf("available video sizes:\n");
+    for (int i = 0; i < caps_.vSizes.size(); i++) {
+        printf("%d: %d x %d\n", i, caps_.vSizes[i].width, caps_.vSizes[i].height);
+    }
+    printf("available focus modes:\n");
+    for (int i = 0; i < caps_.focusModes.size(); i++) {
+        printf("%d: %s\n", i, caps_.focusModes[i].c_str());
+    }
+    printf("available whitebalance modes:\n");
+    for (int i = 0; i < caps_.wbModes.size(); i++) {
+        printf("%d: %s\n", i, caps_.wbModes[i].c_str());
+    }
+    printf("available ISO modes:\n");
+    for (int i = 0; i < caps_.isoModes.size(); i++) {
+        printf("%d: %s\n", i, caps_.isoModes[i].c_str());
+    }
+    printf("available brightness values:\n");
+    printf("min=%d, max=%d, step=%d\n", caps_.brightness.min,
+           caps_.brightness.max, caps_.brightness.step);
+    printf("available sharpness values:\n");
+    printf("min=%d, max=%d, step=%d\n", caps_.sharpness.min,
+           caps_.sharpness.max, caps_.sharpness.step);
+    printf("available contrast values:\n");
+    printf("min=%d, max=%d, step=%d\n", caps_.contrast.min,
+           caps_.contrast.max, caps_.contrast.step);
+
+    printf("available preview fps ranges:\n");
+    for (int i = 0; i < caps_.previewFpsRanges.size(); i++) {
+        printf("%d: [%d, %d]\n", i, caps_.previewFpsRanges[i].min,
+               caps_.previewFpsRanges[i].max);
+    }
+    printf("available video fps values:\n");
+    for (int i = 0; i < caps_.videoFpsValues.size(); i++) {
+        printf("%d: %d\n", i, caps_.videoFpsValues[i]);
+    }
+    return 0;
+}
+
+int CameraTest::setParameters()
+{
+    /* temp: using hard-coded values to test the api
+       need to add a user interface or script to get the values to test*/
+    int pSizeIdx = 2;
+    int vSizeIdx = 2;
+    int focusModeIdx = 3;
+    int wbModeIdx = 2;
+    int isoModeIdx = 3;
+    int pFpsIdx = 3;
+    int vFpsIdx = 3;
+
+    pSize_ = caps_.pSizes[pSizeIdx];
+    vSize_ = caps_.pSizes[vSizeIdx];
+
+    printf("setting preview size: %dx%d\n", pSize_.width, pSize_.height);
+    params_.setPreviewSize(pSize_);
+    printf("setting video size: %dx%d\n", vSize_.width, vSize_.height);
+    params_.setVideoSize(vSize_);
+
+    printf("setting focus mode: %s\n", caps_.focusModes[focusModeIdx].c_str());
+    params_.setFocusMode(caps_.focusModes[focusModeIdx]);
+    printf("setting WB mode: %s\n", caps_.wbModes[wbModeIdx].c_str());
+    params_.setWhiteBalance(caps_.wbModes[wbModeIdx]);
+    printf("setting ISO mode: %s\n", caps_.isoModes[isoModeIdx].c_str());
+    params_.setISO(caps_.isoModes[isoModeIdx]);
+
+    printf("setting preview fps range: %d, %d\n",
+           caps_.previewFpsRanges[pFpsIdx].min,
+           caps_.previewFpsRanges[pFpsIdx].max);
+    params_.setPreviewFpsRange(caps_.previewFpsRanges[pFpsIdx]);
+
+    printf("setting video fps: %d\n", caps_.videoFpsValues[vFpsIdx]);
+    params_.setVideoFPS(caps_.videoFpsValues[vFpsIdx]);
+
+    return params_.commit();
+}
+
+int CameraTest::run()
+{
+    int rc = EXIT_SUCCESS;
+
+    int n = getNumberOfCameras();
+
+    printf("num_cameras = %d\n", n);
+
+    if (n < 1) {
+        printf("No cameras found.\n");
+        return EXIT_FAILURE;
+    }
+
+    int camId=0;
+
+    /* find camera based on function */
+    for (int i=0; i<n; i++) {
+        CameraInfo info;
+        getCameraInfo(i, info);
+        if (info.func == config_.func) {
+            camId = i;
+        }
+    }
+
+    printf("testing camera id=%d\n", camId);
+
+    initialize(camId);
+
+    if (config_.infoMode) {
+        printCapabilities();
+        return rc;
+    }
+
+    setParameters();
+
+    /* initialize perf counters */
+    vFrameCount_ = 0;
+    pFrameCount_ = 0;
+    vFpsAvg_ = 0.0f;
+    pFpsAvg_ = 0.0f;
+
+    printf("start preview\n");
+    camera_->startPreview();
+    printf("start recording\n");
+    camera_->startRecording();
+
+    printf("waiting for %d seconds ...\n", config_.runTime);
+
+    sleep(config_.runTime);
+
+    printf("stop recording\n");
+    camera_->stopRecording();
+    printf("stop preview\n");
+    camera_->stopPreview();
+
+    printf("Average preview FPS = %.2f\n", pFpsAvg_);
+    printf("Average video FPS = %.2f\n", vFpsAvg_);
+    return rc;
+}
+
+const char usageStr[] =
+    "Camera API test application \n"
+    "\n"
+    "usage: camera-test [options]\n"
+    "\n"
+    "  -t <duration>   capture duration in seconds [10]\n"
+    "  -d              dump frames\n"
+    "  -i              info mode\n"
+    "                    - print camera capabilities\n"
+    "                    - streaming will not be started\n"
+    "  -f <type>       camera type\n"
+    "                    - hires\n"
+    "                    - optic\n"
+    "  -h              print this message\n"
+;
+
+static inline void printUsageExit(int code)
+{
+    printf("%s", usageStr);
+    exit(code);
+}
+
+/* parses commandline options and populates the config
+   data structure */
+static TestConfig parseCommandline(int argc, char* argv[])
+{
+    TestConfig cfg;
+    /* default config */
+    cfg.dumpFrames = false;
+    cfg.runTime = 10;
+    cfg.func = CAM_FUNC_HIRES;
+    int c;
+    while ((c = getopt(argc, argv, "hdt:if:")) != -1) {
+        switch (c) {;
+          case 't':
+              cfg.runTime = atoi(optarg);
+              break;
+          case 'f':
+          {
+                  string str(optarg);
+                  if (str == "hires") {
+                      cfg.func = CAM_FUNC_HIRES;
+                  } else if (str == "optic") {
+                      cfg.func = CAM_FUNC_OPTIC_FLOW;
+                  }
+                  break;
+          }
+          case 'd':
+              cfg.dumpFrames = true;
+              break;
+          case 'i':
+              cfg.infoMode = true;
+              break;
+          case 'h':
+          case '?':
+              printUsageExit(0);
+          default:
+              abort();
+        }
+    }
+    return cfg;
+}
+
+int main(int argc, char* argv[])
+{
+
+    TestConfig config = parseCommandline(argc, argv);
+
+    CameraTest test(config);
+    test.run();
+
+    return EXIT_SUCCESS;
+}
-- 
1.9.1

