From 0aa4e8a0398f35bf3256e5aef2cf48903f2a3516 Mon Sep 17 00:00:00 2001
From: Suraj Swami <sswami@codeaurora.org>
Date: Fri, 14 Aug 2015 01:08:36 -0700
Subject: [PATCH 15/16] ov7251 RAW data interface changes

---
 QCamera2/HAL/QCamera2HWI.cpp          | 37 +++++++++++++++-
 QCamera2/HAL/QCamera2HWI.h            |  5 +++
 QCamera2/HAL/QCamera2HWICallbacks.cpp | 70 +++++++++++++++++++++++++++++
 QCamera2/HAL/QCameraParameters.cpp    |  3 +-
 libcamera/test/camera_test.cpp        | 83 +++++++++++++++++++++++++++++------
 5 files changed, 182 insertions(+), 16 deletions(-)

diff --git a/QCamera2/HAL/QCamera2HWI.cpp b/QCamera2/HAL/QCamera2HWI.cpp
index c4baf3d..b842666 100644
--- a/QCamera2/HAL/QCamera2HWI.cpp
+++ b/QCamera2/HAL/QCamera2HWI.cpp
@@ -1479,7 +1479,7 @@ uint8_t QCamera2HardwareInterface::getBufNumRequired(cam_stream_type_t stream_ty
 #ifdef _ANDROID_
             //preview window might not be set at this point. So, query directly
             //from BufferQueue implementation of gralloc buffers.
-
+            
             minUndequeCount = BufferQueue::MIN_UNDEQUEUED_BUFFERS;
 #endif
         }
@@ -1547,6 +1547,7 @@ uint8_t QCamera2HardwareInterface::getBufNumRequired(cam_stream_type_t stream_ty
         }
         break;
     case CAM_STREAM_TYPE_RAW:
+#if 0  /* ov7251 raw data interface bringup */
         if (mParameters.isZSLMode()) {
             bufferCnt = zslQBuffers + minCircularBufNum;
         } else {
@@ -1560,6 +1561,10 @@ uint8_t QCamera2HardwareInterface::getBufNumRequired(cam_stream_type_t stream_ty
                 bufferCnt = maxStreamBuf;
             }
         }
+#else
+		bufferCnt = 20;
+#endif
+
         break;
     case CAM_STREAM_TYPE_VIDEO:
         {
@@ -1798,10 +1803,26 @@ QCameraHeapMemory *QCamera2HardwareInterface::allocateStreamInfoBuf(
     streamInfo->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
     switch (stream_type) {
     case CAM_STREAM_TYPE_SNAPSHOT:
+        if ((mParameters.isZSLMode() && mParameters.getRecordingHintValue() != true) ||
+                 mLongshotEnabled) {
+            streamInfo->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
+        } else {
+            streamInfo->streaming_mode = CAM_STREAMING_MODE_BURST;
+            streamInfo->num_of_burst = mParameters.getNumOfSnapshots()
+                + mParameters.getNumOfExtraHDRInBufsIfNeeded()
+                - mParameters.getNumOfExtraHDROutBufsIfNeeded()
+                + mParameters.getNumOfExtraBuffersForImageProc();
+        }
+        break;
     case CAM_STREAM_TYPE_RAW:
+#if 0  /* ov7251 raw data interface bringup */
         if ((mParameters.isZSLMode() && mParameters.getRecordingHintValue() != true) ||
                  mLongshotEnabled) {
+#endif
+
             streamInfo->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
+
+#if 0
         } else {
             streamInfo->streaming_mode = CAM_STREAMING_MODE_BURST;
             streamInfo->num_of_burst = mParameters.getNumOfSnapshots()
@@ -1809,6 +1830,7 @@ QCameraHeapMemory *QCamera2HardwareInterface::allocateStreamInfoBuf(
                 - mParameters.getNumOfExtraHDROutBufsIfNeeded()
                 + mParameters.getNumOfExtraBuffersForImageProc();
         }
+#endif
         break;
     case CAM_STREAM_TYPE_POSTVIEW:
         if (mLongshotEnabled) {
@@ -4022,8 +4044,21 @@ int32_t QCamera2HardwareInterface::addPreviewChannel()
     }
 
     if (isNoDisplayMode()) {
+	    cam_format_t format; /* OV7251 RAW inferface bringup*/
+
+		mParameters.getStreamFormat( CAM_STREAM_TYPE_PREVIEW, format );
+		if( format == CAM_FORMAT_BAYER_MIPI_RAW_10BPP_GBRG )
+		{
+	        rc = addStreamToChannel(pChannel, CAM_STREAM_TYPE_RAW,
+	                                nodisplay_preview_stream_raw_cb_routine, this);
+
+		}
+		else
+		{
         rc = addStreamToChannel(pChannel, CAM_STREAM_TYPE_PREVIEW,
                                 nodisplay_preview_stream_cb_routine, this);
+		}
+
     } else {
         rc = addStreamToChannel(pChannel, CAM_STREAM_TYPE_PREVIEW,
                                 preview_stream_cb_routine, this);
diff --git a/QCamera2/HAL/QCamera2HWI.h b/QCamera2/HAL/QCamera2HWI.h
index 41a6b81..792e416 100644
--- a/QCamera2/HAL/QCamera2HWI.h
+++ b/QCamera2/HAL/QCamera2HWI.h
@@ -453,6 +453,11 @@ private:
     static void nodisplay_preview_stream_cb_routine(mm_camera_super_buf_t *frame,
                                                     QCameraStream *stream,
                                                     void *userdata);
+
+    static void nodisplay_preview_stream_raw_cb_routine(mm_camera_super_buf_t *frame,
+                                                    QCameraStream *stream,
+                                                    void *userdata);
+
     static void preview_stream_cb_routine(mm_camera_super_buf_t *frame,
                                           QCameraStream *stream,
                                           void *userdata);
diff --git a/QCamera2/HAL/QCamera2HWICallbacks.cpp b/QCamera2/HAL/QCamera2HWICallbacks.cpp
index bbb3e3d..af2ee5d 100644
--- a/QCamera2/HAL/QCamera2HWICallbacks.cpp
+++ b/QCamera2/HAL/QCamera2HWICallbacks.cpp
@@ -644,6 +644,76 @@ void QCamera2HardwareInterface::nodisplay_preview_stream_cb_routine(
 }
 
 /*===========================================================================
+ * FUNCTION   : nodisplay_preview_stream_raw_cb_routine
+ *
+ * DESCRIPTION: helper function to handle post frame from preview_raw_stream
+ *
+ * PARAMETERS :
+ *   @super_frame : received super buffer
+ *   @stream      : stream object
+ *   @userdata    : user data ptr
+ *
+ * RETURN    : None
+ *
+ * NOTE      : caller passes the ownership of super_frame, it's our
+ *             responsibility to free super_frame once it's done.
+ *==========================================================================*/
+
+void QCamera2HardwareInterface::nodisplay_preview_stream_raw_cb_routine(
+                                                          mm_camera_super_buf_t *super_frame,
+                                                          QCameraStream *stream,
+                                                          void * userdata)
+{
+	ALOGE("[KPI Perf] %s E",__func__);
+	QCamera2HardwareInterface *pme = (QCamera2HardwareInterface *)userdata;
+	if (pme == NULL ||
+		pme->mCameraHandle == NULL ||
+		pme->mCameraHandle->camera_handle != super_frame->camera_handle){
+		ALOGE("%s: camera obj not valid", __func__);
+		// simply free super frame
+		free(super_frame);
+		return;
+	}
+	mm_camera_buf_def_t *frame = super_frame->bufs[0];
+	if (NULL == frame) {
+		ALOGE("%s: preview frame is NLUL", __func__);
+		free(super_frame);
+		return;
+	}
+
+	QCameraMemory *previewMemObj = (QCameraMemory *)frame->mem_info;
+	camera_memory_t *preview_mem = NULL;
+	if (previewMemObj != NULL) {
+		preview_mem = previewMemObj->getMemory(frame->buf_idx, false);
+	}
+	if (NULL != previewMemObj && NULL != preview_mem) {
+		pme->dumpFrameToFile(stream, frame, QCAMERA_DUMP_FRM_PREVIEW);
+
+		if ( pme->mDataCb != NULL ) {
+
+			qcamera_callback_argm_t cbArg;
+			memset(&cbArg, 0, sizeof(qcamera_callback_argm_t));
+			cbArg.cb_type = QCAMERA_DATA_CALLBACK;
+			cbArg.msg_type = CAMERA_MSG_PREVIEW_FRAME;
+			cbArg.data = preview_mem;
+			int user_data = frame->buf_idx;
+			cbArg.user_data = ( void * ) user_data;
+			cbArg.cookie = stream;
+			cbArg.release_cb = returnStreamBuffer;
+			int32_t rc = pme->m_cbNotifier.notifyCallback(cbArg);
+			if (rc != NO_ERROR) {
+				ALOGE("%s: fail sending data notify", __func__);
+				stream->bufDone(frame->buf_idx);
+			}
+		} else {
+			stream->bufDone(frame->buf_idx);
+		}
+	}
+	free(super_frame);
+	ALOGD("[KPI Perf] %s X",__func__);
+}
+
+/*===========================================================================
  * FUNCTION   : postview_stream_cb_routine
  *
  * DESCRIPTION: helper function to handle post frame from postview stream
diff --git a/QCamera2/HAL/QCameraParameters.cpp b/QCamera2/HAL/QCameraParameters.cpp
index 453dc9e..52d3081 100644
--- a/QCamera2/HAL/QCameraParameters.cpp
+++ b/QCamera2/HAL/QCameraParameters.cpp
@@ -359,7 +359,8 @@ const QCameraParameters::QCameraMap QCameraParameters::PREVIEW_FORMATS_MAP[] = {
     {PIXEL_FORMAT_YUV420SP_ADRENO, CAM_FORMAT_YUV_420_NV21_ADRENO},
     {PIXEL_FORMAT_YV12,            CAM_FORMAT_YUV_420_YV12},
     {PIXEL_FORMAT_NV12,            CAM_FORMAT_YUV_420_NV12},
-    {QC_PIXEL_FORMAT_NV12_VENUS,   CAM_FORMAT_YUV_420_NV12_VENUS}
+    {QC_PIXEL_FORMAT_NV12_VENUS,   CAM_FORMAT_YUV_420_NV12_VENUS},
+    {PIXEL_FORMAT_BAYER_RGGB,   CAM_FORMAT_BAYER_MIPI_RAW_10BPP_GBRG}
 };
 
 const QCameraParameters::QCameraMap QCameraParameters::PICTURE_TYPES_MAP[] = {
diff --git a/libcamera/test/camera_test.cpp b/libcamera/test/camera_test.cpp
index 8b15ee5..71dd878 100644
--- a/libcamera/test/camera_test.cpp
+++ b/libcamera/test/camera_test.cpp
@@ -49,6 +49,11 @@ struct CameraCaps
     vector<VideoFPS> videoFpsValues;
 };
 
+enum OutputFormatType{
+    YUV_FORMAT,
+    RAW_FORMAT,
+};
+
 enum CamFunction {
     CAM_FUNC_HIRES = 0,
     CAM_FUNC_OPTIC_FLOW = 1,
@@ -60,6 +65,7 @@ struct TestConfig
     bool infoMode;
     int runTime;
     CamFunction func;
+    OutputFormatType outputFormat;
 };
 
 class CameraTest : ICameraListener
@@ -174,8 +180,17 @@ void CameraTest::onPreviewFrame(ICameraFrame* frame)
 {
     if (pFrameCount_ > 0 && pFrameCount_ % 30 == 0) {
         char name[32];
-        snprintf(name, 32, "P_%dx%d_%04d.yuv",
+
+        if ( config_.outputFormat == RAW_FORMAT )
+        {
+            snprintf(name, 32, "P_%dx%d_%04d.raw",
+                 pSize_.width, pSize_.height, pFrameCount_);
+        }else{
+             snprintf(name, 32, "P_%dx%d_%04d.yuv",
                  pSize_.width, pSize_.height, pFrameCount_);
+        }
+
+        
         if (config_.dumpFrames == true) {
             dumpToFile(frame->data, frame->size, name);
         }
@@ -252,6 +267,7 @@ int CameraTest::printCapabilities()
     return 0;
 }
 
+ImageSize VGASize(640,480);
 int CameraTest::setParameters()
 {
     /* temp: using hard-coded values to test the api
@@ -267,26 +283,38 @@ int CameraTest::setParameters()
     pSize_ = caps_.pSizes[pSizeIdx];
     vSize_ = caps_.pSizes[vSizeIdx];
 
+    if ( config_.func == CAM_FUNC_OPTIC_FLOW ){
+	pSize_ = VGASize;
+	vSize_ = VGASize;
+    }
+
     printf("setting preview size: %dx%d\n", pSize_.width, pSize_.height);
     params_.setPreviewSize(pSize_);
     printf("setting video size: %dx%d\n", vSize_.width, vSize_.height);
     params_.setVideoSize(vSize_);
 
-    printf("setting focus mode: %s\n", caps_.focusModes[focusModeIdx].c_str());
-    params_.setFocusMode(caps_.focusModes[focusModeIdx]);
-    printf("setting WB mode: %s\n", caps_.wbModes[wbModeIdx].c_str());
-    params_.setWhiteBalance(caps_.wbModes[wbModeIdx]);
-    printf("setting ISO mode: %s\n", caps_.isoModes[isoModeIdx].c_str());
-    params_.setISO(caps_.isoModes[isoModeIdx]);
+    if ( config_.func != CAM_FUNC_OPTIC_FLOW ){
+      printf("setting focus mode: %s\n", caps_.focusModes[focusModeIdx].c_str());
+      params_.setFocusMode(caps_.focusModes[focusModeIdx]);
+      printf("setting WB mode: %s\n", caps_.wbModes[wbModeIdx].c_str());
+      params_.setWhiteBalance(caps_.wbModes[wbModeIdx]);
+      printf("setting ISO mode: %s\n", caps_.isoModes[isoModeIdx].c_str());
+      params_.setISO(caps_.isoModes[isoModeIdx]);
 
-    printf("setting preview fps range: %d, %d\n",
+      printf("setting preview fps range: %d, %d\n",
            caps_.previewFpsRanges[pFpsIdx].min,
            caps_.previewFpsRanges[pFpsIdx].max);
-    params_.setPreviewFpsRange(caps_.previewFpsRanges[pFpsIdx]);
-
-    printf("setting video fps: %d\n", caps_.videoFpsValues[vFpsIdx]);
-    params_.setVideoFPS(caps_.videoFpsValues[vFpsIdx]);
+      params_.setPreviewFpsRange(caps_.previewFpsRanges[pFpsIdx]);
 
+      printf("setting video fps: %d\n", caps_.videoFpsValues[vFpsIdx]);
+      params_.setVideoFPS(caps_.videoFpsValues[vFpsIdx]);
+    }
+    if (config_.outputFormat == RAW_FORMAT)
+    {
+        params_.set("preview-format", "bayer-rggb");
+        params_.set("picture-format", "bayer-mipi-10gbrg");
+        params_.set("raw-size", "640x480");
+    }
     return params_.commit();
 }
 
@@ -333,15 +361,21 @@ int CameraTest::run()
 
     printf("start preview\n");
     camera_->startPreview();
+
+    if( config_.outputFormat != RAW_FORMAT )
+    {
     printf("start recording\n");
     camera_->startRecording();
-
+    }
     printf("waiting for %d seconds ...\n", config_.runTime);
 
     sleep(config_.runTime);
 
+    if( config_.outputFormat != RAW_FORMAT )
+    {
     printf("stop recording\n");
     camera_->stopRecording();
+    }
     printf("stop preview\n");
     camera_->stopPreview();
 
@@ -363,6 +397,9 @@ const char usageStr[] =
     "  -f <type>       camera type\n"
     "                    - hires\n"
     "                    - optic\n"
+    "  -o Output format\n"
+    "                   0 :YUV format (default)\n"
+    "                   1 : RAW format \n"
     "  -h              print this message\n"
 ;
 
@@ -377,12 +414,14 @@ static inline void printUsageExit(int code)
 static TestConfig parseCommandline(int argc, char* argv[])
 {
     TestConfig cfg;
+    cfg.outputFormat = YUV_FORMAT;
+    int outputFormat;
     /* default config */
     cfg.dumpFrames = false;
     cfg.runTime = 10;
     cfg.func = CAM_FUNC_HIRES;
     int c;
-    while ((c = getopt(argc, argv, "hdt:if:")) != -1) {
+    while ((c = getopt(argc, argv, "hdt:if:o:")) != -1) {
         switch (c) {;
           case 't':
               cfg.runTime = atoi(optarg);
@@ -403,6 +442,22 @@ static TestConfig parseCommandline(int argc, char* argv[])
           case 'i':
               cfg.infoMode = true;
               break;
+         case 'o':
+            outputFormat = atoi(optarg);
+            switch ( outputFormat )
+            {
+                case 0: /* IMX135 , IMX214 */
+                   cfg.outputFormat = YUV_FORMAT;
+                   break; 
+                case 1: /* IMX214 */
+                    cfg.outputFormat = RAW_FORMAT;
+                    break;
+                default:
+                    printf("Invalid format. Setting to default YUV_FORMAT");
+                    cfg.outputFormat = YUV_FORMAT;
+                    break;
+            }        
+	        break;  
           case 'h':
           case '?':
               printUsageExit(0);
-- 
1.9.1

