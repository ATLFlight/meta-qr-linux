From bb4cb0c111028008674fd8a4f1591f864566ea95 Mon Sep 17 00:00:00 2001
From: Punit Soni <punits@codeaurora.org>
Date: Thu, 18 Jun 2015 14:22:31 -0700
Subject: [PATCH 7/9] camera-hal: add copy buffer API in qcamlib

Change-Id: I97cf84409e9e05d304db3dbb33602f388fc18efe
---
 qcamlib/README.md     | 42 ++++++++++++++++++++++++++++++++++++++++++
 qcamlib/inc/qcamlib.h | 40 +++++++++++++---------------------------
 qcamlib/src/qcamlib.c | 28 ++++++++++++++++++++++++++++
 3 files changed, 83 insertions(+), 27 deletions(-)
 create mode 100644 qcamlib/README.md

diff --git a/qcamlib/README.md b/qcamlib/README.md
new file mode 100644
index 0000000..730111a
--- /dev/null
+++ b/qcamlib/README.md
@@ -0,0 +1,42 @@
+# qcamlib camera API usage
+
+### example call-flow for preview and video streaming using qcamlib API
+
+~~~{.c}
+#include "qcamlib.h"
+
+qcamlib_t h_cam;
+qcamlib_frame_info_t preview_info, video_info;
+
+h_cam = qcamlib_create();
+
+preview_info = qcamlib_get_frame_info(h_cam, QCAMLIB_STREAM_PREVIEW);
+video_info = qcamlib_get_frame_info(h_cam, QCAMLIB_STREAM_VIDEO);
+
+qcamlib_register_preview_cb(h_cam, preview_cb);
+qcamlib_register_video_cb(h_cam, video_cb);
+
+qcamlib_start_preview(h_cam);
+qcamlib_start_video(h_cam);
+
+// camera is streaming
+
+qcamlib_stop_preview(h_cam);
+qcamlib_stop_video(h_cam);
+
+qcamlib_destroy(h_cam);
+
+void preview_cb(qcamlib_cb_data_t frame)
+{
+    // copy frame to user buffer
+    qcamlib_copy_frame_to_buf(frame, preview_info, buf);
+    // process the frame
+}
+
+void video_cb(qcamlib_cb_data_t frame)
+{
+    // copy frame to user buffer
+    qcamlib_copy_frame_to_buf(frame, video_info, buf);
+    // process the frame
+}
+~~~
\ No newline at end of file
diff --git a/qcamlib/inc/qcamlib.h b/qcamlib/inc/qcamlib.h
index 980edf4..7e32a59 100644
--- a/qcamlib/inc/qcamlib.h
+++ b/qcamlib/inc/qcamlib.h
@@ -33,33 +33,6 @@
  *
  */
 
-/**
- * @mainpage Camera library API documentation
- *
- * API usage
- *
- * @code
- * // call the library functions in following order
- * qcamlib_init();
- * qcamlib_register_preview_cb(preview_cb);
- * qcamlib_start_preview();
- * qcamlib_stop_preview();
- * qcamlib_exit();
- *
- * // define a callback function to process the preview frames
- * void preview_cb(void* frame)
- * {
- *    // copy frame in user buffer
- *    qcamlib_copy_preview_frame(buf, frame, buf_size);
- *    // process the frame
- *    // Its important to make sure the callback returns in reasonable
- *    // time to keep up with the required frame rate
- *    // for 30fps streaming, the callback should return in less than ~33ms
- * }
- * @endcode
- *
- */
-
 #ifndef __QCAMLIB_H__
 #define __QCAMLIB_H__
 
@@ -242,4 +215,17 @@ void qcamlib_set_cb_userdata(qcamlib_t h, void *userdata);
  */
 int qcamlib_configure(qcamlib_t h, qcamlib_config_t config);
 
+/**
+ * @brief copy the frame to a user buffer
+ * 
+ * @param frame frame data received in callback
+ * @param frame_info frame information data
+ * @param buf user allocated buffer
+ * 
+ * @return int 0: success, non-zero: failure
+ */
+int qcamlib_copy_frame_to_buf(qcamlib_cb_data_t frame,
+                              qcamlib_frame_info_t frame_info,
+                              uint8_t *buf);
+
 #endif
diff --git a/qcamlib/src/qcamlib.c b/qcamlib/src/qcamlib.c
index 0d77c0e..274722c 100644
--- a/qcamlib/src/qcamlib.c
+++ b/qcamlib/src/qcamlib.c
@@ -342,3 +342,31 @@ int qcamlib_configure(qcamlib_t h, qcamlib_config_t config)
              h->test_obj.video_height);
     return 0;
 }
+
+int qcamlib_copy_frame_to_buf(qcamlib_cb_data_t frame,
+                              qcamlib_frame_info_t frame_info,
+                              uint8_t *buf)
+{
+    int i;
+    uint32_t src_offset, dest_offset;
+    /* copy one line at a time */
+    /* Y plane */
+    src_offset = frame_info.planes[0].offset;
+    dest_offset = 0;
+    for (i=0; i<frame_info.height; i++) {
+        memcpy(buf + dest_offset, frame.buffer + src_offset,
+               frame_info.width);
+        src_offset += frame_info.planes[0].stride;
+        dest_offset += frame_info.width;
+    }
+    /* UV plane */
+    src_offset = frame_info.planes[1].offset;
+    dest_offset = frame_info.width * frame_info.height;
+    for (i=0; i<frame_info.height/2; i++) {
+        memcpy(buf + dest_offset, frame.buffer + src_offset,
+               frame_info.width);
+        src_offset += frame_info.planes[1].stride;
+        dest_offset += frame_info.width;
+    }
+    return 0;
+}
-- 
1.9.1

